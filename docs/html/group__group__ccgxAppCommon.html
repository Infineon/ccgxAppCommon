<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CCGx App Common</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CCGx App Common</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ccgxAppCommon.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Common source files</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structvdm__info__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structvdm__info__config__t">vdm_info_config_t</a></td></tr>
<tr class="memdesc:structvdm__info__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure hold all VDM Configuration Info.  <a href="group__group__ccgxAppCommon.html#structvdm__info__config__t">More...</a><br /></td></tr>
<tr class="separator:structvdm__info__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structalt__mode__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structalt__mode__config__t">alt_mode_config_t</a></td></tr>
<tr class="memdesc:structalt__mode__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure hold all VDM Configuration Info.  <a href="group__group__ccgxAppCommon.html#structalt__mode__config__t">More...</a><br /></td></tr>
<tr class="separator:structalt__mode__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structapp__status__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structapp__status__t">app_status_t</a></td></tr>
<tr class="memdesc:structapp__status__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure hold all variables related to application layer functionality.  <a href="group__group__ccgxAppCommon.html#structapp__status__t">More...</a><br /></td></tr>
<tr class="separator:structapp__status__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp__sln__handler__t.html">app_sln_handler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure hold all solution level functions used as a part of application layer.  <a href="structapp__sln__handler__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionbc__dp__dm__state__t"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#unionbc__dp__dm__state__t">bc_dp_dm_state_t</a></td></tr>
<tr class="memdesc:unionbc__dp__dm__state__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union to hold Dp/Dm status.  <a href="group__group__ccgxAppCommon.html#unionbc__dp__dm__state__t">More...</a><br /></td></tr>
<tr class="separator:unionbc__dp__dm__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structbc__status__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structbc__status__t">bc_status_t</a></td></tr>
<tr class="memdesc:structbc__status__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to define battery charger status.  <a href="group__group__ccgxAppCommon.html#structbc__status__t">More...</a><br /></td></tr>
<tr class="separator:structbc__status__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionfw__img__status__t"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t">fw_img_status_t</a></td></tr>
<tr class="memdesc:unionfw__img__status__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot mode reason structure.  <a href="group__group__ccgxAppCommon.html#unionfw__img__status__t">More...</a><br /></td></tr>
<tr class="separator:unionfw__img__status__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structfw__img__status__t_1_1fw__mode__reason__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structfw__img__status__t_1_1fw__mode__reason__t">fw_img_status_t::fw_mode_reason_t</a></td></tr>
<tr class="memdesc:structfw__img__status__t_1_1fw__mode__reason__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Structure containing boot reason status bits.  <a href="group__group__ccgxAppCommon.html#structfw__img__status__t_1_1fw__mode__reason__t">More...</a><br /></td></tr>
<tr class="separator:structfw__img__status__t_1_1fw__mode__reason__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsys__fw__metadata__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a></td></tr>
<tr class="memdesc:structsys__fw__metadata__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCGx Firmware metadata structure.  <a href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">More...</a><br /></td></tr>
<tr class="separator:structsys__fw__metadata__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsFWCT__ROW__NO__T"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structsFWCT__ROW__NO__T">sFWCT_ROW_NO_T</a></td></tr>
<tr class="memdesc:structsFWCT__ROW__NO__T"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for row number.  <a href="group__group__ccgxAppCommon.html#structsFWCT__ROW__NO__T">More...</a><br /></td></tr>
<tr class="separator:structsFWCT__ROW__NO__T"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structi2c__scb__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#structi2c__scb__config__t">i2c_scb_config_t</a></td></tr>
<tr class="memdesc:structi2c__scb__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds all configuration associated with each I2C block.  <a href="group__group__ccgxAppCommon.html#structi2c__scb__config__t">More...</a><br /></td></tr>
<tr class="separator:structi2c__scb__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga48ee8ba9b1f5d5aac3735b589ec17807"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga48ee8ba9b1f5d5aac3735b589ec17807">ADC_VBUS_MIN_OVP_LEVEL</a>&#160;&#160;&#160;(6500u)</td></tr>
<tr class="memdesc:ga48ee8ba9b1f5d5aac3735b589ec17807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum OVP detection voltage when ADC is used to implement OVP (applies to CCG4).  <a href="#ga48ee8ba9b1f5d5aac3735b589ec17807">More...</a><br /></td></tr>
<tr class="separator:ga48ee8ba9b1f5d5aac3735b589ec17807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ed46a1a9fe9a580080492ad6a49ac4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga48ed46a1a9fe9a580080492ad6a49ac4">APP_MAX_SWAP_ATTEMPT_COUNT</a>&#160;&#160;&#160;(10u)</td></tr>
<tr class="memdesc:ga48ed46a1a9fe9a580080492ad6a49ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of swap attempts to be made when port partner is sending a WAIT response.  <a href="#ga48ed46a1a9fe9a580080492ad6a49ac4">More...</a><br /></td></tr>
<tr class="separator:ga48ed46a1a9fe9a580080492ad6a49ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e89d3194795f8ca29bfefce338e1bbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6e89d3194795f8ca29bfefce338e1bbf">APP_PSOURCE_CF_TIMER_PERIOD</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:ga6e89d3194795f8ca29bfefce338e1bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of Power Source Current Foldback timer (in ms).  <a href="#ga6e89d3194795f8ca29bfefce338e1bbf">More...</a><br /></td></tr>
<tr class="separator:ga6e89d3194795f8ca29bfefce338e1bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f00fd60d39f9d7c1a72828ee27912d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga01f00fd60d39f9d7c1a72828ee27912d">APP_PSOURCE_DIS_EXT_DIS_TIMER_PERIOD</a>&#160;&#160;&#160;(10u)</td></tr>
<tr class="memdesc:ga01f00fd60d39f9d7c1a72828ee27912d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of extra VBus discharge after voltage drops below desired level (in ms).  <a href="#ga01f00fd60d39f9d7c1a72828ee27912d">More...</a><br /></td></tr>
<tr class="separator:ga01f00fd60d39f9d7c1a72828ee27912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464f5ed341fd5c0aac3229b534acd2e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga464f5ed341fd5c0aac3229b534acd2e0">APP_PSINK_DIS_TIMER_PERIOD</a>&#160;&#160;&#160;(250u)</td></tr>
<tr class="memdesc:ga464f5ed341fd5c0aac3229b534acd2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum time allowed for power sink disable operation (in ms).  <a href="#ga464f5ed341fd5c0aac3229b534acd2e0">More...</a><br /></td></tr>
<tr class="separator:ga464f5ed341fd5c0aac3229b534acd2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea059dcf5842b4a8ab4246f9024d0d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0ea059dcf5842b4a8ab4246f9024d0d6">APP_PSINK_DIS_MONITOR_TIMER_PERIOD</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:ga0ea059dcf5842b4a8ab4246f9024d0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of VBus voltage checks performed during power sink disable operation.  <a href="#ga0ea059dcf5842b4a8ab4246f9024d0d6">More...</a><br /></td></tr>
<tr class="separator:ga0ea059dcf5842b4a8ab4246f9024d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436c6ec5ca5d949a16db4f6009ce2f3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga436c6ec5ca5d949a16db4f6009ce2f3b">APP_PSINK_DIS_VBUS_IN_DIS_PERIOD</a>&#160;&#160;&#160;(20u)</td></tr>
<tr class="memdesc:ga436c6ec5ca5d949a16db4f6009ce2f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of discharge sequence on the VBUS_IN supply in CCG3PA/CCG3PA2 designs.  <a href="#ga436c6ec5ca5d949a16db4f6009ce2f3b">More...</a><br /></td></tr>
<tr class="separator:ga436c6ec5ca5d949a16db4f6009ce2f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5cc2e3b98ffc6a577ebb5b84f08bb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaba5cc2e3b98ffc6a577ebb5b84f08bb6">APP_FAULT_RECOVERY_TIMER_PERIOD</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:gaba5cc2e3b98ffc6a577ebb5b84f08bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of VBus presence checks after a fault (Over-Voltage) detection while in a sink contract.  <a href="#gaba5cc2e3b98ffc6a577ebb5b84f08bb6">More...</a><br /></td></tr>
<tr class="separator:gaba5cc2e3b98ffc6a577ebb5b84f08bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14b4da3bddac22bb8662640ca8991e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf14b4da3bddac22bb8662640ca8991e4">APP_FAULT_RECOVERY_MAX_WAIT</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:gaf14b4da3bddac22bb8662640ca8991e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time for which VBus will be monitored to ensure removal of VBus by a faulty power source.  <a href="#gaf14b4da3bddac22bb8662640ca8991e4">More...</a><br /></td></tr>
<tr class="separator:gaf14b4da3bddac22bb8662640ca8991e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5a29913d04b49fe1887530f5324d69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaeb5a29913d04b49fe1887530f5324d69">APP_SBU_DELAYED_CONNECT_PERIOD</a>&#160;&#160;&#160;(25u)</td></tr>
<tr class="memdesc:gaeb5a29913d04b49fe1887530f5324d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay (in ms) between Thunderbolt mode entry and SBU path configuration.  <a href="#gaeb5a29913d04b49fe1887530f5324d69">More...</a><br /></td></tr>
<tr class="separator:gaeb5a29913d04b49fe1887530f5324d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160c322e22c2802918fe27bcaa395a5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga160c322e22c2802918fe27bcaa395a5d">APP_CBL_DISC_TIMER_PERIOD</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:ga160c322e22c2802918fe27bcaa395a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay to be used between cable discovery init commands.  <a href="#ga160c322e22c2802918fe27bcaa395a5d">More...</a><br /></td></tr>
<tr class="separator:ga160c322e22c2802918fe27bcaa395a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c17e4678455f70881ee50f56a9a04c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0c17e4678455f70881ee50f56a9a04c6">APP_UFP_RECOV_VCONN_SWAP_TIMER_PERIOD</a>&#160;&#160;&#160;(1000u)</td></tr>
<tr class="memdesc:ga0c17e4678455f70881ee50f56a9a04c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer period used to run Vconn swap after V5V was lost and recovered while UFP.  <a href="#ga0c17e4678455f70881ee50f56a9a04c6">More...</a><br /></td></tr>
<tr class="separator:ga0c17e4678455f70881ee50f56a9a04c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621922005aa15762f154e6aaec8e7f9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga621922005aa15762f154e6aaec8e7f9e">APP_VDM_BUSY_TIMER_PERIOD</a>&#160;&#160;&#160;(50u)</td></tr>
<tr class="memdesc:ga621922005aa15762f154e6aaec8e7f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">VDM busy timer period (in ms).  <a href="#ga621922005aa15762f154e6aaec8e7f9e">More...</a><br /></td></tr>
<tr class="separator:ga621922005aa15762f154e6aaec8e7f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f8ad95f104da54535e6acfa7cb339d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga01f8ad95f104da54535e6acfa7cb339d">APP_VDM_FAIL_RETRY_PERIOD</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:ga01f8ad95f104da54535e6acfa7cb339d"><td class="mdescLeft">&#160;</td><td class="mdescRight">VDM retry (on failure) timer period in ms.  <a href="#ga01f8ad95f104da54535e6acfa7cb339d">More...</a><br /></td></tr>
<tr class="separator:ga01f8ad95f104da54535e6acfa7cb339d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d0121c9b69da45b418d4731d0560088"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6d0121c9b69da45b418d4731d0560088">APP_CABLE_POWER_UP_DELAY</a>&#160;&#160;&#160;(55u)</td></tr>
<tr class="memdesc:ga6d0121c9b69da45b418d4731d0560088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time allowed for cable power up to be complete.  <a href="#ga6d0121c9b69da45b418d4731d0560088">More...</a><br /></td></tr>
<tr class="separator:ga6d0121c9b69da45b418d4731d0560088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f383b7187d91a8cf26679f43f88da4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae8f383b7187d91a8cf26679f43f88da4">APP_CABLE_VDM_START_DELAY</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gae8f383b7187d91a8cf26679f43f88da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cable query delay period in ms.  <a href="#gae8f383b7187d91a8cf26679f43f88da4">More...</a><br /></td></tr>
<tr class="separator:gae8f383b7187d91a8cf26679f43f88da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49241b8ddc59d66a473403a3cdeefa2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac49241b8ddc59d66a473403a3cdeefa2">APP_AME_TIMEOUT_TIMER_PERIOD</a>&#160;&#160;&#160;(800u)</td></tr>
<tr class="memdesc:gac49241b8ddc59d66a473403a3cdeefa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tAME timer period (in ms).  <a href="#gac49241b8ddc59d66a473403a3cdeefa2">More...</a><br /></td></tr>
<tr class="separator:gac49241b8ddc59d66a473403a3cdeefa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5076cbaeb4b140f90b4cbb5676fda6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6e5076cbaeb4b140f90b4cbb5676fda6">APP_DB_SNK_FET_DIS_DELAY_TIMER_PERIOD</a>&#160;&#160;&#160;(50u)</td></tr>
<tr class="memdesc:ga6e5076cbaeb4b140f90b4cbb5676fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead battery Sink Fet disable delay timer period.  <a href="#ga6e5076cbaeb4b140f90b4cbb5676fda6">More...</a><br /></td></tr>
<tr class="separator:ga6e5076cbaeb4b140f90b4cbb5676fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739551acfec5c2a24be219159a4aeb7b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga739551acfec5c2a24be219159a4aeb7b">APP_BB_ON_TIMER_PERIOD</a>&#160;&#160;&#160;(250u)</td></tr>
<tr class="memdesc:ga739551acfec5c2a24be219159a4aeb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Billboard ON delay timer period.  <a href="#ga739551acfec5c2a24be219159a4aeb7b">More...</a><br /></td></tr>
<tr class="separator:ga739551acfec5c2a24be219159a4aeb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0483129151558270208971691a02404"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa0483129151558270208971691a02404">APP_INITIATE_DR_SWAP_TIMER_PERIOD</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gaa0483129151558270208971691a02404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time delay between successive DR_SWAP attempts (in ms).  <a href="#gaa0483129151558270208971691a02404">More...</a><br /></td></tr>
<tr class="separator:gaa0483129151558270208971691a02404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba55f9dd8d47c88610b92a4c1912e6dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaba55f9dd8d47c88610b92a4c1912e6dc">APP_INITIATE_PR_SWAP_TIMER_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:gaba55f9dd8d47c88610b92a4c1912e6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time delay between successive PR_SWAP attempts (in ms).  <a href="#gaba55f9dd8d47c88610b92a4c1912e6dc">More...</a><br /></td></tr>
<tr class="separator:gaba55f9dd8d47c88610b92a4c1912e6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbcf0b242232e4ab0fc9d55a030a044"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gacfbcf0b242232e4ab0fc9d55a030a044">APP_INITIATE_SEND_IRQ_CLEAR_ACK_PERIOD</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:gacfbcf0b242232e4ab0fc9d55a030a044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer period for initiating Virtual HPD IRQ CLEAR ACK.  <a href="#gacfbcf0b242232e4ab0fc9d55a030a044">More...</a><br /></td></tr>
<tr class="separator:gacfbcf0b242232e4ab0fc9d55a030a044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c1d0927ce4e392cf0a81e34d3551b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf3c1d0927ce4e392cf0a81e34d3551b3">RIDGE_INIT_HPD_DEQUEUE_TIMER_PERIOD</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:gaf3c1d0927ce4e392cf0a81e34d3551b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer period in ms for initiating virtual HPD dequeue.  <a href="#gaf3c1d0927ce4e392cf0a81e34d3551b3">More...</a><br /></td></tr>
<tr class="separator:gaf3c1d0927ce4e392cf0a81e34d3551b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032924b23e74967dd4c2660dc952ca57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga032924b23e74967dd4c2660dc952ca57">UCSI_CONNECT_EVENT_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:ga032924b23e74967dd4c2660dc952ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay (in ms) between Type-C connection and sending UCSI event notification.  <a href="#ga032924b23e74967dd4c2660dc952ca57">More...</a><br /></td></tr>
<tr class="separator:ga032924b23e74967dd4c2660dc952ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07aa785fe5652792c75864247c857f23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga07aa785fe5652792c75864247c857f23">APP_BC_CDP_SM_TIMER_PERIOD</a>&#160;&#160;&#160;(30000u)</td></tr>
<tr class="memdesc:ga07aa785fe5652792c75864247c857f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">CDP state machine timeout period.  <a href="#ga07aa785fe5652792c75864247c857f23">More...</a><br /></td></tr>
<tr class="separator:ga07aa785fe5652792c75864247c857f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952b6239190fbe12347840ac65095060"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga952b6239190fbe12347840ac65095060">APP_BC_VDP_DM_SRC_ON_PERIOD</a>&#160;&#160;&#160;(50u)</td></tr>
<tr class="memdesc:ga952b6239190fbe12347840ac65095060"><td class="mdescLeft">&#160;</td><td class="mdescRight">VDP_SRC or VDM_SRC minimum turn on time (the minimum from BC 1.2 spec is 40 ms).  <a href="#ga952b6239190fbe12347840ac65095060">More...</a><br /></td></tr>
<tr class="separator:ga952b6239190fbe12347840ac65095060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802e17b67ddf6c5bc540e6781465386c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga802e17b67ddf6c5bc540e6781465386c">APP_BC_VDMSRC_EN_DIS_PERIOD</a>&#160;&#160;&#160;(30u)</td></tr>
<tr class="memdesc:ga802e17b67ddf6c5bc540e6781465386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VDM_SRC enable/disable maximum period.  <a href="#ga802e17b67ddf6c5bc540e6781465386c">More...</a><br /></td></tr>
<tr class="separator:ga802e17b67ddf6c5bc540e6781465386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8f6cb8dc3b43c84c8da2d3d98478d88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac8f6cb8dc3b43c84c8da2d3d98478d88">APP_BC_AFC_SNK_VI_BYTE_PERIOD</a>&#160;&#160;&#160;(80u)</td></tr>
<tr class="memdesc:gac8f6cb8dc3b43c84c8da2d3d98478d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">AFC SNK period between VI_BYTE sending.  <a href="#gac8f6cb8dc3b43c84c8da2d3d98478d88">More...</a><br /></td></tr>
<tr class="separator:gac8f6cb8dc3b43c84c8da2d3d98478d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cab124e91cc9acc71c6f7adb9038cf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2cab124e91cc9acc71c6f7adb9038cf3">CCG_ACTIVITY_TIMER_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:ga2cab124e91cc9acc71c6f7adb9038cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCG activity timer period in ms.  <a href="#ga2cab124e91cc9acc71c6f7adb9038cf3">More...</a><br /></td></tr>
<tr class="separator:ga2cab124e91cc9acc71c6f7adb9038cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d29a70d473dc904258a9b17d6514ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga77d29a70d473dc904258a9b17d6514ea">CCG_ACTIVITY_TIMER_PERIOD_SLEEP</a>&#160;&#160;&#160;(1000u)</td></tr>
<tr class="memdesc:ga77d29a70d473dc904258a9b17d6514ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCG activity timer period during sleep in ms.  <a href="#ga77d29a70d473dc904258a9b17d6514ea">More...</a><br /></td></tr>
<tr class="separator:ga77d29a70d473dc904258a9b17d6514ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24fe082de56f01659d0c627f4cd40c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf24fe082de56f01659d0c627f4cd40c8">OTP_DEBOUNCE_PERIOD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaf24fe082de56f01659d0c627f4cd40c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">OTP debounce timer period in ms.  <a href="#gaf24fe082de56f01659d0c627f4cd40c8">More...</a><br /></td></tr>
<tr class="separator:gaf24fe082de56f01659d0c627f4cd40c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab822a1f5024e9e63df33384a051d6723"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab822a1f5024e9e63df33384a051d6723">TYPE_A_CUR_SENSE_TIMER_PERIOD</a>&#160;&#160;&#160;(30000)</td></tr>
<tr class="memdesc:gab822a1f5024e9e63df33384a051d6723"><td class="mdescLeft">&#160;</td><td class="mdescRight">TYPE-A current sense timer period.  <a href="#gab822a1f5024e9e63df33384a051d6723">More...</a><br /></td></tr>
<tr class="separator:gab822a1f5024e9e63df33384a051d6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3739e828b77c953e208a78b55f0a04f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae3739e828b77c953e208a78b55f0a04f">TYPE_A_REG_SWITCH_TIMER_PERIOD</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:gae3739e828b77c953e208a78b55f0a04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TYPE-A regulator switch timer period in ms.  <a href="#gae3739e828b77c953e208a78b55f0a04f">More...</a><br /></td></tr>
<tr class="separator:gae3739e828b77c953e208a78b55f0a04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25de3e7acfb2fcfbbd1cf174a751681b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga25de3e7acfb2fcfbbd1cf174a751681b">TYPE_A_PWM_STEP_TIMER_PERIOD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga25de3e7acfb2fcfbbd1cf174a751681b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TYPE-A port PWM step change time in ms.  <a href="#ga25de3e7acfb2fcfbbd1cf174a751681b">More...</a><br /></td></tr>
<tr class="separator:ga25de3e7acfb2fcfbbd1cf174a751681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf434604ddd01da1bc02558a54e62b1da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf434604ddd01da1bc02558a54e62b1da">PB_DEBOUNCE_PERIOD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:gaf434604ddd01da1bc02558a54e62b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">PB debounce timer period in ms.  <a href="#gaf434604ddd01da1bc02558a54e62b1da">More...</a><br /></td></tr>
<tr class="separator:gaf434604ddd01da1bc02558a54e62b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b44e1d2929781e8eb43d55b5dc15a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga93b44e1d2929781e8eb43d55b5dc15a8">APP_PB_VBATT_DEBOUNCE_IN_MS</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:ga93b44e1d2929781e8eb43d55b5dc15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PB debounce period in ms.  <a href="#ga93b44e1d2929781e8eb43d55b5dc15a8">More...</a><br /></td></tr>
<tr class="separator:ga93b44e1d2929781e8eb43d55b5dc15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d0eeffd004a72632bc988f5ac8b854"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga30d0eeffd004a72632bc988f5ac8b854">THROTTLE_DEBOUNCE_PERIOD</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:ga30d0eeffd004a72632bc988f5ac8b854"><td class="mdescLeft">&#160;</td><td class="mdescRight">THROTTLE time period in ms.  <a href="#ga30d0eeffd004a72632bc988f5ac8b854">More...</a><br /></td></tr>
<tr class="separator:ga30d0eeffd004a72632bc988f5ac8b854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3950c3b31b9b63c51169e591f7dbfcc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3950c3b31b9b63c51169e591f7dbfcc4">THROTTLE_WAIT_FOR_PD_PERIOD</a>&#160;&#160;&#160;(500)</td></tr>
<tr class="memdesc:ga3950c3b31b9b63c51169e591f7dbfcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">THROTTLE time period in ms.  <a href="#ga3950c3b31b9b63c51169e591f7dbfcc4">More...</a><br /></td></tr>
<tr class="separator:ga3950c3b31b9b63c51169e591f7dbfcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b7d908764a2e9b3383d5ed01e1a575"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac0b7d908764a2e9b3383d5ed01e1a575">APP_BAD_SINK_TIMEOUT_TIMER_PERIOD</a>&#160;&#160;&#160;(1000u)</td></tr>
<tr class="memdesc:gac0b7d908764a2e9b3383d5ed01e1a575"><td class="mdescLeft">&#160;</td><td class="mdescRight">PD bad sink timeout timer period in ms.  <a href="#gac0b7d908764a2e9b3383d5ed01e1a575">More...</a><br /></td></tr>
<tr class="separator:gac0b7d908764a2e9b3383d5ed01e1a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481a8ad0214a446fb2b53c8ad7d45ee0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga481a8ad0214a446fb2b53c8ad7d45ee0">APP_PSOURCE_VBUS_SET_TIMER_PERIOD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga481a8ad0214a446fb2b53c8ad7d45ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power source VBUS set timer period in ms.  <a href="#ga481a8ad0214a446fb2b53c8ad7d45ee0">More...</a><br /></td></tr>
<tr class="separator:ga481a8ad0214a446fb2b53c8ad7d45ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2741da6b697d084158e5df64a11226e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2741da6b697d084158e5df64a11226e8">APP_PSOURCE_SAFE_FET_ON_MONITOR_TIMER_PERIOD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga2741da6b697d084158e5df64a11226e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power source safe FET monitor timer period in ms.  <a href="#ga2741da6b697d084158e5df64a11226e8">More...</a><br /></td></tr>
<tr class="separator:ga2741da6b697d084158e5df64a11226e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ed86145c53b6af4e5604355fe69ffe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga91ed86145c53b6af4e5604355fe69ffe">APP_BC_VBUS_CYCLE_TIMER_PERIOD</a>&#160;&#160;&#160;(200u)</td></tr>
<tr class="memdesc:ga91ed86145c53b6af4e5604355fe69ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">VBUS OFF time to do a VBUS power cycle.  <a href="#ga91ed86145c53b6af4e5604355fe69ffe">More...</a><br /></td></tr>
<tr class="separator:ga91ed86145c53b6af4e5604355fe69ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1309484de31486b864d441874ff27cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa1309484de31486b864d441874ff27cc">APP_BC_SINK_CONTACT_STABLE_TIMER_PERIOD</a>&#160;&#160;&#160;(50u)</td></tr>
<tr class="memdesc:gaa1309484de31486b864d441874ff27cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sink DCD stable time period.  <a href="#gaa1309484de31486b864d441874ff27cc">More...</a><br /></td></tr>
<tr class="separator:gaa1309484de31486b864d441874ff27cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fcc63cdef84679e47d4bda8c78ce918"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5fcc63cdef84679e47d4bda8c78ce918">APP_BC_DCP_DETECT_TIMER_PERIOD</a>&#160;&#160;&#160;(1100u)</td></tr>
<tr class="memdesc:ga5fcc63cdef84679e47d4bda8c78ce918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tglitch_done time waiting for the portable device to complete detection.  <a href="#ga5fcc63cdef84679e47d4bda8c78ce918">More...</a><br /></td></tr>
<tr class="separator:ga5fcc63cdef84679e47d4bda8c78ce918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdc8c28067120799b71088017945a3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabbdc8c28067120799b71088017945a3c">APP_BC_APPLE_DETECT_TIMER_PERIOD</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gabbdc8c28067120799b71088017945a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debounce time to verify if the attached device is Apple or not.  <a href="#gabbdc8c28067120799b71088017945a3c">More...</a><br /></td></tr>
<tr class="separator:gabbdc8c28067120799b71088017945a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dfeb8f9222c7099880e85531a291263"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2dfeb8f9222c7099880e85531a291263">APP_BC_DP_DM_DEBOUNCE_TIMER_PERIOD</a>&#160;&#160;&#160;(40u)</td></tr>
<tr class="memdesc:ga2dfeb8f9222c7099880e85531a291263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debounce time for identifying state change for DP and DM lines.  <a href="#ga2dfeb8f9222c7099880e85531a291263">More...</a><br /></td></tr>
<tr class="separator:ga2dfeb8f9222c7099880e85531a291263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5831ab48406ec2f5b93fee7a198bae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae5831ab48406ec2f5b93fee7a198bae6">APP_BC_AFC_DETECT_TIMER_PERIOD</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:gae5831ab48406ec2f5b93fee7a198bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">AFC detection time.  <a href="#gae5831ab48406ec2f5b93fee7a198bae6">More...</a><br /></td></tr>
<tr class="separator:gae5831ab48406ec2f5b93fee7a198bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b9461a32dea72256e1ee05ff5215e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad6b9461a32dea72256e1ee05ff5215e7">APP_BC_GLITCH_BC_DONE_TIMER_PERIOD</a>&#160;&#160;&#160;(1500)</td></tr>
<tr class="memdesc:gad6b9461a32dea72256e1ee05ff5215e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TGLITCH_BC_DONE timer period.  <a href="#gad6b9461a32dea72256e1ee05ff5215e7">More...</a><br /></td></tr>
<tr class="separator:gad6b9461a32dea72256e1ee05ff5215e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5607ce7ae0d7510f37cb91f6f9be2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadb5607ce7ae0d7510f37cb91f6f9be2a">APP_BC_GLITCH_DM_HIGH_TIMER_PERIOD</a>&#160;&#160;&#160;(40)</td></tr>
<tr class="memdesc:gadb5607ce7ae0d7510f37cb91f6f9be2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">T_GLITCH_DM_HIGH timer period.  <a href="#gadb5607ce7ae0d7510f37cb91f6f9be2a">More...</a><br /></td></tr>
<tr class="separator:gadb5607ce7ae0d7510f37cb91f6f9be2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0803a425ecfebb6c53d88873cefc0190"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0803a425ecfebb6c53d88873cefc0190">APP_BC_V_NEW_REQUEST_TIMER_PERIOD</a>&#160;&#160;&#160;(200)</td></tr>
<tr class="memdesc:ga0803a425ecfebb6c53d88873cefc0190"><td class="mdescLeft">&#160;</td><td class="mdescRight">T_V_NEW_REQUEST timer period.  <a href="#ga0803a425ecfebb6c53d88873cefc0190">More...</a><br /></td></tr>
<tr class="separator:ga0803a425ecfebb6c53d88873cefc0190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c91055c6218bcd4672cca20a3baa7a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9c91055c6218bcd4672cca20a3baa7a8">APP_RESET_VDM_TIMER_PERIOD</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:ga9c91055c6218bcd4672cca20a3baa7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset VDM layer time period.  <a href="#ga9c91055c6218bcd4672cca20a3baa7a8">More...</a><br /></td></tr>
<tr class="separator:ga9c91055c6218bcd4672cca20a3baa7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdbd4d51697948f0f14270b57d56e31d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gacdbd4d51697948f0f14270b57d56e31d">APP_OT_VBE_LOW_TEMP_ADDR</a>&#160;&#160;&#160;(0x0FFFF427)</td></tr>
<tr class="memdesc:gacdbd4d51697948f0f14270b57d56e31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low temperature VBJT code sflash address.  <a href="#gacdbd4d51697948f0f14270b57d56e31d">More...</a><br /></td></tr>
<tr class="separator:gacdbd4d51697948f0f14270b57d56e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad01527eda77352d7a2e171b106c374"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3ad01527eda77352d7a2e171b106c374">APP_OT_VBE_HIGH_TEMP_ADDR</a>&#160;&#160;&#160;(0x0FFFF426)</td></tr>
<tr class="memdesc:ga3ad01527eda77352d7a2e171b106c374"><td class="mdescLeft">&#160;</td><td class="mdescRight">High temperature VBJT code sflash address.  <a href="#ga3ad01527eda77352d7a2e171b106c374">More...</a><br /></td></tr>
<tr class="separator:ga3ad01527eda77352d7a2e171b106c374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbbcabdfeba09aa754c2b172fd5d6116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadbbcabdfeba09aa754c2b172fd5d6116">APP_OT_VBE_25_C_TEMP_ADDR</a>&#160;&#160;&#160;(0x0FFFF428)</td></tr>
<tr class="memdesc:gadbbcabdfeba09aa754c2b172fd5d6116"><td class="mdescLeft">&#160;</td><td class="mdescRight">25C temperature VBJT code sflash address.  <a href="#gadbbcabdfeba09aa754c2b172fd5d6116">More...</a><br /></td></tr>
<tr class="separator:gadbbcabdfeba09aa754c2b172fd5d6116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4234e85f96be459e23fc6efd0cef90"><td class="memItemLeft" align="right" valign="top"><a id="gaea4234e85f96be459e23fc6efd0cef90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaea4234e85f96be459e23fc6efd0cef90">APP_OT_LOW_TEMP</a>&#160;&#160;&#160;(-40)</td></tr>
<tr class="memdesc:gaea4234e85f96be459e23fc6efd0cef90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low temperature which corresponds to low temperature VBJT code stored in sflash (in Celsius degrees) <br /></td></tr>
<tr class="separator:gaea4234e85f96be459e23fc6efd0cef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58a06644cb9e108066f1f832ea0c862b"><td class="memItemLeft" align="right" valign="top"><a id="ga58a06644cb9e108066f1f832ea0c862b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga58a06644cb9e108066f1f832ea0c862b">APP_OT_HIGH_TEMP</a>&#160;&#160;&#160;(120u)</td></tr>
<tr class="memdesc:ga58a06644cb9e108066f1f832ea0c862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">High temperature which corresponds to high temperature VBJT code stored in sflash (in Celsius degrees) <br /></td></tr>
<tr class="separator:ga58a06644cb9e108066f1f832ea0c862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8fbb2893c36373e52ca97b2763779f"><td class="memItemLeft" align="right" valign="top"><a id="ga2d8fbb2893c36373e52ca97b2763779f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2d8fbb2893c36373e52ca97b2763779f">APP_OT_ROOM_TEMP</a>&#160;&#160;&#160;(25)</td></tr>
<tr class="memdesc:ga2d8fbb2893c36373e52ca97b2763779f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Room temperature used for VBJT code stored in sflash (in Celsius degrees) <br /></td></tr>
<tr class="separator:ga2d8fbb2893c36373e52ca97b2763779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2aca79edf3f9e4335d1ff7c8075a776"><td class="memItemLeft" align="right" valign="top"><a id="gaf2aca79edf3f9e4335d1ff7c8075a776"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf2aca79edf3f9e4335d1ff7c8075a776">APP_OT_DETECTION_TIMER_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:gaf2aca79edf3f9e4335d1ff7c8075a776"><td class="mdescLeft">&#160;</td><td class="mdescRight">OT detection scanning period. <br /></td></tr>
<tr class="separator:gaf2aca79edf3f9e4335d1ff7c8075a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd9d464994f7b3443d914d35efe8425"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabfd9d464994f7b3443d914d35efe8425">APP_VCONN_SWAP_PENDING</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:gabfd9d464994f7b3443d914d35efe8425"><td class="mdescLeft">&#160;</td><td class="mdescRight">VConn swap pending bit in the app.  <a href="#gabfd9d464994f7b3443d914d35efe8425">More...</a><br /></td></tr>
<tr class="separator:gabfd9d464994f7b3443d914d35efe8425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cec0c41df24ed096ba250ca1be687b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0cec0c41df24ed096ba250ca1be687b2">APP_DR_SWAP_PENDING</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:ga0cec0c41df24ed096ba250ca1be687b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data Role swap pending bit in the app.  <a href="#ga0cec0c41df24ed096ba250ca1be687b2">More...</a><br /></td></tr>
<tr class="separator:ga0cec0c41df24ed096ba250ca1be687b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae878a7dfb84422d20c3bad027b37a31f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae878a7dfb84422d20c3bad027b37a31f">APP_PR_SWAP_PENDING</a>&#160;&#160;&#160;(4u)</td></tr>
<tr class="memdesc:gae878a7dfb84422d20c3bad027b37a31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power Role swap pending bit in the app.  <a href="#gae878a7dfb84422d20c3bad027b37a31f">More...</a><br /></td></tr>
<tr class="separator:gae878a7dfb84422d20c3bad027b37a31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf741c2d6caa86ff456c51528bd5494d1"><td class="memItemLeft" align="right" valign="top"><a id="gaf741c2d6caa86ff456c51528bd5494d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf741c2d6caa86ff456c51528bd5494d1">APP_RETIMER_DISABLE_DELAY</a>&#160;&#160;&#160;(200u)</td></tr>
<tr class="memdesc:gaf741c2d6caa86ff456c51528bd5494d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time to wait after disconnect to power the retimer off. <br /></td></tr>
<tr class="separator:gaf741c2d6caa86ff456c51528bd5494d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f18e834bcadcafbacba77e8853f909"><td class="memItemLeft" align="right" valign="top"><a id="ga07f18e834bcadcafbacba77e8853f909"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga07f18e834bcadcafbacba77e8853f909">APP_RETIMER_ENABLE_DELAY</a>&#160;&#160;&#160;(100u)</td></tr>
<tr class="memdesc:ga07f18e834bcadcafbacba77e8853f909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time to wait after hard reset to power the retimer ON. <br /></td></tr>
<tr class="separator:ga07f18e834bcadcafbacba77e8853f909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a9f7518ae2f96b3e8024c256b854ab"><td class="memItemLeft" align="right" valign="top"><a id="ga88a9f7518ae2f96b3e8024c256b854ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga88a9f7518ae2f96b3e8024c256b854ab">APP_AUTO_DR_SWAP_TRY_PERIOD</a>&#160;&#160;&#160;(10u)</td></tr>
<tr class="memdesc:ga88a9f7518ae2f96b3e8024c256b854ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait time between DR_Swap tries. <br /></td></tr>
<tr class="separator:ga88a9f7518ae2f96b3e8024c256b854ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd74674ed1783264c19eb25b10e4ffe"><td class="memItemLeft" align="right" valign="top"><a id="gafbd74674ed1783264c19eb25b10e4ffe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafbd74674ed1783264c19eb25b10e4ffe">ICL_VSYS_STABLE_WAIT_TIME</a>&#160;&#160;&#160;(10u)</td></tr>
<tr class="memdesc:gafbd74674ed1783264c19eb25b10e4ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">How long to wait for VSYS to stabilize. <br /></td></tr>
<tr class="separator:gafbd74674ed1783264c19eb25b10e4ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872c4146d391a2ca514a8b4b57a391d2"><td class="memItemLeft" align="right" valign="top"><a id="ga872c4146d391a2ca514a8b4b57a391d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga872c4146d391a2ca514a8b4b57a391d2">TBT_MODE_EXIT_CHECK_PERIOD</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:ga872c4146d391a2ca514a8b4b57a391d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodicity of checking if TBT mode should be exited. <br /></td></tr>
<tr class="separator:ga872c4146d391a2ca514a8b4b57a391d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace142939d09e99d20d8fcdd027e953e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gace142939d09e99d20d8fcdd027e953e4">APP_VCONN_RECOVERY_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:gace142939d09e99d20d8fcdd027e953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay between VConn fault and recovery attempt.  <a href="#gace142939d09e99d20d8fcdd027e953e4">More...</a><br /></td></tr>
<tr class="separator:gace142939d09e99d20d8fcdd027e953e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e4ee6e3ce4dbd59288aa094f5f4a77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac2e4ee6e3ce4dbd59288aa094f5f4a77">APP_ALT_MODE_POLL_PERIOD</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gac2e4ee6e3ce4dbd59288aa094f5f4a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodicity of checking if alt mode which is on pause could be run.  <a href="#gac2e4ee6e3ce4dbd59288aa094f5f4a77">More...</a><br /></td></tr>
<tr class="separator:gac2e4ee6e3ce4dbd59288aa094f5f4a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3f1edb8df276dbddb0385a169af773"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5a3f1edb8df276dbddb0385a169af773">APP_HPD_DEQUE_POLL_PERIOD</a>&#160;&#160;&#160;(3u)</td></tr>
<tr class="memdesc:ga5a3f1edb8df276dbddb0385a169af773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodicity of checking if paused HPD dequeuing could be run.  <a href="#ga5a3f1edb8df276dbddb0385a169af773">More...</a><br /></td></tr>
<tr class="separator:ga5a3f1edb8df276dbddb0385a169af773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b118f6f434f969af4e453f3b2dbe439"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4b118f6f434f969af4e453f3b2dbe439">APP_HPI_VPRO_SUPP_MASK</a>&#160;&#160;&#160;(0x10u)</td></tr>
<tr class="memdesc:ga4b118f6f434f969af4e453f3b2dbe439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to identify is vPro mode supported in HPI host capabilities register.  <a href="#ga4b118f6f434f969af4e453f3b2dbe439">More...</a><br /></td></tr>
<tr class="separator:ga4b118f6f434f969af4e453f3b2dbe439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5da197a5ba89711e55b66c4ee524164"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae5da197a5ba89711e55b66c4ee524164">APP_ALT_MODE_STAT_MASK</a>&#160;&#160;&#160;(0x3Fu)</td></tr>
<tr class="memdesc:gae5da197a5ba89711e55b66c4ee524164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to identify active alternate modes.  <a href="#gae5da197a5ba89711e55b66c4ee524164">More...</a><br /></td></tr>
<tr class="separator:gae5da197a5ba89711e55b66c4ee524164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c09f0e1ad990fb16e17e7fd3f3d87e7"><td class="memItemLeft" align="right" valign="top"><a id="ga4c09f0e1ad990fb16e17e7fd3f3d87e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4c09f0e1ad990fb16e17e7fd3f3d87e7">APP_DISC_COMPLETE_MASK</a>&#160;&#160;&#160;(0x80u)</td></tr>
<tr class="memdesc:ga4c09f0e1ad990fb16e17e7fd3f3d87e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to identify that Discovery process completed. <br /></td></tr>
<tr class="separator:ga4c09f0e1ad990fb16e17e7fd3f3d87e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0fe1c4450a13d4961e29e02b54e445"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gace0fe1c4450a13d4961e29e02b54e445">APP_USB4_ACTIVE_MASK</a>&#160;&#160;&#160;(0x40u)</td></tr>
<tr class="memdesc:gace0fe1c4450a13d4961e29e02b54e445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to identify is USB4 mode entered.  <a href="#gace0fe1c4450a13d4961e29e02b54e445">More...</a><br /></td></tr>
<tr class="separator:gace0fe1c4450a13d4961e29e02b54e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aeb80edad987595b7660ae9faacbc52"><td class="memItemLeft" align="right" valign="top"><a id="ga5aeb80edad987595b7660ae9faacbc52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5aeb80edad987595b7660ae9faacbc52">USB4_EN_HOST_PARAM_MASK</a>&#160;&#160;&#160;(0x20u)</td></tr>
<tr class="memdesc:ga5aeb80edad987595b7660ae9faacbc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to identify that USB4 functionality is enabled. <br /></td></tr>
<tr class="separator:ga5aeb80edad987595b7660ae9faacbc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18bb4085b98dd8670330e54c3a8d6b38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga18bb4085b98dd8670330e54c3a8d6b38">APP_DATA_RESET_TIMER_PERIOD</a>&#160;&#160;&#160;(205u)</td></tr>
<tr class="memdesc:ga18bb4085b98dd8670330e54c3a8d6b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">tDataReset period used by DFP to delay MUX state updates.  <a href="#ga18bb4085b98dd8670330e54c3a8d6b38">More...</a><br /></td></tr>
<tr class="separator:ga18bb4085b98dd8670330e54c3a8d6b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca75f713628a2f98b4c139cfa4a472c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1ca75f713628a2f98b4c139cfa4a472c">APP_DATA_RESET_FAIL_TIMEOUT</a>&#160;&#160;&#160;(295u)</td></tr>
<tr class="memdesc:ga1ca75f713628a2f98b4c139cfa4a472c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tDataResetFail timeout period used by the DFP after expiry of tDataReset timer.  <a href="#ga1ca75f713628a2f98b4c139cfa4a472c">More...</a><br /></td></tr>
<tr class="separator:ga1ca75f713628a2f98b4c139cfa4a472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167af7fb2cd95a22cab0f67525ddb212"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga167af7fb2cd95a22cab0f67525ddb212">BC_CMP_0_IDX</a>&#160;&#160;&#160;(0u)</td></tr>
<tr class="memdesc:ga167af7fb2cd95a22cab0f67525ddb212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Battery charger comparator #1.  <a href="#ga167af7fb2cd95a22cab0f67525ddb212">More...</a><br /></td></tr>
<tr class="separator:ga167af7fb2cd95a22cab0f67525ddb212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f87efabf0db12be8187e184829a4545"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4f87efabf0db12be8187e184829a4545">BC_CMP_1_IDX</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:ga4f87efabf0db12be8187e184829a4545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Battery charger comparator #2.  <a href="#ga4f87efabf0db12be8187e184829a4545">More...</a><br /></td></tr>
<tr class="separator:ga4f87efabf0db12be8187e184829a4545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3657458ae00450c7f70e5fc8155a4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaea3657458ae00450c7f70e5fc8155a4b">BC_AMP_LIMIT</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:gaea3657458ae00450c7f70e5fc8155a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum current across various BC modes: 3.0 A.  <a href="#gaea3657458ae00450c7f70e5fc8155a4b">More...</a><br /></td></tr>
<tr class="separator:gaea3657458ae00450c7f70e5fc8155a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46845bb54e7a35f44014fb12885a5f22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga46845bb54e7a35f44014fb12885a5f22">APPLE_AMP_1A</a>&#160;&#160;&#160;(100)</td></tr>
<tr class="memdesc:ga46845bb54e7a35f44014fb12885a5f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Apple 1.0A brick.  <a href="#ga46845bb54e7a35f44014fb12885a5f22">More...</a><br /></td></tr>
<tr class="separator:ga46845bb54e7a35f44014fb12885a5f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f70e97e177a422a76a1d219fd613fd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3f70e97e177a422a76a1d219fd613fd7">APPLE_AMP_2_1A</a>&#160;&#160;&#160;(210)</td></tr>
<tr class="memdesc:ga3f70e97e177a422a76a1d219fd613fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Apple 2.1A brick.  <a href="#ga3f70e97e177a422a76a1d219fd613fd7">More...</a><br /></td></tr>
<tr class="separator:ga3f70e97e177a422a76a1d219fd613fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24a361f0070e432edf5b883a13b4f85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac24a361f0070e432edf5b883a13b4f85">APPLE_AMP_2_4A</a>&#160;&#160;&#160;(240)</td></tr>
<tr class="memdesc:gac24a361f0070e432edf5b883a13b4f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Apple 2.4A brick.  <a href="#gac24a361f0070e432edf5b883a13b4f85">More...</a><br /></td></tr>
<tr class="separator:gac24a361f0070e432edf5b883a13b4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab359d0ceede9e3b2d8885c82e7557506"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab359d0ceede9e3b2d8885c82e7557506">APPLE_AMP_3A</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:gab359d0ceede9e3b2d8885c82e7557506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Apple 3.0A brick.  <a href="#gab359d0ceede9e3b2d8885c82e7557506">More...</a><br /></td></tr>
<tr class="separator:gab359d0ceede9e3b2d8885c82e7557506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ed46d75073c3e336a26f0221610af8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad5ed46d75073c3e336a26f0221610af8">QC_AMP_5V</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:gad5ed46d75073c3e336a26f0221610af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Quick Charge at 5 V.  <a href="#gad5ed46d75073c3e336a26f0221610af8">More...</a><br /></td></tr>
<tr class="separator:gad5ed46d75073c3e336a26f0221610af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7cc8cd2cbef886c34b765e5cc4ca963"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa7cc8cd2cbef886c34b765e5cc4ca963">QC_AMP_9V</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:gaa7cc8cd2cbef886c34b765e5cc4ca963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Quick Charge at 9 V.  <a href="#gaa7cc8cd2cbef886c34b765e5cc4ca963">More...</a><br /></td></tr>
<tr class="separator:gaa7cc8cd2cbef886c34b765e5cc4ca963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be09768ea825e054fea1e1e512e9e34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1be09768ea825e054fea1e1e512e9e34">QC_AMP_12V</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:ga1be09768ea825e054fea1e1e512e9e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Quick Charge at 12 V.  <a href="#ga1be09768ea825e054fea1e1e512e9e34">More...</a><br /></td></tr>
<tr class="separator:ga1be09768ea825e054fea1e1e512e9e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b570cbe892ecb1b9bd19b3cf5c353cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7b570cbe892ecb1b9bd19b3cf5c353cb">QC_AMP_20V</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:ga7b570cbe892ecb1b9bd19b3cf5c353cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Quick Charge at 20 V.  <a href="#ga7b570cbe892ecb1b9bd19b3cf5c353cb">More...</a><br /></td></tr>
<tr class="separator:ga7b570cbe892ecb1b9bd19b3cf5c353cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab602a3aa3cd9cba505b22e953087bba2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab602a3aa3cd9cba505b22e953087bba2">QC_AMP_CONT</a>&#160;&#160;&#160;(300)</td></tr>
<tr class="memdesc:gab602a3aa3cd9cba505b22e953087bba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current limit for Quick Charge continuous mode.  <a href="#gab602a3aa3cd9cba505b22e953087bba2">More...</a><br /></td></tr>
<tr class="separator:gab602a3aa3cd9cba505b22e953087bba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga402455722fd5e75286769924c8d30a2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga402455722fd5e75286769924c8d30a2e">QC_CONT_VOLT_CHANGE_PER_PULSE</a>&#160;&#160;&#160;(200u)</td></tr>
<tr class="memdesc:ga402455722fd5e75286769924c8d30a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick Charge continuous mode voltage change per pulse received.  <a href="#ga402455722fd5e75286769924c8d30a2e">More...</a><br /></td></tr>
<tr class="separator:ga402455722fd5e75286769924c8d30a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9297cf5a3585ae39c2b5e8651589c321"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9297cf5a3585ae39c2b5e8651589c321">QC3_MIN_VOLT</a>&#160;&#160;&#160;(3400u)</td></tr>
<tr class="memdesc:ga9297cf5a3585ae39c2b5e8651589c321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum supply voltage used in QC charging.  <a href="#ga9297cf5a3585ae39c2b5e8651589c321">More...</a><br /></td></tr>
<tr class="separator:ga9297cf5a3585ae39c2b5e8651589c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23bf04f48baf5f32ad3c54e0eff6309c"><td class="memItemLeft" align="right" valign="top"><a id="ga23bf04f48baf5f32ad3c54e0eff6309c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga23bf04f48baf5f32ad3c54e0eff6309c">CCG_POWER_PRECISION_MULT</a>&#160;&#160;&#160;(100000u)</td></tr>
<tr class="memdesc:ga23bf04f48baf5f32ad3c54e0eff6309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplier used in PDP value simplification. <br /></td></tr>
<tr class="separator:ga23bf04f48baf5f32ad3c54e0eff6309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89daaa8305087861fc507b0598beb8f"><td class="memItemLeft" align="right" valign="top"><a id="gaa89daaa8305087861fc507b0598beb8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa89daaa8305087861fc507b0598beb8f">AFC_DETECT_RETRY_COUNT</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="memdesc:gaa89daaa8305087861fc507b0598beb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">AFC detect retry count. <br /></td></tr>
<tr class="separator:gaa89daaa8305087861fc507b0598beb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eefcece7e9d0213769d481ebac1dd7f"><td class="memItemLeft" align="right" valign="top"><a id="ga2eefcece7e9d0213769d481ebac1dd7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2eefcece7e9d0213769d481ebac1dd7f">AFC_WAIT_DM_RETRY_COUNT</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:ga2eefcece7e9d0213769d481ebac1dd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">AFC wait retry count. <br /></td></tr>
<tr class="separator:ga2eefcece7e9d0213769d481ebac1dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56b19bf0a0428bde914badbebd58064"><td class="memItemLeft" align="right" valign="top"><a id="gac56b19bf0a0428bde914badbebd58064"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac56b19bf0a0428bde914badbebd58064">BC_SINK_SDP_CONNECTED</a>&#160;&#160;&#160;(0x01)</td></tr>
<tr class="memdesc:gac56b19bf0a0428bde914badbebd58064"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC SDP Connected. <br /></td></tr>
<tr class="separator:gac56b19bf0a0428bde914badbebd58064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24c5a92b8cd900cb8511d8097a233b7"><td class="memItemLeft" align="right" valign="top"><a id="gac24c5a92b8cd900cb8511d8097a233b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac24c5a92b8cd900cb8511d8097a233b7">BC_SINK_SEC_CHARGER_DETECT</a>&#160;&#160;&#160;(0x02)</td></tr>
<tr class="memdesc:gac24c5a92b8cd900cb8511d8097a233b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC Sec charger detect Connected. <br /></td></tr>
<tr class="separator:gac24c5a92b8cd900cb8511d8097a233b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dba14872a6196c53e2f366e5177737d"><td class="memItemLeft" align="right" valign="top"><a id="ga6dba14872a6196c53e2f366e5177737d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6dba14872a6196c53e2f366e5177737d">BC_SINK_CDP_CONNECTED</a>&#160;&#160;&#160;(0x03)</td></tr>
<tr class="memdesc:ga6dba14872a6196c53e2f366e5177737d"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC CDP Connected. <br /></td></tr>
<tr class="separator:ga6dba14872a6196c53e2f366e5177737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab621edaeef2ccfa3f45f9ec77d7b8f7d"><td class="memItemLeft" align="right" valign="top"><a id="gab621edaeef2ccfa3f45f9ec77d7b8f7d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab621edaeef2ccfa3f45f9ec77d7b8f7d">BC_SINK_DCP_CONNECTED</a>&#160;&#160;&#160;(0x04)</td></tr>
<tr class="memdesc:gab621edaeef2ccfa3f45f9ec77d7b8f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC DCP Connected. <br /></td></tr>
<tr class="separator:gab621edaeef2ccfa3f45f9ec77d7b8f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c4dd2104b7c5db28607368950807e6"><td class="memItemLeft" align="right" valign="top"><a id="gac4c4dd2104b7c5db28607368950807e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac4c4dd2104b7c5db28607368950807e6">BC_QC_AFC_SNK_MAX_VOLT</a>&#160;&#160;&#160;(CY_PD_VSAFE_15V)</td></tr>
<tr class="memdesc:gac4c4dd2104b7c5db28607368950807e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC QC AFC sink maximum voltage. <br /></td></tr>
<tr class="separator:gac4c4dd2104b7c5db28607368950807e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8e5bacb9cdfbc9634ac004e74ebe3a"><td class="memItemLeft" align="right" valign="top"><a id="gafb8e5bacb9cdfbc9634ac004e74ebe3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafb8e5bacb9cdfbc9634ac004e74ebe3a">BC_QC_AFC_SNK_MIN_VOLT</a>&#160;&#160;&#160;(CY_PD_VSAFE_5V)</td></tr>
<tr class="memdesc:gafb8e5bacb9cdfbc9634ac004e74ebe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC QC AFC sink minimum voltage. <br /></td></tr>
<tr class="separator:gafb8e5bacb9cdfbc9634ac004e74ebe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486bd39275bb935d70690ebd21e1e734"><td class="memItemLeft" align="right" valign="top"><a id="ga486bd39275bb935d70690ebd21e1e734"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga486bd39275bb935d70690ebd21e1e734">BC_QC_AFC_SNK_MAX_CUR</a>&#160;&#160;&#160;(CY_PD_I_3A)</td></tr>
<tr class="memdesc:ga486bd39275bb935d70690ebd21e1e734"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC QC AFC sink maximum current in 1mA units. <br /></td></tr>
<tr class="separator:ga486bd39275bb935d70690ebd21e1e734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c79daaadfe0fa30682a102fa17f8e5b"><td class="memItemLeft" align="right" valign="top"><a id="ga4c79daaadfe0fa30682a102fa17f8e5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4c79daaadfe0fa30682a102fa17f8e5b">BC_QC_AFC_SNK_MIN_CUR</a>&#160;&#160;&#160;(CY_PD_I_1P5A)</td></tr>
<tr class="memdesc:ga4c79daaadfe0fa30682a102fa17f8e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BC QC AFC sink maximum current in 1mA units. <br /></td></tr>
<tr class="separator:ga4c79daaadfe0fa30682a102fa17f8e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bbd0c7ffe4f8305e24009f036345b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga33bbd0c7ffe4f8305e24009f036345b2">GPIO_DM_FIELD_SIZE</a>&#160;&#160;&#160;(3u)</td></tr>
<tr class="memdesc:ga33bbd0c7ffe4f8305e24009f036345b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO drive mode field size.  <a href="#ga33bbd0c7ffe4f8305e24009f036345b2">More...</a><br /></td></tr>
<tr class="separator:ga33bbd0c7ffe4f8305e24009f036345b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb5fee6197441b63d00a3f368cb009e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6cb5fee6197441b63d00a3f368cb009e">GPIO_DM_FIELD_MASK</a>&#160;&#160;&#160;((uint32_t)7u)</td></tr>
<tr class="memdesc:ga6cb5fee6197441b63d00a3f368cb009e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO drive mode field mask without offset.  <a href="#ga6cb5fee6197441b63d00a3f368cb009e">More...</a><br /></td></tr>
<tr class="separator:ga6cb5fee6197441b63d00a3f368cb009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbcad622cbfcc0ed0c8220d4bab44cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3dbcad622cbfcc0ed0c8220d4bab44cb">GPIO_INT_FIELD_MASK</a>&#160;&#160;&#160;((uint32_t)3u)</td></tr>
<tr class="memdesc:ga3dbcad622cbfcc0ed0c8220d4bab44cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO interrupt configuration field mask.  <a href="#ga3dbcad622cbfcc0ed0c8220d4bab44cb">More...</a><br /></td></tr>
<tr class="separator:ga3dbcad622cbfcc0ed0c8220d4bab44cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3978a4eeb5db98937242ef759c4a68da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3978a4eeb5db98937242ef759c4a68da">HSIOM_FIELD_SHIFT</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:ga3978a4eeb5db98937242ef759c4a68da"><td class="mdescLeft">&#160;</td><td class="mdescRight">HSIOM configuration field size as left shift value.  <a href="#ga3978a4eeb5db98937242ef759c4a68da">More...</a><br /></td></tr>
<tr class="separator:ga3978a4eeb5db98937242ef759c4a68da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b028c0e2c77b7e38d60367696a8d8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae6b028c0e2c77b7e38d60367696a8d8e">GPIO_PORT0_INTR_NO</a>&#160;&#160;&#160;(0u)</td></tr>
<tr class="memdesc:gae6b028c0e2c77b7e38d60367696a8d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P0.x pins.  <a href="#gae6b028c0e2c77b7e38d60367696a8d8e">More...</a><br /></td></tr>
<tr class="separator:gae6b028c0e2c77b7e38d60367696a8d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga117d20f6c81874047d283112454fcbdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga117d20f6c81874047d283112454fcbdf">GPIO_PORT1_INTR_NO</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:ga117d20f6c81874047d283112454fcbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P1.x pins.  <a href="#ga117d20f6c81874047d283112454fcbdf">More...</a><br /></td></tr>
<tr class="separator:ga117d20f6c81874047d283112454fcbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae778674e0e5e0ee2f56fd75d000608ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae778674e0e5e0ee2f56fd75d000608ed">GPIO_PORT2_INTR_NO</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:gae778674e0e5e0ee2f56fd75d000608ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P2.x pins.  <a href="#gae778674e0e5e0ee2f56fd75d000608ed">More...</a><br /></td></tr>
<tr class="separator:gae778674e0e5e0ee2f56fd75d000608ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d547bcf05ff8cc9c49a9f564bd1f2b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2d547bcf05ff8cc9c49a9f564bd1f2b6">GPIO_PORT3_INTR_NO</a>&#160;&#160;&#160;(3u)</td></tr>
<tr class="memdesc:ga2d547bcf05ff8cc9c49a9f564bd1f2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P3.x pins.  <a href="#ga2d547bcf05ff8cc9c49a9f564bd1f2b6">More...</a><br /></td></tr>
<tr class="separator:ga2d547bcf05ff8cc9c49a9f564bd1f2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a3f154d45ef0f4b2109665d3d17a52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga22a3f154d45ef0f4b2109665d3d17a52">GPIO_PORT4_INTR_NO</a>&#160;&#160;&#160;(4u)</td></tr>
<tr class="memdesc:ga22a3f154d45ef0f4b2109665d3d17a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P4.x pins.  <a href="#ga22a3f154d45ef0f4b2109665d3d17a52">More...</a><br /></td></tr>
<tr class="separator:ga22a3f154d45ef0f4b2109665d3d17a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf90602703a9c22b87bcabf22dec6e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabcf90602703a9c22b87bcabf22dec6e3">GPIO_PORT5_INTR_NO</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gabcf90602703a9c22b87bcabf22dec6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P5.x pins.  <a href="#gabcf90602703a9c22b87bcabf22dec6e3">More...</a><br /></td></tr>
<tr class="separator:gabcf90602703a9c22b87bcabf22dec6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477235d634a356497e227232e51c50e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga477235d634a356497e227232e51c50e4">GPIO_PORT6_INTR_NO</a>&#160;&#160;&#160;(6u)</td></tr>
<tr class="memdesc:ga477235d634a356497e227232e51c50e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vector number for P6.x pins.  <a href="#ga477235d634a356497e227232e51c50e4">More...</a><br /></td></tr>
<tr class="separator:ga477235d634a356497e227232e51c50e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c68b2056bc85a439c873aae5b0aea4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga25c68b2056bc85a439c873aae5b0aea4">APP_PPS_SNK_CONTRACT_PERIOD</a>&#160;&#160;&#160;(9000u)</td></tr>
<tr class="memdesc:ga25c68b2056bc85a439c873aae5b0aea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period after which a PPS Sink repeats PD contract attempts.  <a href="#ga25c68b2056bc85a439c873aae5b0aea4">More...</a><br /></td></tr>
<tr class="separator:ga25c68b2056bc85a439c873aae5b0aea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96924b0d3e724956428b4a679b956fea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga96924b0d3e724956428b4a679b956fea">APP_PPS_SNK_CONTRACT_RETRY_PERIOD</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:ga96924b0d3e724956428b4a679b956fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period after which a failed PPS sink re-contract attempt will be retried.  <a href="#ga96924b0d3e724956428b4a679b956fea">More...</a><br /></td></tr>
<tr class="separator:ga96924b0d3e724956428b4a679b956fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b8c764d40652ece8483122a5dd37fd"><td class="memItemLeft" align="right" valign="top"><a id="gae3b8c764d40652ece8483122a5dd37fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae3b8c764d40652ece8483122a5dd37fd">PPS_CF_VBUS_DECREMENT_STEP</a>&#160;&#160;&#160;(200u)</td></tr>
<tr class="memdesc:gae3b8c764d40652ece8483122a5dd37fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">VBUS decrement value on each Current foldback event. <br /></td></tr>
<tr class="separator:gae3b8c764d40652ece8483122a5dd37fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a76a453947377f3c581bbdc0e1bd46"><td class="memItemLeft" align="right" valign="top"><a id="ga47a76a453947377f3c581bbdc0e1bd46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga47a76a453947377f3c581bbdc0e1bd46">THROTTLE_TEMP_SENSOR_EN</a>&#160;&#160;&#160;(0x80u)</td></tr>
<tr class="memdesc:ga47a76a453947377f3c581bbdc0e1bd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temperature sensor enable. <br /></td></tr>
<tr class="separator:ga47a76a453947377f3c581bbdc0e1bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bdbdd1d3dc56559b4dedb2ff698463"><td class="memItemLeft" align="right" valign="top"><a id="gae6bdbdd1d3dc56559b4dedb2ff698463"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae6bdbdd1d3dc56559b4dedb2ff698463">THROTTLE_TEMPERATURE_HYSTERESIS</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:gae6bdbdd1d3dc56559b4dedb2ff698463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the hysteresis value to be used for temperature(deg C) based power throttling. <br /></td></tr>
<tr class="separator:gae6bdbdd1d3dc56559b4dedb2ff698463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff95e3b94b21a080b571b9d0c376436"><td class="memItemLeft" align="right" valign="top"><a id="gabff95e3b94b21a080b571b9d0c376436"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabff95e3b94b21a080b571b9d0c376436">THROTTLE_MAX_TEMP</a>&#160;&#160;&#160;(255u)</td></tr>
<tr class="memdesc:gabff95e3b94b21a080b571b9d0c376436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the max temperature value that can be assigned. <br /></td></tr>
<tr class="separator:gabff95e3b94b21a080b571b9d0c376436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad329a21756ff6937e3e0388045ce8400"><td class="memItemLeft" align="right" valign="top"><a id="gad329a21756ff6937e3e0388045ce8400"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad329a21756ff6937e3e0388045ce8400">SLAVE_REG_ADD</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gad329a21756ff6937e3e0388045ce8400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of the first register of the slave. <br /></td></tr>
<tr class="separator:gad329a21756ff6937e3e0388045ce8400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d873728ac3d39072f46280d7074378c"><td class="memItemLeft" align="right" valign="top"><a id="ga4d873728ac3d39072f46280d7074378c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4d873728ac3d39072f46280d7074378c">THROTTLE_VOLT_DIVIDER</a>&#160;&#160;&#160;(18u)</td></tr>
<tr class="memdesc:ga4d873728ac3d39072f46280d7074378c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the voltage divider multiplier value. <br /></td></tr>
<tr class="separator:ga4d873728ac3d39072f46280d7074378c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033d4a356dd64f60a41563e50be4c289"><td class="memItemLeft" align="right" valign="top"><a id="ga033d4a356dd64f60a41563e50be4c289"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga033d4a356dd64f60a41563e50be4c289">THROTTLE_VIN_HYSTERESIS</a>&#160;&#160;&#160;(5u)</td></tr>
<tr class="memdesc:ga033d4a356dd64f60a41563e50be4c289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the hysteresis value to be used for VIN( 100 mV ) based power throttling. <br /></td></tr>
<tr class="separator:ga033d4a356dd64f60a41563e50be4c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad456bb3be6173dae2997daf53c4aabc8"><td class="memItemLeft" align="right" valign="top"><a id="gad456bb3be6173dae2997daf53c4aabc8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad456bb3be6173dae2997daf53c4aabc8">CCG_OC_BUFFER_DATE_TYPE</a>&#160;&#160;&#160;void</td></tr>
<tr class="memdesc:gad456bb3be6173dae2997daf53c4aabc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines data type of OC Buffer. <br /></td></tr>
<tr class="separator:gad456bb3be6173dae2997daf53c4aabc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156253580c66f60c5dcfea33881373b0"><td class="memItemLeft" align="right" valign="top"><a id="ga156253580c66f60c5dcfea33881373b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga156253580c66f60c5dcfea33881373b0">CY_DR_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:ga156253580c66f60c5dcfea33881373b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:ga156253580c66f60c5dcfea33881373b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ba864328b042578dee63a2439c1aee"><td class="memItemLeft" align="right" valign="top"><a id="gad9ba864328b042578dee63a2439c1aee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad9ba864328b042578dee63a2439c1aee">CY_PR_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x0C</td></tr>
<tr class="memdesc:gad9ba864328b042578dee63a2439c1aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">PR SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:gad9ba864328b042578dee63a2439c1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="memItemLeft" align="right" valign="top"><a id="gadcf06cdba1e0d1273aae9a4c083d1f73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadcf06cdba1e0d1273aae9a4c083d1f73">CY_PR_SWAP_RESPONSE_POS</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">PR SWAP Bit Position From Config Table. <br /></td></tr>
<tr class="separator:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c755bc1df32193ff9356904ddb1085"><td class="memItemLeft" align="right" valign="top"><a id="gab2c755bc1df32193ff9356904ddb1085"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab2c755bc1df32193ff9356904ddb1085">CY_VCONN_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x30</td></tr>
<tr class="memdesc:gab2c755bc1df32193ff9356904ddb1085"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCONN SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:gab2c755bc1df32193ff9356904ddb1085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778baf9b3c116c444b11fbc8c185471b"><td class="memItemLeft" align="right" valign="top"><a id="ga778baf9b3c116c444b11fbc8c185471b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga778baf9b3c116c444b11fbc8c185471b">CY_VCONN_SWAP_RESPONSE_POS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga778baf9b3c116c444b11fbc8c185471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCONN SWAP Bit Position From Config Table. <br /></td></tr>
<tr class="separator:ga778baf9b3c116c444b11fbc8c185471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ad292ed4c6e9125cf8ada82635387f"><td class="memItemLeft" align="right" valign="top"><a id="gaf2ad292ed4c6e9125cf8ada82635387f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf2ad292ed4c6e9125cf8ada82635387f">THERMISTOR_FAULT_TEMP</a>&#160;&#160;&#160;(255u)</td></tr>
<tr class="memdesc:gaf2ad292ed4c6e9125cf8ada82635387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the max temperature value that can be assigned for thermistor. <br /></td></tr>
<tr class="separator:gaf2ad292ed4c6e9125cf8ada82635387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2954a974990f62ac8ff354585f89c50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab2954a974990f62ac8ff354585f89c50">UVDM_RESPONSE_MAX_NO_OF_VDO</a>&#160;&#160;&#160;(0x07u)</td></tr>
<tr class="memdesc:gab2954a974990f62ac8ff354585f89c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of VDOs in U_VDM response.  <a href="#gab2954a974990f62ac8ff354585f89c50">More...</a><br /></td></tr>
<tr class="separator:gab2954a974990f62ac8ff354585f89c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b05992ad9a5802c9b2f87887e11730"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad3b05992ad9a5802c9b2f87887e11730">UVDM_HEADER_INDEX</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="memdesc:gad3b05992ad9a5802c9b2f87887e11730"><td class="mdescLeft">&#160;</td><td class="mdescRight">VDM Header index in U_VDM Response.  <a href="#gad3b05992ad9a5802c9b2f87887e11730">More...</a><br /></td></tr>
<tr class="separator:gad3b05992ad9a5802c9b2f87887e11730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f345c8631d3864e38ef43e376017500"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5f345c8631d3864e38ef43e376017500">UVDM_SIGNATURE_BYTE_OFFSET</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="memdesc:ga5f345c8631d3864e38ef43e376017500"><td class="mdescLeft">&#160;</td><td class="mdescRight">U_VDM commands signature byte offset.  <a href="#ga5f345c8631d3864e38ef43e376017500">More...</a><br /></td></tr>
<tr class="separator:ga5f345c8631d3864e38ef43e376017500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c2ca2ef07580bcc2388df9b272d859"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab5c2ca2ef07580bcc2388df9b272d859">UVDM_DEVICE_MODE_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gab5c2ca2ef07580bcc2388df9b272d859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response U_VDM DEVICE_MODE VDO index.  <a href="#gab5c2ca2ef07580bcc2388df9b272d859">More...</a><br /></td></tr>
<tr class="separator:gab5c2ca2ef07580bcc2388df9b272d859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90596a2d4b0963940bea7b40b75d48fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga90596a2d4b0963940bea7b40b75d48fd">UVDM_BOOT_LAST_ROW_VDO_INDEX</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:ga90596a2d4b0963940bea7b40b75d48fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">BOOT LAST ROW VDO Index.  <a href="#ga90596a2d4b0963940bea7b40b75d48fd">More...</a><br /></td></tr>
<tr class="separator:ga90596a2d4b0963940bea7b40b75d48fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd6f0b7289a1dfeae40466fa81609cf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabd6f0b7289a1dfeae40466fa81609cf0">UVDM_BOOT_VERSION_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gabd6f0b7289a1dfeae40466fa81609cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response U_VDM BOOT VERSION VDO index.  <a href="#gabd6f0b7289a1dfeae40466fa81609cf0">More...</a><br /></td></tr>
<tr class="separator:gabd6f0b7289a1dfeae40466fa81609cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7f57d458c1b477b4ff79dede370015"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaca7f57d458c1b477b4ff79dede370015">UVDM_IMG1_VERSION_VDO_INDEX</a>&#160;&#160;&#160;(0x03u)</td></tr>
<tr class="memdesc:gaca7f57d458c1b477b4ff79dede370015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response U_VDM FW Image 1 VERSION VDO index.  <a href="#gaca7f57d458c1b477b4ff79dede370015">More...</a><br /></td></tr>
<tr class="separator:gaca7f57d458c1b477b4ff79dede370015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f926c2c27a7a33cc5afa04ef43a81d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga39f926c2c27a7a33cc5afa04ef43a81d">UVDM_IMG2_VERSION_VDO_INDEX</a>&#160;&#160;&#160;(0x05u)</td></tr>
<tr class="memdesc:ga39f926c2c27a7a33cc5afa04ef43a81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response U_VDM FW Image 2 VERSION VDO index.  <a href="#ga39f926c2c27a7a33cc5afa04ef43a81d">More...</a><br /></td></tr>
<tr class="separator:ga39f926c2c27a7a33cc5afa04ef43a81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43b2696ff167c8ddc29352f1070f463"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab43b2696ff167c8ddc29352f1070f463">UVDM_VERSION_NUM_SIZE_BYTES</a>&#160;&#160;&#160;(0x08u)</td></tr>
<tr class="memdesc:gab43b2696ff167c8ddc29352f1070f463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version number size in bytes.  <a href="#gab43b2696ff167c8ddc29352f1070f463">More...</a><br /></td></tr>
<tr class="separator:gab43b2696ff167c8ddc29352f1070f463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7c9912fa838757eca10599f716b7fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8c7c9912fa838757eca10599f716b7fd">UVDM_GET_VERSION_U_VDM_NO_OF_VDO</a>&#160;&#160;&#160;(0x06u)</td></tr>
<tr class="memdesc:ga8c7c9912fa838757eca10599f716b7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of VDOs in GET_VERSION U_VDM Response.  <a href="#ga8c7c9912fa838757eca10599f716b7fd">More...</a><br /></td></tr>
<tr class="separator:ga8c7c9912fa838757eca10599f716b7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e4c0243c7f18f2b5e37270464aff60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga83e4c0243c7f18f2b5e37270464aff60">UVDM_GET_SILICON_ID_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:ga83e4c0243c7f18f2b5e37270464aff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_SILICON_ID Command size in bytes.  <a href="#ga83e4c0243c7f18f2b5e37270464aff60">More...</a><br /></td></tr>
<tr class="separator:ga83e4c0243c7f18f2b5e37270464aff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2037d0438d77a8f96931acc38c87d0"><td class="memItemLeft" align="right" valign="top"><a id="ga3d2037d0438d77a8f96931acc38c87d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3d2037d0438d77a8f96931acc38c87d0">UVDM_GET_SILICON_ID_CMD_SIG</a>&#160;&#160;&#160;(0x53u)</td></tr>
<tr class="memdesc:ga3d2037d0438d77a8f96931acc38c87d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_SILICON_ID Command Signature: 'S'. <br /></td></tr>
<tr class="separator:ga3d2037d0438d77a8f96931acc38c87d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b4ba91c5e1986f8c27bd1a2564d3d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga80b4ba91c5e1986f8c27bd1a2564d3d0">UVDM_FW1_START_ADDR_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga80b4ba91c5e1986f8c27bd1a2564d3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response UVDM_FW1_START_ADDR VDO index.  <a href="#ga80b4ba91c5e1986f8c27bd1a2564d3d0">More...</a><br /></td></tr>
<tr class="separator:ga80b4ba91c5e1986f8c27bd1a2564d3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2538b360e06eb5c365691588fbc2d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabe2538b360e06eb5c365691588fbc2d6">UVDM_FW2_START_ADDR_VDO_INDEX</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:gabe2538b360e06eb5c365691588fbc2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response UVDM_FW2_START_ADDR VDO index.  <a href="#gabe2538b360e06eb5c365691588fbc2d6">More...</a><br /></td></tr>
<tr class="separator:gabe2538b360e06eb5c365691588fbc2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57792eef4b15e00e098fcf406b974f36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga57792eef4b15e00e098fcf406b974f36">UVDM_GET_FW_START_ADDR_UVDM_NO_OF_VDO</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:ga57792eef4b15e00e098fcf406b974f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of VDOs in GET_FW_START_ADDRESS_UVDM response.  <a href="#ga57792eef4b15e00e098fcf406b974f36">More...</a><br /></td></tr>
<tr class="separator:ga57792eef4b15e00e098fcf406b974f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0867f1eab1166708b321a85939d780a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab0867f1eab1166708b321a85939d780a">UVDM_SILICON_ID_VDO_INDEX</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:gab0867f1eab1166708b321a85939d780a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SILICON_ID VDO index in U_VDM response.  <a href="#gab0867f1eab1166708b321a85939d780a">More...</a><br /></td></tr>
<tr class="separator:gab0867f1eab1166708b321a85939d780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34e8997d907c8bd48f870d8b4d0e4a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa34e8997d907c8bd48f870d8b4d0e4a8">UVDM_DEVICE_RESET_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gaa34e8997d907c8bd48f870d8b4d0e4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEVICE_RESET Command size in bytes.  <a href="#gaa34e8997d907c8bd48f870d8b4d0e4a8">More...</a><br /></td></tr>
<tr class="separator:gaa34e8997d907c8bd48f870d8b4d0e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb814f81573174e948193259d216e46"><td class="memItemLeft" align="right" valign="top"><a id="ga7eb814f81573174e948193259d216e46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7eb814f81573174e948193259d216e46">UVDM_DEVICE_RESET_CMD_SIG</a>&#160;&#160;&#160;(0x52u)</td></tr>
<tr class="memdesc:ga7eb814f81573174e948193259d216e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device RESET Command Signature: 'R'. <br /></td></tr>
<tr class="separator:ga7eb814f81573174e948193259d216e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa890eca2eaf632155b801b141d87e242"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa890eca2eaf632155b801b141d87e242">UVDM_JUMP_TO_BOOT_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gaa890eca2eaf632155b801b141d87e242"><td class="mdescLeft">&#160;</td><td class="mdescRight">JUMP_TO_BOOT Command size in bytes.  <a href="#gaa890eca2eaf632155b801b141d87e242">More...</a><br /></td></tr>
<tr class="separator:gaa890eca2eaf632155b801b141d87e242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6d7dbbcf80ab48842e20ef198eef8d"><td class="memItemLeft" align="right" valign="top"><a id="ga1f6d7dbbcf80ab48842e20ef198eef8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1f6d7dbbcf80ab48842e20ef198eef8d">UVDM_JUMP_TO_BOOT_CMD_SIG</a>&#160;&#160;&#160;('J')</td></tr>
<tr class="memdesc:ga1f6d7dbbcf80ab48842e20ef198eef8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">JUMP_TO_BOOT Command Signature: 'J'. <br /></td></tr>
<tr class="separator:ga1f6d7dbbcf80ab48842e20ef198eef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe134c34890548229981734e59fb9e7"><td class="memItemLeft" align="right" valign="top"><a id="ga0fe134c34890548229981734e59fb9e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0fe134c34890548229981734e59fb9e7">UVDM_JUMP_TO_ALT_FW_SIG</a>&#160;&#160;&#160;('A')</td></tr>
<tr class="memdesc:ga0fe134c34890548229981734e59fb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature value used to request JUMP_TO_ALT_FW: 'A'. <br /></td></tr>
<tr class="separator:ga0fe134c34890548229981734e59fb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a5be1bb44697ec8de515c4051e56e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa3a5be1bb44697ec8de515c4051e56e0">UVDM_ENTER_FLASHING_MODE_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gaa3a5be1bb44697ec8de515c4051e56e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ENTER_FLASHING_MODE Command size in bytes.  <a href="#gaa3a5be1bb44697ec8de515c4051e56e0">More...</a><br /></td></tr>
<tr class="separator:gaa3a5be1bb44697ec8de515c4051e56e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff395aab2936bb52e9e22dd17943cf6"><td class="memItemLeft" align="right" valign="top"><a id="ga5ff395aab2936bb52e9e22dd17943cf6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5ff395aab2936bb52e9e22dd17943cf6">UVDM_ENTER_FLASHING_MODE_CMD_SIG</a>&#160;&#160;&#160;(0x50u)</td></tr>
<tr class="memdesc:ga5ff395aab2936bb52e9e22dd17943cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ENTER FLASHING MODE Command Signature: 'P'. <br /></td></tr>
<tr class="separator:ga5ff395aab2936bb52e9e22dd17943cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43690cb24e3f8a2517756425b148c8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab43690cb24e3f8a2517756425b148c8b">UVDM_FLASH_READ_WRITE_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gab43690cb24e3f8a2517756425b148c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash write and read command size.  <a href="#gab43690cb24e3f8a2517756425b148c8b">More...</a><br /></td></tr>
<tr class="separator:gab43690cb24e3f8a2517756425b148c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808df75a6aa1a05cd8a68de748f77686"><td class="memItemLeft" align="right" valign="top"><a id="ga808df75a6aa1a05cd8a68de748f77686"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga808df75a6aa1a05cd8a68de748f77686">UVDM_FLASH_READ_WRITE_CMD_SIG</a>&#160;&#160;&#160;(0x46u)</td></tr>
<tr class="memdesc:ga808df75a6aa1a05cd8a68de748f77686"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLASH_READ_WRITE Command Signature: 'F'. <br /></td></tr>
<tr class="separator:ga808df75a6aa1a05cd8a68de748f77686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga875522284456917153b40096d0a6d658"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga875522284456917153b40096d0a6d658">UVDM_FLASH_ROW_NUM_LSB_OFFSET</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga875522284456917153b40096d0a6d658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Write and Read command row num LSB offset.  <a href="#ga875522284456917153b40096d0a6d658">More...</a><br /></td></tr>
<tr class="separator:ga875522284456917153b40096d0a6d658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3169e34f384e1e2ba4d72c4ec655d817"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3169e34f384e1e2ba4d72c4ec655d817">UVDM_FLASH_ROW_NUM_MSB_OFFSET</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:ga3169e34f384e1e2ba4d72c4ec655d817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Write and Read command row num MSB offset.  <a href="#ga3169e34f384e1e2ba4d72c4ec655d817">More...</a><br /></td></tr>
<tr class="separator:ga3169e34f384e1e2ba4d72c4ec655d817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677fbbc4ae6b40e81a9012ccecb7c8c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga677fbbc4ae6b40e81a9012ccecb7c8c8">UVDM_READ_DATA_RESPONSE_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga677fbbc4ae6b40e81a9012ccecb7c8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">READ_DATA Response VDO index.  <a href="#ga677fbbc4ae6b40e81a9012ccecb7c8c8">More...</a><br /></td></tr>
<tr class="separator:ga677fbbc4ae6b40e81a9012ccecb7c8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63ba216a1decad34a39f3d6e9dc4261"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf63ba216a1decad34a39f3d6e9dc4261">UVDM_RESPONSE_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gaf63ba216a1decad34a39f3d6e9dc4261"><td class="mdescLeft">&#160;</td><td class="mdescRight">U_VDM Response VDO index.  <a href="#gaf63ba216a1decad34a39f3d6e9dc4261">More...</a><br /></td></tr>
<tr class="separator:gaf63ba216a1decad34a39f3d6e9dc4261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5616636103518742a7f4301711aa26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaec5616636103518742a7f4301711aa26">UVDM_READ_DATA_NO_OF_VDO_ERROR_CASE</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:gaec5616636103518742a7f4301711aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">READ_DATA response no of VDOs in error case.  <a href="#gaec5616636103518742a7f4301711aa26">More...</a><br /></td></tr>
<tr class="separator:gaec5616636103518742a7f4301711aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcecbc396e48b4e434148ccbf8d0ae55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadcecbc396e48b4e434148ccbf8d0ae55">UVDM_VALIDATE_FW_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gadcecbc396e48b4e434148ccbf8d0ae55"><td class="mdescLeft">&#160;</td><td class="mdescRight">VALIDATE_FW command size.  <a href="#gadcecbc396e48b4e434148ccbf8d0ae55">More...</a><br /></td></tr>
<tr class="separator:gadcecbc396e48b4e434148ccbf8d0ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac168c8f26511e6900e643a7d6a8cee20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac168c8f26511e6900e643a7d6a8cee20">UVDM_VALIDATE_FW_MODE_INDEX</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="memdesc:gac168c8f26511e6900e643a7d6a8cee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">VALIDATE_FW Register FW MODE offset.  <a href="#gac168c8f26511e6900e643a7d6a8cee20">More...</a><br /></td></tr>
<tr class="separator:gac168c8f26511e6900e643a7d6a8cee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3abb3c5f66cdd2a05367f2e8ab902bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad3abb3c5f66cdd2a05367f2e8ab902bc">UVDM_REASON_FOR_BOOT_MODE_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gad3abb3c5f66cdd2a05367f2e8ab902bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">REASON_FOR_BOOT_MODE VDO index.  <a href="#gad3abb3c5f66cdd2a05367f2e8ab902bc">More...</a><br /></td></tr>
<tr class="separator:gad3abb3c5f66cdd2a05367f2e8ab902bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994d17a568700bed304773a08ec5b931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga994d17a568700bed304773a08ec5b931">UVDM_GET_CHECKSUM_CMD_SIZE</a>&#160;&#160;&#160;(0x08u)</td></tr>
<tr class="memdesc:ga994d17a568700bed304773a08ec5b931"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CHECKSUM command size.  <a href="#ga994d17a568700bed304773a08ec5b931">More...</a><br /></td></tr>
<tr class="separator:ga994d17a568700bed304773a08ec5b931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea5056961cdabc3683e735e7fe9fc5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6ea5056961cdabc3683e735e7fe9fc5d">UVDM_FLASH_ADDR_LSB_OFFSET</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="memdesc:ga6ea5056961cdabc3683e735e7fe9fc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CHECKSUM CMD FLASH ADDR LSB offset.  <a href="#ga6ea5056961cdabc3683e735e7fe9fc5d">More...</a><br /></td></tr>
<tr class="separator:ga6ea5056961cdabc3683e735e7fe9fc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b6c19ca2fe56f68f970fc466c3fcfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga91b6c19ca2fe56f68f970fc466c3fcfb">UVDM_FLASH_SIZE_LSB_OFFSET</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:ga91b6c19ca2fe56f68f970fc466c3fcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CHECKSUM CMD FLASH SIZE LSB offset.  <a href="#ga91b6c19ca2fe56f68f970fc466c3fcfb">More...</a><br /></td></tr>
<tr class="separator:ga91b6c19ca2fe56f68f970fc466c3fcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f3e075f0704d8a696317c34f418faa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad5f3e075f0704d8a696317c34f418faa">UVDM_CHECKSUM_VDO_INDEX</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gad5f3e075f0704d8a696317c34f418faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CHECKSUM response checksum VDO index.  <a href="#gad5f3e075f0704d8a696317c34f418faa">More...</a><br /></td></tr>
<tr class="separator:gad5f3e075f0704d8a696317c34f418faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55891d85525f6df77dff2ff1fc2d734"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac55891d85525f6df77dff2ff1fc2d734">UVDM_SET_APP_PRIORITY_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:gac55891d85525f6df77dff2ff1fc2d734"><td class="mdescLeft">&#160;</td><td class="mdescRight">SET_APP_PRIORITY command size.  <a href="#gac55891d85525f6df77dff2ff1fc2d734">More...</a><br /></td></tr>
<tr class="separator:gac55891d85525f6df77dff2ff1fc2d734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648b3420c1f04d165bcfbd70c02b9f14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga648b3420c1f04d165bcfbd70c02b9f14">UVDM_SET_APP_PRIORITY_INDEX</a>&#160;&#160;&#160;(0x00u)</td></tr>
<tr class="memdesc:ga648b3420c1f04d165bcfbd70c02b9f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">SET_APP_PRIORITY FW Image priority offset.  <a href="#ga648b3420c1f04d165bcfbd70c02b9f14">More...</a><br /></td></tr>
<tr class="separator:ga648b3420c1f04d165bcfbd70c02b9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d189dd40acbd5de1d0589fa7f8886f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga18d189dd40acbd5de1d0589fa7f8886f">UVDM_SEND_SIGN_SEQUENCE_1</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga18d189dd40acbd5de1d0589fa7f8886f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Signature UVDM Valid Sequence Number 1.  <a href="#ga18d189dd40acbd5de1d0589fa7f8886f">More...</a><br /></td></tr>
<tr class="separator:ga18d189dd40acbd5de1d0589fa7f8886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd66e1c3838ac98c2c8e76b2a9e4af7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadbd66e1c3838ac98c2c8e76b2a9e4af7">UVDM_SEND_SIGN_SEQUENCE_2</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:gadbd66e1c3838ac98c2c8e76b2a9e4af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Signature UVDM Valid Sequence Number 2.  <a href="#gadbd66e1c3838ac98c2c8e76b2a9e4af7">More...</a><br /></td></tr>
<tr class="separator:gadbd66e1c3838ac98c2c8e76b2a9e4af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c2d59daf349cdb793a6b15fa866e6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf8c2d59daf349cdb793a6b15fa866e6a">UVDM_SEND_SIGN_SEQUENCE_3</a>&#160;&#160;&#160;(0x03u)</td></tr>
<tr class="memdesc:gaf8c2d59daf349cdb793a6b15fa866e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Signature UVDM Valid Sequence Number 3.  <a href="#gaf8c2d59daf349cdb793a6b15fa866e6a">More...</a><br /></td></tr>
<tr class="separator:gaf8c2d59daf349cdb793a6b15fa866e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b78b919d93184342809c6b492466dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa9b78b919d93184342809c6b492466dd">UVDM_SEND_SIGN_SEC_1_2_SIZE</a>&#160;&#160;&#160;(0x18u)</td></tr>
<tr class="memdesc:gaa9b78b919d93184342809c6b492466dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Signature UVDM Section 1 and 2 size in Bytes.  <a href="#gaa9b78b919d93184342809c6b492466dd">More...</a><br /></td></tr>
<tr class="separator:gaa9b78b919d93184342809c6b492466dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6dcce53e0e3235a30a7b539d76635d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5d6dcce53e0e3235a30a7b539d76635d">UVDM_SEND_SIGN_SEC_3_SIZE</a>&#160;&#160;&#160;(0x10u)</td></tr>
<tr class="memdesc:ga5d6dcce53e0e3235a30a7b539d76635d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Signature UVDM Section 3 size in Bytes.  <a href="#ga5d6dcce53e0e3235a30a7b539d76635d">More...</a><br /></td></tr>
<tr class="separator:ga5d6dcce53e0e3235a30a7b539d76635d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee3be55ab5d1b13a969d54595bb5584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8ee3be55ab5d1b13a969d54595bb5584">UVDM_GET_CUSTOMER_INFO_SEQ_1</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga8ee3be55ab5d1b13a969d54595bb5584"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CUSTOMER_INFO VDM Sequence Number 1.  <a href="#ga8ee3be55ab5d1b13a969d54595bb5584">More...</a><br /></td></tr>
<tr class="separator:ga8ee3be55ab5d1b13a969d54595bb5584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65da41b1a3a90a4a403e86340e5bc005"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga65da41b1a3a90a4a403e86340e5bc005">UVDM_GET_CUSTOMER_INFO_SEQ_2</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:ga65da41b1a3a90a4a403e86340e5bc005"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CUSTOMER_INFO VDM Sequence Number 2.  <a href="#ga65da41b1a3a90a4a403e86340e5bc005">More...</a><br /></td></tr>
<tr class="separator:ga65da41b1a3a90a4a403e86340e5bc005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2cfa777dabb301ea53159d3dca70e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaff2cfa777dabb301ea53159d3dca70e2">UVDM_GET_CUSTOMER_INFO_RESPONSE_SIZE</a>&#160;&#160;&#160;(0x10u)</td></tr>
<tr class="memdesc:gaff2cfa777dabb301ea53159d3dca70e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CUSTOMER_INFO Response Size in bytes.  <a href="#gaff2cfa777dabb301ea53159d3dca70e2">More...</a><br /></td></tr>
<tr class="separator:gaff2cfa777dabb301ea53159d3dca70e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87505ea1aa920293446fa208eb2115d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga87505ea1aa920293446fa208eb2115d6">UVDM_GET_CUSTOMER_INFO_RESPONSE_VDO_NUM</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:ga87505ea1aa920293446fa208eb2115d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GET_CUSTOMER_INFO number of VDOs in response.  <a href="#ga87505ea1aa920293446fa208eb2115d6">More...</a><br /></td></tr>
<tr class="separator:ga87505ea1aa920293446fa208eb2115d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff4bf17dc2e0a1579346f98bded4707"><td class="memItemLeft" align="right" valign="top"><a id="ga7ff4bf17dc2e0a1579346f98bded4707"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7ff4bf17dc2e0a1579346f98bded4707">UVDM_FWCT_SIG_WRITE_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:ga7ff4bf17dc2e0a1579346f98bded4707"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Signature write command size in bytes. <br /></td></tr>
<tr class="separator:ga7ff4bf17dc2e0a1579346f98bded4707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f51833e79fefa45237eb7ab02b9dd90"><td class="memItemLeft" align="right" valign="top"><a id="ga3f51833e79fefa45237eb7ab02b9dd90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3f51833e79fefa45237eb7ab02b9dd90">UVDM_FWCT_ROW_WRITE_CMD_SIZE</a>&#160;&#160;&#160;(0x04u)</td></tr>
<tr class="memdesc:ga3f51833e79fefa45237eb7ab02b9dd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Row write command size in bytes. <br /></td></tr>
<tr class="separator:ga3f51833e79fefa45237eb7ab02b9dd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf365b97b88b9ebd3586e84051f65e07f"><td class="memItemLeft" align="right" valign="top"><a id="gaf365b97b88b9ebd3586e84051f65e07f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf365b97b88b9ebd3586e84051f65e07f">UVDM_FWCT_SIG_WRITE_CMD_SIG</a>&#160;&#160;&#160;('M')</td></tr>
<tr class="memdesc:gaf365b97b88b9ebd3586e84051f65e07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Signature write command signature. <br /></td></tr>
<tr class="separator:gaf365b97b88b9ebd3586e84051f65e07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ccf4e90d26e608a08f6d442a4d1159"><td class="memItemLeft" align="right" valign="top"><a id="ga11ccf4e90d26e608a08f6d442a4d1159"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga11ccf4e90d26e608a08f6d442a4d1159">UVDM_FWCT_ROW_WRITE_CMD_SIG</a>&#160;&#160;&#160;('N')</td></tr>
<tr class="memdesc:ga11ccf4e90d26e608a08f6d442a4d1159"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Row write command signature. <br /></td></tr>
<tr class="separator:ga11ccf4e90d26e608a08f6d442a4d1159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00fa9d10bf3bb3bc2b36904ae613bdc0"><td class="memItemLeft" align="right" valign="top"><a id="ga00fa9d10bf3bb3bc2b36904ae613bdc0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga00fa9d10bf3bb3bc2b36904ae613bdc0">CCG_STATUS_CODE_OFFSET</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:ga00fa9d10bf3bb3bc2b36904ae613bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCG Status offset. <br /></td></tr>
<tr class="separator:ga00fa9d10bf3bb3bc2b36904ae613bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1bdc60e21d634fe2d4f5a748ab5486"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gade1bdc60e21d634fe2d4f5a748ab5486">CCG_STATUS_TO_HPI_RESPONSE</a>(c)&#160;&#160;&#160;((c) + <a class="el" href="group__group__ccgxAppCommon.html#ga00fa9d10bf3bb3bc2b36904ae613bdc0">CCG_STATUS_CODE_OFFSET</a>)</td></tr>
<tr class="memdesc:gade1bdc60e21d634fe2d4f5a748ab5486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert CCG status code to HPI/UVDM response code.  <a href="#gade1bdc60e21d634fe2d4f5a748ab5486">More...</a><br /></td></tr>
<tr class="separator:gade1bdc60e21d634fe2d4f5a748ab5486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8758d61786a6daa230654a2363c4eb4"><td class="memItemLeft" align="right" valign="top"><a id="gac8758d61786a6daa230654a2363c4eb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac8758d61786a6daa230654a2363c4eb4">VDO_START_IDX</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:gac8758d61786a6daa230654a2363c4eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the starting index of VDO. <br /></td></tr>
<tr class="separator:gac8758d61786a6daa230654a2363c4eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1a6c53c66a4c6633597cc1e5f2a8a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaee1a6c53c66a4c6633597cc1e5f2a8a7">CY_PD_IMG1_FW_STATUS_BIT_MASK</a>&#160;&#160;&#160;(0x08)</td></tr>
<tr class="memdesc:gaee1a6c53c66a4c6633597cc1e5f2a8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for Image-1 FW status bit in Boot mode reason byte.  <a href="#gaee1a6c53c66a4c6633597cc1e5f2a8a7">More...</a><br /></td></tr>
<tr class="separator:gaee1a6c53c66a4c6633597cc1e5f2a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4629436a6d068d87f0e28cb37aafd83d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4629436a6d068d87f0e28cb37aafd83d">CCG_BOOT_MODE_RQT_SIG</a>&#160;&#160;&#160;(0x424Cu)</td></tr>
<tr class="memdesc:ga4629436a6d068d87f0e28cb37aafd83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature used for firmware to indicate boot mode request.  <a href="#ga4629436a6d068d87f0e28cb37aafd83d">More...</a><br /></td></tr>
<tr class="separator:ga4629436a6d068d87f0e28cb37aafd83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46812a8cbac3d4dd71c4dc228572fb83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga46812a8cbac3d4dd71c4dc228572fb83">CCG_FW1_BOOT_RQT_SIG</a>&#160;&#160;&#160;(0x4231u)</td></tr>
<tr class="memdesc:ga46812a8cbac3d4dd71c4dc228572fb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature used to indicate boot FW1 request.  <a href="#ga46812a8cbac3d4dd71c4dc228572fb83">More...</a><br /></td></tr>
<tr class="separator:ga46812a8cbac3d4dd71c4dc228572fb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2148e79850430d38916c2c984a9dc64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa2148e79850430d38916c2c984a9dc64">CCG_FW2_BOOT_RQT_SIG</a>&#160;&#160;&#160;(0x4232u)</td></tr>
<tr class="memdesc:gaa2148e79850430d38916c2c984a9dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature used to indicate boot FW2 request.  <a href="#gaa2148e79850430d38916c2c984a9dc64">More...</a><br /></td></tr>
<tr class="separator:gaa2148e79850430d38916c2c984a9dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2518cdc374b4223d58ebe712d8b0c8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae2518cdc374b4223d58ebe712d8b0c8d">CCG_FW_METADATA_BOOTSEQ_OFFSET</a>&#160;&#160;&#160;(0x1Cu)</td></tr>
<tr class="memdesc:gae2518cdc374b4223d58ebe712d8b0c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Firmware boot sequence number offset.  <a href="#gae2518cdc374b4223d58ebe712d8b0c8d">More...</a><br /></td></tr>
<tr class="separator:gae2518cdc374b4223d58ebe712d8b0c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74341b7a5afab68f365959025d0a0851"><td class="memItemLeft" align="right" valign="top"><a id="ga74341b7a5afab68f365959025d0a0851"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga74341b7a5afab68f365959025d0a0851">CCG_BL_WAIT_DEFAULT</a>&#160;&#160;&#160;(50u)</td></tr>
<tr class="memdesc:ga74341b7a5afab68f365959025d0a0851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default boot-wait window for CCGx boot-loader: 50 ms. <br /></td></tr>
<tr class="separator:ga74341b7a5afab68f365959025d0a0851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3bf5638047ecde260210d115c5c0cd"><td class="memItemLeft" align="right" valign="top"><a id="gaed3bf5638047ecde260210d115c5c0cd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaed3bf5638047ecde260210d115c5c0cd">CCG_BL_WAIT_MINIMUM</a>&#160;&#160;&#160;(20u)</td></tr>
<tr class="memdesc:gaed3bf5638047ecde260210d115c5c0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum boot-wait window duration supported: 20 ms. <br /></td></tr>
<tr class="separator:gaed3bf5638047ecde260210d115c5c0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ded94b001a9dbbb1631ee6524accef"><td class="memItemLeft" align="right" valign="top"><a id="ga40ded94b001a9dbbb1631ee6524accef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga40ded94b001a9dbbb1631ee6524accef">CCG_BL_WAIT_MAXIMUM</a>&#160;&#160;&#160;(1000u)</td></tr>
<tr class="memdesc:ga40ded94b001a9dbbb1631ee6524accef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum boot-wait window duration supported: 1000 ms. <br /></td></tr>
<tr class="separator:ga40ded94b001a9dbbb1631ee6524accef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d83312efd628a2ae20735621eb2df0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2d83312efd628a2ae20735621eb2df0d">CCG_FWMETA_APPID_WAIT_DEF</a>&#160;&#160;&#160;(0xFFFFu)</td></tr>
<tr class="memdesc:ga2d83312efd628a2ae20735621eb2df0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FW metadata application ID value requesting default boot-wait window.  <a href="#ga2d83312efd628a2ae20735621eb2df0d">More...</a><br /></td></tr>
<tr class="separator:ga2d83312efd628a2ae20735621eb2df0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab112db7a8197e81a852641526d3f41d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab112db7a8197e81a852641526d3f41d6">CCG_FWMETA_APPID_WAIT_0</a>&#160;&#160;&#160;(0x4946u)</td></tr>
<tr class="memdesc:gab112db7a8197e81a852641526d3f41d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">FW metadata application ID value requesting a zero boot-wait window.  <a href="#gab112db7a8197e81a852641526d3f41d6">More...</a><br /></td></tr>
<tr class="separator:gab112db7a8197e81a852641526d3f41d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7254214f39297c8998882f135ffdf7"><td class="memItemLeft" align="right" valign="top"><a id="ga9d7254214f39297c8998882f135ffdf7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9d7254214f39297c8998882f135ffdf7">CONFIGTABLE_SIGNATURE</a>&#160;&#160;&#160;(0x4946u)</td></tr>
<tr class="memdesc:ga9d7254214f39297c8998882f135ffdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature used to validate config table content. <br /></td></tr>
<tr class="separator:ga9d7254214f39297c8998882f135ffdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31eb9aa72aa9164ccd72df617fbc81be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga31eb9aa72aa9164ccd72df617fbc81be">CONFIGTABLE_SIZE_OFFSET</a>&#160;&#160;&#160;(6u)</td></tr>
<tr class="memdesc:ga31eb9aa72aa9164ccd72df617fbc81be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to table size field in config table.  <a href="#ga31eb9aa72aa9164ccd72df617fbc81be">More...</a><br /></td></tr>
<tr class="separator:ga31eb9aa72aa9164ccd72df617fbc81be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec1266abf1be1cf53fa4c02a55ac2ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6ec1266abf1be1cf53fa4c02a55ac2ea">CONFIGTABLE_CHECKSUM_OFFSET</a>&#160;&#160;&#160;(8u)</td></tr>
<tr class="memdesc:ga6ec1266abf1be1cf53fa4c02a55ac2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset to checksum field in config table.  <a href="#ga6ec1266abf1be1cf53fa4c02a55ac2ea">More...</a><br /></td></tr>
<tr class="separator:ga6ec1266abf1be1cf53fa4c02a55ac2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff74513994e58a5f54bacdde7839e515"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaff74513994e58a5f54bacdde7839e515">CONFIGTABLE_CHECKSUM_START</a>&#160;&#160;&#160;(12u)</td></tr>
<tr class="memdesc:gaff74513994e58a5f54bacdde7839e515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset at which table checksum calculation starts.  <a href="#gaff74513994e58a5f54bacdde7839e515">More...</a><br /></td></tr>
<tr class="separator:gaff74513994e58a5f54bacdde7839e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79f9e16114680b19eae3f38a6832fde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac79f9e16114680b19eae3f38a6832fde">SROM_API_PARAM_SIZE</a>&#160;&#160;&#160;(8u)</td></tr>
<tr class="memdesc:gac79f9e16114680b19eae3f38a6832fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of flash write SROM API parameters in bytes.  <a href="#gac79f9e16114680b19eae3f38a6832fde">More...</a><br /></td></tr>
<tr class="separator:gac79f9e16114680b19eae3f38a6832fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bad9041973178a25edc29bb0c1ec79c"><td class="memItemLeft" align="right" valign="top"><a id="ga5bad9041973178a25edc29bb0c1ec79c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5bad9041973178a25edc29bb0c1ec79c">CCG_FLASH_SIZE</a>&#160;&#160;&#160;(CY_FLASH_SIZE)</td></tr>
<tr class="memdesc:ga5bad9041973178a25edc29bb0c1ec79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCGx FLASH OPTIONS. <br /></td></tr>
<tr class="separator:ga5bad9041973178a25edc29bb0c1ec79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45cae8f297464ef4487c82e6c7079840"><td class="memItemLeft" align="right" valign="top"><a id="ga45cae8f297464ef4487c82e6c7079840"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga45cae8f297464ef4487c82e6c7079840">CCG_FWCT_TABLE_SIZE</a>&#160;&#160;&#160;(104u)</td></tr>
<tr class="memdesc:ga45cae8f297464ef4487c82e6c7079840"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Table size. <br /></td></tr>
<tr class="separator:ga45cae8f297464ef4487c82e6c7079840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4effda95262afbdcec57b0b57c9265c0"><td class="memItemLeft" align="right" valign="top"><a id="ga4effda95262afbdcec57b0b57c9265c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4effda95262afbdcec57b0b57c9265c0">CCG_GUID_SIZE</a>&#160;&#160;&#160;(16u)</td></tr>
<tr class="memdesc:ga4effda95262afbdcec57b0b57c9265c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">GUID size. <br /></td></tr>
<tr class="separator:ga4effda95262afbdcec57b0b57c9265c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530ec4b47251e619c9c3aae6b27df29d"><td class="memItemLeft" align="right" valign="top"><a id="ga530ec4b47251e619c9c3aae6b27df29d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga530ec4b47251e619c9c3aae6b27df29d">FWCT_SIGNATURE</a>&#160;&#160;&#160;(0x54435746u)</td></tr>
<tr class="memdesc:ga530ec4b47251e619c9c3aae6b27df29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Signature. <br /></td></tr>
<tr class="separator:ga530ec4b47251e619c9c3aae6b27df29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b13d198a47bd5390bc69f862c8bc4be"><td class="memItemLeft" align="right" valign="top"><a id="ga3b13d198a47bd5390bc69f862c8bc4be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3b13d198a47bd5390bc69f862c8bc4be">CCG_SHA256_HASH_SIZE</a>&#160;&#160;&#160;(32u)</td></tr>
<tr class="memdesc:ga3b13d198a47bd5390bc69f862c8bc4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-256 fw hash Size. <br /></td></tr>
<tr class="separator:ga3b13d198a47bd5390bc69f862c8bc4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea425f587608ac30f2aeb5489c556e54"><td class="memItemLeft" align="right" valign="top"><a id="gaea425f587608ac30f2aeb5489c556e54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaea425f587608ac30f2aeb5489c556e54">CCG_FW_VER_SIZE</a>&#160;&#160;&#160;(8u)</td></tr>
<tr class="memdesc:gaea425f587608ac30f2aeb5489c556e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">FW version size. <br /></td></tr>
<tr class="separator:gaea425f587608ac30f2aeb5489c556e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf0b93d8bb76e0a0faf7de6515b950d"><td class="memItemLeft" align="right" valign="top"><a id="ga8cf0b93d8bb76e0a0faf7de6515b950d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8cf0b93d8bb76e0a0faf7de6515b950d">PKEY_NUM_OFFSET</a>&#160;&#160;&#160;(57u)</td></tr>
<tr class="memdesc:ga8cf0b93d8bb76e0a0faf7de6515b950d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key number offset. <br /></td></tr>
<tr class="separator:ga8cf0b93d8bb76e0a0faf7de6515b950d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33254039bd3eeb23a640f8cdbcb4fa34"><td class="memItemLeft" align="right" valign="top"><a id="ga33254039bd3eeb23a640f8cdbcb4fa34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga33254039bd3eeb23a640f8cdbcb4fa34">PKEY_EXP_OFFSET</a>&#160;&#160;&#160;(65u)</td></tr>
<tr class="memdesc:ga33254039bd3eeb23a640f8cdbcb4fa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key exponent offset. <br /></td></tr>
<tr class="separator:ga33254039bd3eeb23a640f8cdbcb4fa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7e9bd421bb893c30a5f6bcc742389b"><td class="memItemLeft" align="right" valign="top"><a id="ga9d7e9bd421bb893c30a5f6bcc742389b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9d7e9bd421bb893c30a5f6bcc742389b">CCG_FWCT_SIG_SIZE</a>&#160;&#160;&#160;(256u)</td></tr>
<tr class="memdesc:ga9d7e9bd421bb893c30a5f6bcc742389b"><td class="mdescLeft">&#160;</td><td class="mdescRight">FWCT Signature Size. <br /></td></tr>
<tr class="separator:ga9d7e9bd421bb893c30a5f6bcc742389b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cf50b29b8b6666e945b97b5ee7702b"><td class="memItemLeft" align="right" valign="top"><a id="gac3cf50b29b8b6666e945b97b5ee7702b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac3cf50b29b8b6666e945b97b5ee7702b">MAX_FLASH_WRITE_CNT</a>&#160;&#160;&#160;(99u)</td></tr>
<tr class="memdesc:gac3cf50b29b8b6666e945b97b5ee7702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum flash write count. <br /></td></tr>
<tr class="separator:gac3cf50b29b8b6666e945b97b5ee7702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bb63e6e66da9af3d87a788cf28a0e9"><td class="memItemLeft" align="right" valign="top"><a id="gac5bb63e6e66da9af3d87a788cf28a0e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac5bb63e6e66da9af3d87a788cf28a0e9">PRIMARY_FW_MD_ROW</a>&#160;&#160;&#160;(0x1FFu)</td></tr>
<tr class="memdesc:gac5bb63e6e66da9af3d87a788cf28a0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata Row Number of the Primary Firmware. <br /></td></tr>
<tr class="separator:gac5bb63e6e66da9af3d87a788cf28a0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ef9b621ace5ca0aa7bf099fe5ee789"><td class="memItemLeft" align="right" valign="top"><a id="gaa1ef9b621ace5ca0aa7bf099fe5ee789"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa1ef9b621ace5ca0aa7bf099fe5ee789">SECONDARY_FW_MD_ROW</a>&#160;&#160;&#160;(<a class="el" href="group__group__ccgxAppCommon.html#gac5bb63e6e66da9af3d87a788cf28a0e9">PRIMARY_FW_MD_ROW</a>)</td></tr>
<tr class="memdesc:gaa1ef9b621ace5ca0aa7bf099fe5ee789"><td class="mdescLeft">&#160;</td><td class="mdescRight">If single image application, set this field to contain the primary image metadata row. <br /></td></tr>
<tr class="separator:gaa1ef9b621ace5ca0aa7bf099fe5ee789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef0c100dd883c3c502961aa4ec2ff21"><td class="memItemLeft" align="right" valign="top"><a id="gaaef0c100dd883c3c502961aa4ec2ff21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaaef0c100dd883c3c502961aa4ec2ff21">PKEY_1_FLASH_ROW</a>&#160;&#160;&#160;(0x14u)</td></tr>
<tr class="memdesc:gaaef0c100dd883c3c502961aa4ec2ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public Key-1 Row number. <br /></td></tr>
<tr class="separator:gaaef0c100dd883c3c502961aa4ec2ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fdf1b3e46a20bf640d088db256906f6"><td class="memItemLeft" align="right" valign="top"><a id="ga8fdf1b3e46a20bf640d088db256906f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8fdf1b3e46a20bf640d088db256906f6">PKEY_2_FLASH_ROW</a>&#160;&#160;&#160;(0x16u)</td></tr>
<tr class="memdesc:ga8fdf1b3e46a20bf640d088db256906f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public Key-1 Row number. <br /></td></tr>
<tr class="separator:ga8fdf1b3e46a20bf640d088db256906f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04efbaf3c874bd6f8c53bd351f1ace1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad04efbaf3c874bd6f8c53bd351f1ace1">FLASH_INVALID_ROW_NUMBER</a>&#160;&#160;&#160;(0xFFFFu)</td></tr>
<tr class="memdesc:gad04efbaf3c874bd6f8c53bd351f1ace1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid row numer is used to check against the read row number given to validate it.  <a href="#gad04efbaf3c874bd6f8c53bd351f1ace1">More...</a><br /></td></tr>
<tr class="separator:gad04efbaf3c874bd6f8c53bd351f1ace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff9f3a8493ed4cca0e1e49986f6947c5"><td class="memItemLeft" align="right" valign="top"><a id="gaff9f3a8493ed4cca0e1e49986f6947c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaff9f3a8493ed4cca0e1e49986f6947c5">CRYPTO_ALGORITHM_USED</a>&#160;&#160;&#160;(SHA256_RSA2048)</td></tr>
<tr class="memdesc:gaff9f3a8493ed4cca0e1e49986f6947c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to indicate type of crypto algorithm used. <br /></td></tr>
<tr class="separator:gaff9f3a8493ed4cca0e1e49986f6947c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829e5d246f885d98ad982a48274a3a33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga829e5d246f885d98ad982a48274a3a33">CALL_MAP</a>(str)&#160;&#160;&#160;(str)</td></tr>
<tr class="memdesc:ga829e5d246f885d98ad982a48274a3a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROM/Flash function and variable access macro redirection.  <a href="#ga829e5d246f885d98ad982a48274a3a33">More...</a><br /></td></tr>
<tr class="separator:ga829e5d246f885d98ad982a48274a3a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a56dcdff67c86033f0c01b8348ceef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga52a56dcdff67c86033f0c01b8348ceef">SYS_BOOT_VERSION_ADDRESS</a>&#160;&#160;&#160;(0x000000E0u)</td></tr>
<tr class="memdesc:ga52a56dcdff67c86033f0c01b8348ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot loader version address in FLASH.  <a href="#ga52a56dcdff67c86033f0c01b8348ceef">More...</a><br /></td></tr>
<tr class="separator:ga52a56dcdff67c86033f0c01b8348ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb7d76d557aac1feaeffab0238c1a2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8fb7d76d557aac1feaeffab0238c1a2c">SYS_FW_VERSION_OFFSET</a>&#160;&#160;&#160;(0x000000E0u)</td></tr>
<tr class="memdesc:ga8fb7d76d557aac1feaeffab0238c1a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of FW version from start of FW image in flash.  <a href="#ga8fb7d76d557aac1feaeffab0238c1a2c">More...</a><br /></td></tr>
<tr class="separator:ga8fb7d76d557aac1feaeffab0238c1a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053ccc9a3f265802af4480f97351f69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2053ccc9a3f265802af4480f97351f69">SYS_APP_VERSION_OFFSET</a>&#160;&#160;&#160;(0x00000004u)</td></tr>
<tr class="memdesc:ga2053ccc9a3f265802af4480f97351f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of App version from start of firmware version.  <a href="#ga2053ccc9a3f265802af4480f97351f69">More...</a><br /></td></tr>
<tr class="separator:ga2053ccc9a3f265802af4480f97351f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9db8ce72753c10e59e1317724d29bd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac9db8ce72753c10e59e1317724d29bd6">SYS_SILICON_ID_OFFSET</a>&#160;&#160;&#160;(0x000000EAu)</td></tr>
<tr class="memdesc:gac9db8ce72753c10e59e1317724d29bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of Silicon ID stored in FW image in flash.  <a href="#gac9db8ce72753c10e59e1317724d29bd6">More...</a><br /></td></tr>
<tr class="separator:gac9db8ce72753c10e59e1317724d29bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c7eb50fd605e56c5d8aeb962311999"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae1c7eb50fd605e56c5d8aeb962311999">SYS_BOOT_TYPE_FIELD_OFFSET</a>&#160;&#160;&#160;(0x000000ECu)</td></tr>
<tr class="memdesc:gae1c7eb50fd605e56c5d8aeb962311999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of Bootloader type in Bootloader flash region.  <a href="#gae1c7eb50fd605e56c5d8aeb962311999">More...</a><br /></td></tr>
<tr class="separator:gae1c7eb50fd605e56c5d8aeb962311999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558779f9eb98a2b13d4a78c8b82019cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga558779f9eb98a2b13d4a78c8b82019cb">SYS_FW_CUSTOM_INFO_OFFSET</a>&#160;&#160;&#160;(0x000000C0u)</td></tr>
<tr class="memdesc:ga558779f9eb98a2b13d4a78c8b82019cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of Customer Specific Info from FW start.  <a href="#ga558779f9eb98a2b13d4a78c8b82019cb">More...</a><br /></td></tr>
<tr class="separator:ga558779f9eb98a2b13d4a78c8b82019cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8881e3c46b0145464725e9062288b3"><td class="memItemLeft" align="right" valign="top"><a id="gafa8881e3c46b0145464725e9062288b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafa8881e3c46b0145464725e9062288b3">SYS_METADATA_VALID_SIG</a>&#160;&#160;&#160;(0x4359u)</td></tr>
<tr class="memdesc:gafa8881e3c46b0145464725e9062288b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata table valid signature: "CY". <br /></td></tr>
<tr class="separator:gafa8881e3c46b0145464725e9062288b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e838d6dd17a17f5e919cf5916d10162"><td class="memItemLeft" align="right" valign="top"><a id="ga8e838d6dd17a17f5e919cf5916d10162"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8e838d6dd17a17f5e919cf5916d10162">SYS_PSEUDO_METADATA_VALID_SIG</a>&#160;&#160;&#160;(0x4350u)</td></tr>
<tr class="memdesc:ga8e838d6dd17a17f5e919cf5916d10162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo-Metadata valid signature: "CP". <br /></td></tr>
<tr class="separator:ga8e838d6dd17a17f5e919cf5916d10162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872c442af3386c4c2118e3abdcf259f0"><td class="memItemLeft" align="right" valign="top"><a id="ga872c442af3386c4c2118e3abdcf259f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga872c442af3386c4c2118e3abdcf259f0">SYS_BOOT_MODE_RQT_SIG</a>&#160;&#160;&#160;(0x424Cu)</td></tr>
<tr class="memdesc:ga872c442af3386c4c2118e3abdcf259f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot Mode Request Signature: "BL". <br /></td></tr>
<tr class="separator:ga872c442af3386c4c2118e3abdcf259f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1888aeb134c2710e07dee476b0856282"><td class="memItemLeft" align="right" valign="top"><a id="ga1888aeb134c2710e07dee476b0856282"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1888aeb134c2710e07dee476b0856282">SYS_CONFIG_TABLE_SIGN</a>&#160;&#160;&#160;(0x4359u)</td></tr>
<tr class="memdesc:ga1888aeb134c2710e07dee476b0856282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration table valid signature: "CY". <br /></td></tr>
<tr class="separator:ga1888aeb134c2710e07dee476b0856282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c60fd38d0cf4391ea6185073aa4a90e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2c60fd38d0cf4391ea6185073aa4a90e">SYS_INVALID_FW_START_ADDR</a>&#160;&#160;&#160;(0x00000000u)</td></tr>
<tr class="memdesc:ga2c60fd38d0cf4391ea6185073aa4a90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid FW Start Address.  <a href="#ga2c60fd38d0cf4391ea6185073aa4a90e">More...</a><br /></td></tr>
<tr class="separator:ga2c60fd38d0cf4391ea6185073aa4a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf755f850acb81fe1c79b2862c8f11c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaacf755f850acb81fe1c79b2862c8f11c">SYS_BOOT_TYPE_SECURE_BOOT_MASK</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:gaacf755f850acb81fe1c79b2862c8f11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get Secure Boot feature bit in BL type.  <a href="#gaacf755f850acb81fe1c79b2862c8f11c">More...</a><br /></td></tr>
<tr class="separator:gaacf755f850acb81fe1c79b2862c8f11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318342e3edd398cec8a3d2faf13a7d42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga318342e3edd398cec8a3d2faf13a7d42">SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_POS</a>&#160;&#160;&#160;(0x01u)</td></tr>
<tr class="memdesc:ga318342e3edd398cec8a3d2faf13a7d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of FW update interface bit in BL type.  <a href="#ga318342e3edd398cec8a3d2faf13a7d42">More...</a><br /></td></tr>
<tr class="separator:ga318342e3edd398cec8a3d2faf13a7d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b580e0f52dd71dc8653db16c9b66b8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5b580e0f52dd71dc8653db16c9b66b8e">SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_MASK</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:ga5b580e0f52dd71dc8653db16c9b66b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to get FW update interface bit in BL type.  <a href="#ga5b580e0f52dd71dc8653db16c9b66b8e">More...</a><br /></td></tr>
<tr class="separator:ga5b580e0f52dd71dc8653db16c9b66b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c6da4c670474b3f3546572ea241fba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac4c6da4c670474b3f3546572ea241fba">SYS_BOOT_TYPE_APP_PRIORITY_POS</a>&#160;&#160;&#160;(0x02u)</td></tr>
<tr class="memdesc:gac4c6da4c670474b3f3546572ea241fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of app priority bit in Bootloader type.  <a href="#gac4c6da4c670474b3f3546572ea241fba">More...</a><br /></td></tr>
<tr class="separator:gac4c6da4c670474b3f3546572ea241fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24fc2b8e4c341d7abdcefc315bf4a1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad24fc2b8e4c341d7abdcefc315bf4a1d">SYS_SILICON_ID_MASK</a>&#160;&#160;&#160;(0xFF00u)</td></tr>
<tr class="memdesc:gad24fc2b8e4c341d7abdcefc315bf4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask to extract the device ID from Silicon ID.  <a href="#gad24fc2b8e4c341d7abdcefc315bf4a1d">More...</a><br /></td></tr>
<tr class="separator:gad24fc2b8e4c341d7abdcefc315bf4a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac455ffb620f153f74c1d077a3a50cbb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac455ffb620f153f74c1d077a3a50cbb5">I2C_BLOCK_COUNT</a>&#160;&#160;&#160;(4u)</td></tr>
<tr class="memdesc:gac455ffb620f153f74c1d077a3a50cbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of I2C blocks supported by the device.  <a href="#gac455ffb620f153f74c1d077a3a50cbb5">More...</a><br /></td></tr>
<tr class="separator:gac455ffb620f153f74c1d077a3a50cbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6754f4029a711074afd8b63960b795bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6754f4029a711074afd8b63960b795bc">I2C_CLEAR_INTR_MASK</a>&#160;&#160;&#160;(0x00000000u)</td></tr>
<tr class="memdesc:ga6754f4029a711074afd8b63960b795bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to clear Interrupt mask bits.  <a href="#ga6754f4029a711074afd8b63960b795bc">More...</a><br /></td></tr>
<tr class="separator:ga6754f4029a711074afd8b63960b795bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedba4e22294441cbd1727dc45ab20a51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaedba4e22294441cbd1727dc45ab20a51">I2C_CLEAR_INTR_REQUEST_REG</a>&#160;&#160;&#160;(0xFFFFFFFFu)</td></tr>
<tr class="memdesc:gaedba4e22294441cbd1727dc45ab20a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to clear Interrupt request bits.  <a href="#gaedba4e22294441cbd1727dc45ab20a51">More...</a><br /></td></tr>
<tr class="separator:gaedba4e22294441cbd1727dc45ab20a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a38c7ab96be675f851393a68aea1e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga02a38c7ab96be675f851393a68aea1e0">I2C_SCB_FIFO_SIZE</a>&#160;&#160;&#160;(8u)</td></tr>
<tr class="memdesc:ga02a38c7ab96be675f851393a68aea1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of FIFO in the SCB block for I2C transfers.  <a href="#ga02a38c7ab96be675f851393a68aea1e0">More...</a><br /></td></tr>
<tr class="separator:ga02a38c7ab96be675f851393a68aea1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68bc5185f3c65ebbc2dce1d7c750bea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac68bc5185f3c65ebbc2dce1d7c750bea">I2C_SCB_RX_FIFO_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__group__ccgxAppCommon.html#ga02a38c7ab96be675f851393a68aea1e0">I2C_SCB_FIFO_SIZE</a>)</td></tr>
<tr class="memdesc:gac68bc5185f3c65ebbc2dce1d7c750bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of FIFO provided by the SCB block for I2C read (incoming data) transfers.  <a href="#gac68bc5185f3c65ebbc2dce1d7c750bea">More...</a><br /></td></tr>
<tr class="separator:gac68bc5185f3c65ebbc2dce1d7c750bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1363753bae06613ab2be5bdb52ba7bba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1363753bae06613ab2be5bdb52ba7bba">I2C_SCB_TX_FIFO_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__group__ccgxAppCommon.html#ga02a38c7ab96be675f851393a68aea1e0">I2C_SCB_FIFO_SIZE</a>)</td></tr>
<tr class="memdesc:ga1363753bae06613ab2be5bdb52ba7bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of FIFO provided by the SCB block for I2C write (outgoing data) transfers.  <a href="#ga1363753bae06613ab2be5bdb52ba7bba">More...</a><br /></td></tr>
<tr class="separator:ga1363753bae06613ab2be5bdb52ba7bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8024fe32ce8273fce98e4f8c16455288"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8024fe32ce8273fce98e4f8c16455288">I2C_SLAVE_ADDR_MASK_DEFAULT</a>&#160;&#160;&#160;(0xFEu)</td></tr>
<tr class="memdesc:ga8024fe32ce8273fce98e4f8c16455288"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Slave address mask to be applied on received preamble.  <a href="#ga8024fe32ce8273fce98e4f8c16455288">More...</a><br /></td></tr>
<tr class="separator:ga8024fe32ce8273fce98e4f8c16455288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cd8596f98f94d90c2ec74c003f5a45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab7cd8596f98f94d90c2ec74c003f5a45">I2C_SLAVE_TIMER_BASE</a>&#160;&#160;&#160;(111)</td></tr>
<tr class="memdesc:gab7cd8596f98f94d90c2ec74c003f5a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base ID of timers reserved for I2C transfer timeout implementation.  <a href="#gab7cd8596f98f94d90c2ec74c003f5a45">More...</a><br /></td></tr>
<tr class="separator:gab7cd8596f98f94d90c2ec74c003f5a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88834404a8fdafcbbfbb1f0266897165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga88834404a8fdafcbbfbb1f0266897165">I2C_SLAVE_TIMER_PERIOD</a>&#160;&#160;&#160;(500u)</td></tr>
<tr class="memdesc:ga88834404a8fdafcbbfbb1f0266897165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout period for I2C transfers in milliseconds.  <a href="#ga88834404a8fdafcbbfbb1f0266897165">More...</a><br /></td></tr>
<tr class="separator:ga88834404a8fdafcbbfbb1f0266897165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga05e5e6e022e2fb8b6a30b303f9a0d2fe"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">gpio_intr_cb_t</a>) (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, bool pin_state)</td></tr>
<tr class="memdesc:ga05e5e6e022e2fb8b6a30b303f9a0d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback type for GPIO interrupt notification.  <a href="#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">More...</a><br /></td></tr>
<tr class="separator:ga05e5e6e022e2fb8b6a30b303f9a0d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07a7ee21510d24dac6326ec163d8e3c"><td class="memItemLeft" align="right" valign="top"><a id="gaa07a7ee21510d24dac6326ec163d8e3c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa07a7ee21510d24dac6326ec163d8e3c">instrumentation_cb_t</a>) (uint8_t port, uint8_t evt)</td></tr>
<tr class="memdesc:gaa07a7ee21510d24dac6326ec163d8e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to solution level handler for instrumentation faults. <br /></td></tr>
<tr class="separator:gaa07a7ee21510d24dac6326ec163d8e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad247990093dcf83bc7a86f1215878b05"><td class="memItemLeft" align="right" valign="top"><a id="gad247990093dcf83bc7a86f1215878b05"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a>) (<a class="el" href="group__group__ccgxAppCommon.html#ga459a4d34fea4545cb049bcbc0aa2924c">i2c_cb_cmd_t</a> cmd, <a class="el" href="group__group__ccgxAppCommon.html#gacebb36a46a6b7abb6d95ff1847116864">i2c_scb_state_t</a> i2c_state, uint16_t count)</td></tr>
<tr class="memdesc:gad247990093dcf83bc7a86f1215878b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C callback function for interrupt notifications. <br /></td></tr>
<tr class="separator:gad247990093dcf83bc7a86f1215878b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1091be6e2b432c69d3d21af326fa2243"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1091be6e2b432c69d3d21af326fa2243">app_port_fault_status_mask_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243ae6e9ae0dff1b80979b9d82c25ca78e80">APP_PORT_FAULT_NONE</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a14f805c5f221be2f3523752ccd3cb99f">APP_PORT_VCONN_FAULT_ACTIVE</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a746978b97a8c945dac70f8d323fa3391">APP_PORT_SINK_FAULT_ACTIVE</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a9b9d2e82cf54849646723777d17d65a4">APP_PORT_SRC_FAULT_ACTIVE</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a1be76ddd79458e2d827f64bb8850a182">APP_PORT_VBUS_DROP_WAIT_ACTIVE</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a02b6ba427b9bed14bda05f4af2bfe77c">APP_PORT_V5V_SUPPLY_LOST</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1091be6e2b432c69d3d21af326fa2243a5a496d7a46fb7c0dfccd37845e4faab3">APP_PORT_DISABLE_IN_PROGRESS</a> = 0x80
<br />
 }<tr class="memdesc:ga1091be6e2b432c69d3d21af326fa2243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fault detection and handling related status bits tracked in the fault_status field.  <a href="group__group__ccgxAppCommon.html#ga1091be6e2b432c69d3d21af326fa2243">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1091be6e2b432c69d3d21af326fa2243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2137d1a6e9ce52725c9677ce5a5b8ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa2137d1a6e9ce52725c9677ce5a5b8ce">app_nb_sys_pwr_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8ceaaf3d873168899417c392960172abf412">NB_SYS_PWR_STATE_S0</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8ceaa1c1f259360b15c397915ec4fdd72adc">NB_SYS_PWR_STATE_S3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8cea0b0296dbf5da772b85b7155c5a6016cc">NB_SYS_PWR_STATE_S4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8ceaae6d812fd459e73f898126a9ebccce3b">NB_SYS_PWR_STATE_S5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8cea8aea5281edfb1de8ed31bdff5cf877ae">NB_SYS_PWR_STATE_MOD_STBY</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaa2137d1a6e9ce52725c9677ce5a5b8cea486495f7a6aa41e5fa82eb6236aef202">NB_SYS_PWR_STATE_G3</a>
<br />
 }<tr class="memdesc:gaa2137d1a6e9ce52725c9677ce5a5b8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of system power states for Notebook/Desktop designs.  <a href="group__group__ccgxAppCommon.html#gaa2137d1a6e9ce52725c9677ce5a5b8ce">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaa2137d1a6e9ce52725c9677ce5a5b8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777691ea974d8d40f8dd07454e7a91c3"><td class="memItemLeft" align="right" valign="top"><a id="ga777691ea974d8d40f8dd07454e7a91c3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga777691ea974d8d40f8dd07454e7a91c3">app_cfg_sub_table_type_t</a> { <br />
&#160;&#160;<b>CONFIG_SUB_TABLE_OVP</b> = 0, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_OCP</b> = 1, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_SCP</b> = 2, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_RCP</b> = 3, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_OTP</b> = 4, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_VCONN_OCP</b> = 5, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_INTL_PF</b> = 6, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_PD_HOST</b> = 7, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_TBT_HOST</b> = 8, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_CUST_AM</b> = 9, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_ALT_MODE</b> = 10, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_BCR</b> = 11, 
<br />
&#160;&#160;<b>CONFIG_SUB_TABLE_AMD</b> = 12
<br />
 }<tr class="memdesc:ga777691ea974d8d40f8dd07454e7a91c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of sub-table types in the configuration table for the application. <br /></td></tr>
</td></tr>
<tr class="separator:ga777691ea974d8d40f8dd07454e7a91c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28ca7d6bdea64e62f33e874641a230a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga28ca7d6bdea64e62f33e874641a230a0a188e72a84ccbdd0868fd135b6764049a">MUX_STATE_IDLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga28ca7d6bdea64e62f33e874641a230a0a037e061efc69e608af6613c741cd3354">MUX_STATE_FAIL</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga28ca7d6bdea64e62f33e874641a230a0a0222514ec6646d85b0a803cc82b8428f">MUX_STATE_BUSY</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga28ca7d6bdea64e62f33e874641a230a0a5211ab41c8cdf35c0347fb675241952d">MUX_STATE_SUCCESS</a>
<br />
 }<tr class="memdesc:ga28ca7d6bdea64e62f33e874641a230a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">@ typedef mux_status_t @ brief Possible states for the MUX handler.  <a href="group__group__ccgxAppCommon.html#ga28ca7d6bdea64e62f33e874641a230a0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga28ca7d6bdea64e62f33e874641a230a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc325232edd54ae8343508768c79fef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1bc325232edd54ae8343508768c79fef">sys_hw_error_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1bc325232edd54ae8343508768c79fefae54f28326798ea119fc858fbf0fb1701">SYS_HW_ERROR_NONE</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1bc325232edd54ae8343508768c79fefa035c02d4e80976f054b4cc070a06d24b">SYS_HW_ERROR_MUX_ACCESS</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1bc325232edd54ae8343508768c79fefae54db6b5ffeabe75a5c7619bad60d774">SYS_HW_ERROR_REG_ACCESS</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga1bc325232edd54ae8343508768c79fefabbe38f41e36873d8e7d66c15acf05621">SYS_HW_ERROR_BAD_VOLTAGE</a> = 0x04
<br />
 }<tr class="memdesc:ga1bc325232edd54ae8343508768c79fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible hardware errors defined for the system.  <a href="group__group__ccgxAppCommon.html#ga1bc325232edd54ae8343508768c79fef">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1bc325232edd54ae8343508768c79fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbca13754d3851031d9d2b4cb920a6bb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabbca13754d3851031d9d2b4cb920a6bb">app_thermistor_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggabbca13754d3851031d9d2b4cb920a6bba556a98a3acd608e8696bda4de549c674">APP_THERMISTOR_TYPE_NTC</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggabbca13754d3851031d9d2b4cb920a6bbabc2b791844205c626beda8f66bcccc3a">APP_THERMISTOR_TYPE_PTC</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggabbca13754d3851031d9d2b4cb920a6bba198a89a0a851603ed0c3590268527327">APP_THERMISTOR_TYPE_INTRNL</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggabbca13754d3851031d9d2b4cb920a6bba2ef1b03d49da4397dac32989af4b58a6">APP_THERMISTOR_TYPE_ERROR</a> = 0x03
<br />
 }<tr class="memdesc:gabbca13754d3851031d9d2b4cb920a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible Thermistor types that can be configured.  <a href="group__group__ccgxAppCommon.html#gabbca13754d3851031d9d2b4cb920a6bb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gabbca13754d3851031d9d2b4cb920a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1a30fd54c54d07259ea52e0c3ea200"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8b1a30fd54c54d07259ea52e0c3ea200">mux_select_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200acccf11b679f0f2696e77a4b1a6ffd70a">MUX_CONFIG_ISOLATE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a8846b26e0fd62aa8068da135457180c1">MUX_CONFIG_SAFE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a8ed5f7d8bc79520a986d38ec4a8a65dd">MUX_CONFIG_SS_ONLY</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a3501b1c9fa8f965cb0329cf07d865a54">MUX_CONFIG_USB4_CUSTOM</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a4d9129047052be4c57fbe65bed006a6f">MUX_CONFIG_RIDGE_CUSTOM</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a5c4e0f7fc012c1dec422421f50079868">MUX_CONFIG_INIT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8b1a30fd54c54d07259ea52e0c3ea200a137f7fb9b6c14ef0b7be5d42daf3aad0">MUX_CONFIG_DEINIT</a>
<br />
 }<tr class="memdesc:ga8b1a30fd54c54d07259ea52e0c3ea200"><td class="mdescLeft">&#160;</td><td class="mdescRight">@ typedef mux_select_t @ brief Possible settings for the Type-C Data MUX.  <a href="group__group__ccgxAppCommon.html#ga8b1a30fd54c54d07259ea52e0c3ea200">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8b1a30fd54c54d07259ea52e0c3ea200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9af8ba98e8e424f8442e293f854f0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7a9af8ba98e8e424f8442e293f854f0f">ccg_supply_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga7a9af8ba98e8e424f8442e293f854f0faa4bc81152f4149de1af2c76aaef6f6cf">CCG_SUPPLY_VSYS</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga7a9af8ba98e8e424f8442e293f854f0fae5d6b6fec2d8a0c99fd941a27605ff67">CCG_SUPPLY_V5V</a> = 0x01
<br />
 }<tr class="memdesc:ga7a9af8ba98e8e424f8442e293f854f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of power supplies input to and monitored by the CCG5x and CCG6x devices.  <a href="group__group__ccgxAppCommon.html#ga7a9af8ba98e8e424f8442e293f854f0f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7a9af8ba98e8e424f8442e293f854f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7903ba44bd8d1e319f7590e7d592b1a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7903ba44bd8d1e319f7590e7d592b1a9">bc_port_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga7903ba44bd8d1e319f7590e7d592b1a9a8ca54cb6d1dcd07b65ef6386e28c6cc2">BC_PORT_TYPE_A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga7903ba44bd8d1e319f7590e7d592b1a9abe48ce7fe64c80dac86f9e039c1e6c86">BC_PORT_TYPE_C</a>
<br />
 }<tr class="memdesc:ga7903ba44bd8d1e319f7590e7d592b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Battery charging port types.  <a href="group__group__ccgxAppCommon.html#ga7903ba44bd8d1e319f7590e7d592b1a9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7903ba44bd8d1e319f7590e7d592b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013e4bb33c056c7899d9ba01f9e8ca5a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga013e4bb33c056c7899d9ba01f9e8ca5aa15a773c5b99672d3608036e724e6c8e5">BC_PORT_SINK</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga013e4bb33c056c7899d9ba01f9e8ca5aa76230ea610cf4862b7820acb42f1fa27">BC_PORT_SOURCE</a>
<br />
 }<tr class="memdesc:ga013e4bb33c056c7899d9ba01f9e8ca5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Battery charging port role.  <a href="group__group__ccgxAppCommon.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga013e4bb33c056c7899d9ba01f9e8ca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e167e7384c20bdca3fc90dd5ba8163"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf4e167e7384c20bdca3fc90dd5ba8163">bc_qc_class_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf4e167e7384c20bdca3fc90dd5ba8163a1a7b4b977ba679196ab7753f370e100e">BC_QC_CLASS_A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf4e167e7384c20bdca3fc90dd5ba8163af6d078f91809682d0c9426cd128148b8">BC_QC_CLASS_B</a>
<br />
 }<tr class="memdesc:gaf4e167e7384c20bdca3fc90dd5ba8163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qualcomm Quick Charge charger class.  <a href="group__group__ccgxAppCommon.html#gaf4e167e7384c20bdca3fc90dd5ba8163">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaf4e167e7384c20bdca3fc90dd5ba8163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451c9706d02556521e32e66aa78ab48b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga451c9706d02556521e32e66aa78ab48b">bc_qc_ver_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga451c9706d02556521e32e66aa78ab48baa5a16b974a27087ad4f1fc5be6e8e86c">BC_QC_VER_2</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga451c9706d02556521e32e66aa78ab48ba6b6e1ed11b98a806234eef58e30c0842">BC_QC_VER_3</a>
<br />
 }<tr class="memdesc:ga451c9706d02556521e32e66aa78ab48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Qualcomm charger version.  <a href="group__group__ccgxAppCommon.html#ga451c9706d02556521e32e66aa78ab48b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga451c9706d02556521e32e66aa78ab48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccd83f68100db184fb580677c9b6e47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadccd83f68100db184fb580677c9b6e47">bc_apple_id_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadccd83f68100db184fb580677c9b6e47a50cacc9e0f69ff1e4924af77e8e3b362">BC_APPLE_ID_1A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadccd83f68100db184fb580677c9b6e47afdfb0bf6368f27396413fec457572af6">BC_APPLE_ID_2_1A</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadccd83f68100db184fb580677c9b6e47a625c2d37287cb1d2b650af596b28ca1a">BC_APPLE_ID_2_4A</a>
<br />
 }<tr class="memdesc:gadccd83f68100db184fb580677c9b6e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apple charger brick id.  <a href="group__group__ccgxAppCommon.html#gadccd83f68100db184fb580677c9b6e47">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadccd83f68100db184fb580677c9b6e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b59aae9342e308eac3d4c7447edabe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf6b59aae9342e308eac3d4c7447edabe">bc_charge_mode_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea79d9c09a8c8ac0905dc2ba7619b6895c">BC_CHARGE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea7aab279b2a9c2c7b9969609f6a6d4cee">BC_CHARGE_DCP</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea480a0d32a9619385020020050eee332f">BC_CHARGE_QC2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea878acad41d7a690c8da0a463d75bf9f6">BC_CHARGE_QC3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea1d0f74f2f8e380a9ec183deca569e814">BC_CHARGE_AFC</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea53025080e01dd863252c012edbd7a6c1">BC_CHARGE_APPLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf6b59aae9342e308eac3d4c7447edabea86f0cc62fa0b6eeeaa82f48dd13032f2">BC_CHARGE_CDP</a>
<br />
 }<tr class="memdesc:gaf6b59aae9342e308eac3d4c7447edabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of legacy battery charging schemes supported over a Type-C or Type-A port.  <a href="group__group__ccgxAppCommon.html#gaf6b59aae9342e308eac3d4c7447edabe">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaf6b59aae9342e308eac3d4c7447edabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc0527a2ced048816b7b75b7b4357cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadcc0527a2ced048816b7b75b7b4357cc">bc_d_status_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadcc0527a2ced048816b7b75b7b4357cca22a7b682125a6ef2cbbf793053b56c1f">BC_D_GND</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadcc0527a2ced048816b7b75b7b4357cca1f00718bd86a919b95c0b5594a45b267">BC_D_0_6V</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadcc0527a2ced048816b7b75b7b4357cca57ebe44fd9369253681200690e0b322f">BC_D_3_3V</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadcc0527a2ced048816b7b75b7b4357cca0f0ecec14a7363894bf0c4c8b1d5221f">BC_D_ERR</a>
<br />
 }<tr class="memdesc:gadcc0527a2ced048816b7b75b7b4357cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the various Dp/Dm states.  <a href="group__group__ccgxAppCommon.html#gadcc0527a2ced048816b7b75b7b4357cc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadcc0527a2ced048816b7b75b7b4357cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba44f84aad9f024cdb897fbc11f15bae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaba44f84aad9f024cdb897fbc11f15bae">bc_apple_term</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaba44f84aad9f024cdb897fbc11f15baea8e40aa37cd02b198bcddc2d8becb1295">APPLE_TERM1</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaba44f84aad9f024cdb897fbc11f15baea8ae05e94a248c579b05720fbe31b60f4">APPLE_TERM2</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaba44f84aad9f024cdb897fbc11f15baeac19b34cdbeb374a7c0031346d72f0fa6">APPLE_TERM3</a> = 3
<br />
 }<tr class="memdesc:gaba44f84aad9f024cdb897fbc11f15bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Apple terminations codes.  <a href="group__group__ccgxAppCommon.html#gaba44f84aad9f024cdb897fbc11f15bae">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaba44f84aad9f024cdb897fbc11f15bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc4785e34159a46b6e6a14c09297352d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafc4785e34159a46b6e6a14c09297352d">bc_apple_brick_id</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da7439dfb5b322c6278b6c5f4af54991b8">APPLE_BRICK_ID_0</a> = 0x11, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da675c612dc6d0cf5602343c36b00b6381">APPLE_BRICK_ID_1</a> = 0x12, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da0e0fd1f198d7975814e4bdd060f1b7dc">APPLE_BRICK_ID_2</a> = 0x13, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da1f4e606332e57286a954f6d24d762aa3">APPLE_BRICK_ID_3</a> = 0x21, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352dafd65c69e85b30b3eb1387d330a612c0e">APPLE_BRICK_ID_4</a> = 0x22, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da806e446a372770961facdf346f97c75e">APPLE_BRICK_ID_5</a> = 0x23, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352da39cb9e3054be29dded6dfd46d1a5efbb">APPLE_BRICK_ID_6</a> = 0x31, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352daccf8a03b00ade762250c7f3883821595">APPLE_BRICK_ID_7</a> = 0x32, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggafc4785e34159a46b6e6a14c09297352dac3a500a9342c57943535529d0639c790">APPLE_BRICK_ID_8</a> = 0x33
<br />
 }<tr class="memdesc:gafc4785e34159a46b6e6a14c09297352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible Apple Brick IDs based on the terminations on DP and DM pins.  <a href="group__group__ccgxAppCommon.html#gafc4785e34159a46b6e6a14c09297352d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gafc4785e34159a46b6e6a14c09297352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa71d2453ce7697ebd7b34f8c951392"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9aa71d2453ce7697ebd7b34f8c951392">bc_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a472586df5734d0172687220fcd71843d">BC_FSM_OFF</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a62f74466921b4954741663e20d90f5fb">BC_FSM_SRC_LOOK_FOR_CONNECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392ae34ad2b37b6e2c9e2f3b6a15f3ae35fd">BC_FSM_SRC_INITIAL_CONNECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392aae7f227adfa36b4c0c738dc4822977d9">BC_FSM_SRC_APPLE_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a8b400c7ef2de7b9886c8f96eed35e4c0">BC_FSM_SRC_CDP_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392af1122c9570fe68eaae15cec8be56dbdc">BC_FSM_SRC_OTHERS_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392ab7d3017a7349e7449f8537565504d247">BC_FSM_SRC_QC_OR_AFC</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a0e960250b3d8e9f2de15c1a8b918743b">BC_FSM_SRC_QC_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a1e387e350b416a1796a7800234af2309">BC_FSM_SRC_AFC_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a92f24791eb06f19cd24481ce958a9ff5">BC_FSM_SINK_START</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a0e435eb5c633759966758e6f9204f093">BC_FSM_SINK_APPLE_CHARGER_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a49c0413696fa4f82eb962d643fb349ea">BC_FSM_SINK_APPLE_BRICK_ID_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392af0e254a59e18fdde0e0ed7b364193e2d">BC_FSM_SINK_PRIMARY_CHARGER_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392ad19d7ca74994c47dab910d3073209f90">BC_FSM_SINK_TYPE_C_ONLY_SOURCE_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a944b72c24b4df6301ef49a9ea14ed18c">BC_FSM_SINK_SECONDARY_CHARGER_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a328e53b637885e368499cec480acbc4f">BC_FSM_SINK_DCP_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a6f266dafe1491962a6a53e0976e11d47">BC_FSM_SINK_SDP_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a884c244caef4df77caa734c639c2e263">BC_FSM_SINK_CDP_CONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a476eecd33c767b4542267b0b861c7f8d">BC_FSM_SINK_AFC_CHARGER_DETECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392ae71161d003eeb09b5e762d412a7145d2">BC_FSM_SINK_QC_CHARGER_DETECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga9aa71d2453ce7697ebd7b34f8c951392a4650f63b111670a353d03cb586f30fd4">BC_FSM_MAX_STATES</a>
<br />
 }<tr class="memdesc:ga9aa71d2453ce7697ebd7b34f8c951392"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of states in the legacy battery charging state machine.  <a href="group__group__ccgxAppCommon.html#ga9aa71d2453ce7697ebd7b34f8c951392">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga9aa71d2453ce7697ebd7b34f8c951392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b85b4ed92d797ea6bcb9c869f2fd47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab9b85b4ed92d797ea6bcb9c869f2fd47">bc_sink_timer_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggab9b85b4ed92d797ea6bcb9c869f2fd47aa5a0fb9b2135614e16a0857d1a6c3d70">BC_SINK_TIMER_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggab9b85b4ed92d797ea6bcb9c869f2fd47a2c39ddc65f4f93385a457388d2e0d3be">BC_SINK_DCD_DEBOUNCE_TIMER</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggab9b85b4ed92d797ea6bcb9c869f2fd47a31dbf7f927e451ea08ec4fe170946086">BC_SINK_TIMER_BC_DONE</a> = 2, 
<br />
&#160;&#160;<b>BC_SINK_TIMER_DM_HIGH</b> = 3
<br />
 }<tr class="memdesc:gab9b85b4ed92d797ea6bcb9c869f2fd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible timers in sink mode.  <a href="group__group__ccgxAppCommon.html#gab9b85b4ed92d797ea6bcb9c869f2fd47">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gab9b85b4ed92d797ea6bcb9c869f2fd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd5dcca7a3c67f0e2c2f6a7e538ef7f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa1276ed3b776de8f7032368a49d1120ee">GPIO_PORT_0_PIN_0</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa99dc124a515a416df13b1cc8a161c8cf">GPIO_PORT_0_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5b05d98ca91289ca156de5116757be06">GPIO_PORT_0_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa02fe21499b724387f8fb61e67b7a2101">GPIO_PORT_0_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5344901dc2fc6dcb8936c6e5aa05339b">GPIO_PORT_0_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2cae814b84c9bb7b37bc908b760167d2">GPIO_PORT_0_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa443698ab60f0a3999e835c0f40f3f95e">GPIO_PORT_0_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa01ae5402d011013cc2cff8ca9821a120">GPIO_PORT_0_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa112c4da9a2d37ef1ea4bd54a64ccc15d">GPIO_PORT_1_PIN_0</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faf6d5b594c5187e2ef4eb62ccce84da02">GPIO_PORT_1_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5cfb2323de1477384edf1c855907844d">GPIO_PORT_1_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7facf757504ceb1ab9a2c01f456efbd8e15">GPIO_PORT_1_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faa377bc01bd96d27aebbce8357344680e">GPIO_PORT_1_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa652390cb0d1eda70730a3205f64c5678">GPIO_PORT_1_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa12d52fd12d89edad1099d7764a9d66d9">GPIO_PORT_1_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7ab965ff56d936e1e5533689143cf166">GPIO_PORT_1_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faeecb4411147bbcda5f2c3d973bdcba06">GPIO_PORT_2_PIN_0</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fac91bafd4e3e853e65e8b22a02750709d">GPIO_PORT_2_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa410c85c6e7ff9483f2ec4f63415f3861">GPIO_PORT_2_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fac56a6cfa151bcae92a9bb6c0ab66d6ed">GPIO_PORT_2_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa52b8b5b6ec253e207bc9cf1021ee2cbe">GPIO_PORT_2_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa926d647e544ae15c3ea842cfd6831f3f">GPIO_PORT_2_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa963f16a09f06ff3ff03ec941fce34d44">GPIO_PORT_2_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa48a35a1489851e628a982067293f1a0f">GPIO_PORT_2_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad118c76412ac07fb9f2e335b5f8e8571">GPIO_PORT_3_PIN_0</a> = 0x30, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa84731e836bd8856f2331ff5306a3ae0c">GPIO_PORT_3_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa3da2aa5607bca768e83de577d7c7ade8">GPIO_PORT_3_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2ba4752e65a3a306b4b44fbeff1c5844">GPIO_PORT_3_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad109c0423bfa827da8a36e7a69cc1185">GPIO_PORT_3_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae16a403a8a86e50df4de4781b6bee138">GPIO_PORT_3_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7292d621bc2d071db6ebe49537927b92">GPIO_PORT_3_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faef16a22a4062b44c7f882571fa0c4fc6">GPIO_PORT_3_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae33e167b53d34faebdcaea844d44edea">GPIO_PORT_4_PIN_0</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa0e2e5b3656c82f46cd57bf0520370878">GPIO_PORT_4_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae9d26203db4d818f51e3cb1693f9de37">GPIO_PORT_4_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa538f691971bc699769716fe73372c2ec">GPIO_PORT_4_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa9383f3374899207da191c26265ff3177">GPIO_PORT_4_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2a4aead01ce9f697a44e2c338594ffee">GPIO_PORT_4_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa4a0210aaf155201017a65a98cb53ce18">GPIO_PORT_4_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa52508b75e1cd8c61023f647e2d8626f0">GPIO_PORT_4_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa799cc99b89d5c889bdc420c33934f0bf">GPIO_PORT_5_PIN_0</a> = 0x50, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7facb9cfc813e2345ed5a3a75898b1a253a">GPIO_PORT_5_PIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa10a7d490f3d0df9a251df33d35da42d7">GPIO_PORT_5_PIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fafe2de427331a0b949d9ca1264c36b373">GPIO_PORT_5_PIN_3</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad9e0f3214d407c7e316b8768f501de46">GPIO_PORT_5_PIN_4</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7565e2f0ea0b7d72abd2ad2d15be97d1">GPIO_PORT_5_PIN_5</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fab7931504ad796058e1f628fc887ed845">GPIO_PORT_5_PIN_6</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fabe6ad72ddef076e6051fee3efb991b34">GPIO_PORT_5_PIN_7</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa00853e909cd9c54b6c7de51d248623c5">GPIO_PORT_6_PIN_0</a> = 0x60, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa99628aa1586832f5f3dfcff506004841">GPIO_PORT_6_PIN_1</a>
<br />
 }<tr class="memdesc:gadbd5dcca7a3c67f0e2c2f6a7e538ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of pins supported on CCGx devices.  <a href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadbd5dcca7a3c67f0e2c2f6a7e538ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91de19d5edf75a3e58f9d2c9371c30f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5ae6eb06505d148078a8020ae0b5ae2b4b">GPIO_DM_HIZ_ANALOG</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5aa15bca49a2a36bd694cb3fcacbe6c99b">GPIO_DM_HIZ_DIGITAL</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5a8b68a63faf2c896b680103032a3d61cd">GPIO_DM_RES_UP</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5a946073dc394d366fd384195ade7ab0fe">GPIO_DM_RES_DWN</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5ac1a6be1d280217a0138b4193a8958fdd">GPIO_DM_OD_LOW</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5aee032bd6c9fe5a979b24788e10b25da9">GPIO_DM_OD_HIGH</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5a2d470cf24c28ea7b8c6250bb6487571e">GPIO_DM_STRONG</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga91de19d5edf75a3e58f9d2c9371c30f5a8c28faee8980630c383a54da5190d7ec">GPIO_DM_RES_UPDOWN</a>
<br />
 }<tr class="memdesc:ga91de19d5edf75a3e58f9d2c9371c30f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various GPIO drive modes supported by the CCGx devices.  <a href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga91de19d5edf75a3e58f9d2c9371c30f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534bf6468ef6937caf6db065d83845ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga534bf6468ef6937caf6db065d83845caa8315c5b4fb780e79d6b080c186817897">GPIO_INTR_DISABLE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga534bf6468ef6937caf6db065d83845caa90cefe7b29e5a48b3ffaaaebcaedcc47">GPIO_INTR_RISING</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga534bf6468ef6937caf6db065d83845caadaf32c18079eb7bd646f98a06b49e210">GPIO_INTR_FALLING</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga534bf6468ef6937caf6db065d83845caa0f43ca6fc28a055f1f80024d1dfe846b">GPIO_INTR_BOTH</a>
<br />
 }<tr class="memdesc:ga534bf6468ef6937caf6db065d83845ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various GPIO interrupt modes supported by the device.  <a href="group__group__ccgxAppCommon.html#ga534bf6468ef6937caf6db065d83845ca">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga534bf6468ef6937caf6db065d83845ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21929450529e4881bbfac8628bd82577"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a> { <a class="el" href="group__group__ccgxAppCommon.html#gga21929450529e4881bbfac8628bd82577aa35888587d5dc6faee7923c6fd086c59">HSIOM_MODE_GPIO</a> = 0
 }<tr class="memdesc:ga21929450529e4881bbfac8628bd82577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various IO matrix configuration modes.  <a href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga21929450529e4881bbfac8628bd82577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690ec97bf194692eae90b1276e129295"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a8a978cd51564cdf4f5840e09956da53d">UVDM_CMD_RESERVED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a2e40806b81f8998ec93847466aa7d3ed">UVDM_CMD_GET_DEVICE_MODE_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295af9cec52a844a160145e07078be8a6090">UVDM_CMD_GET_DEVICE_VERSION_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a1b896a36d56888ef3692dd5d753175a5">UVDM_CMD_GET_SILICON_ID_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a69b79feaacc613c3e1252b805fc5cdbf">UVDM_CMD_DEVICE_RESET_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a1fc040788a624b2ee0674df5ef9f6fe2">UVDM_CMD_JUMP_TO_BOOT_OPCDOE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a77f95650a43528ecb8d43d7d69049a10">UVDM_CMD_ENTER_FLASHING_MODE_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295ab62b1777bdd92b50387b32d81592c9ba">UVDM_CMD_SEND_DATA_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295ab4686321869f757c72d17a22e9260282">UVDM_CMD_FLASH_WRITE_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a811717f4ed535607afc48d3a55464b0d">UVDM_CMD_READ_DATA_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295af461f567a94e2077652ab156c73a2273">UVDM_CMD_FLASH_READ_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295ad095ff23a283990d36be79e68906d10a">UVDM_CMD_VALIDATE_FW_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a6327ea1b770b24cc37e9242127688624">UVDM_CMD_REASON_FOR_BOOT_MODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a66be1931fa0229311a456dca89f83915">UVDM_CMD_GET_CHECKSUM</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a532ad432926e6b478a9e430f24458b18">UVDM_CMD_GET_FW_START_ADDRESS_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a4b669e4d5369781a48fcaa159f085183">UVDM_CMD_SET_APP_PRIORITY_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a21f7e67dcfffa18c8ba7945d45692e89">UVDM_CMD_RESERVED_16</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a03631f2eaaeb901a5a560fc88458e61f">UVDM_CMD_SEND_SIGNATURE_OPCODE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a50594cac90160f0ee90b8f3132589159">UVDM_CMD_RESERVED_18</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295ace69759b1fd3574d0b1c27f4fffc8843">UVDM_CMD_GET_BOOT_TYPE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295ade77278a8e7408af943fe3e290cfb067">UVDM_CMD_GET_CUSTOMER_INFO</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a680f07050546022b1f428b1760f5ac82">UVDM_CMD_RESERVED_21</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a0039d3d75d81cd098fd6e82aa0c1ac59">UVDM_CMD_FWCT_SIG_WRITE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295a91256d9b968897a5066040739b5ba84d">UVDM_CMD_FWCT_ROW_WRITE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga690ec97bf194692eae90b1276e129295aa327cf7e75ade397a2a533360ae802be">UVDM_CMD_CUSTOM</a> = 30
<br />
 }<tr class="memdesc:ga690ec97bf194692eae90b1276e129295"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of opcodes supported in Cypress Flashing Alternate Mode U_VDMs.  <a href="group__group__ccgxAppCommon.html#ga690ec97bf194692eae90b1276e129295">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga690ec97bf194692eae90b1276e129295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e70c33f2bd3c8f24494776269a35ad7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga5e70c33f2bd3c8f24494776269a35ad7af445ad09a8010bc59102ff33160d74c1">UVDM_NOT_HANDLED</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga5e70c33f2bd3c8f24494776269a35ad7aa07e1de15f31d60434113acd40cdfd4a">UVDM_HANDLED_RESPONSE_READY</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga5e70c33f2bd3c8f24494776269a35ad7add9a5aadb369d40563f8a0e02ad32c63">UVDM_HANDLED_NO_RESPONSE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga5e70c33f2bd3c8f24494776269a35ad7ae2eccb87e5b7927fdfb0bffe36588ca2">UVDM_HANDLED_RESPONSE_NOT_READY</a>
<br />
 }<tr class="memdesc:ga5e70c33f2bd3c8f24494776269a35ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible states of UVDM Response.  <a href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga5e70c33f2bd3c8f24494776269a35ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd88527b70b8f8aed9c2495edceacc6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadd88527b70b8f8aed9c2495edceacc6c">uvdm_qc_pps_cmd_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadd88527b70b8f8aed9c2495edceacc6cab1b876648ff2383efdc2aa1293f5d196">UVDM_QC_GET_CASE_TEMP</a> = 0x1003, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadd88527b70b8f8aed9c2495edceacc6ca221911a061c9878b12e450dc4ea05a6c">UVDM_QC_GET_CONNECTOR_TEMP</a> = 0x0B03, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadd88527b70b8f8aed9c2495edceacc6cad3a2ceaa7234e51562b7a169973b3dc7">UVDM_QC_GET_CONNECTOR_VOLT</a> = 0x0603, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadd88527b70b8f8aed9c2495edceacc6ca72429a3f951bfa3c6fb034c58365141c">UVDM_QC_GET_CHARGER_TYPE</a> = 0x0C03, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggadd88527b70b8f8aed9c2495edceacc6cab5f1ccdb0aee42ba59c050ca5aeec56e">UVDM_QC_GET_CHARGER_VERSION</a> = 0x0E03
<br />
 }<tr class="memdesc:gadd88527b70b8f8aed9c2495edceacc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of opcodes of QC 5.0/4.0 UVDM Commands.  <a href="group__group__ccgxAppCommon.html#gadd88527b70b8f8aed9c2495edceacc6c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadd88527b70b8f8aed9c2495edceacc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1610d2adf8661cff2fbb56f85be45f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2f1610d2adf8661cff2fbb56f85be45f">eFWCT_IDX_TYPE</a> { <br />
&#160;&#160;<b>FWCT_IDX_0</b> = 0, 
<br />
&#160;&#160;<b>FWCT_IDX_1</b> = 1, 
<br />
&#160;&#160;<b>MAX_FWCT_IDX</b>
<br />
 }<tr class="memdesc:ga2f1610d2adf8661cff2fbb56f85be45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to index the array for FWCT row number.  <a href="group__group__ccgxAppCommon.html#ga2f1610d2adf8661cff2fbb56f85be45f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga2f1610d2adf8661cff2fbb56f85be45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c73b649a1c51bbb96cfb3f1aeb4e0e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7c73b649a1c51bbb96cfb3f1aeb4e0e9">eIMAGE_TYPE</a> { <br />
&#160;&#160;<b>PRIMARY_IMAGE</b> = 0, 
<br />
&#160;&#160;<b>MAX_IMAGE_TYPES</b>
<br />
 }<tr class="memdesc:ga7c73b649a1c51bbb96cfb3f1aeb4e0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for image types.  <a href="group__group__ccgxAppCommon.html#ga7c73b649a1c51bbb96cfb3f1aeb4e0e9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7c73b649a1c51bbb96cfb3f1aeb4e0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0499a81eacb51cf06f95c0df6ce57c56"><td class="memItemLeft" align="right" valign="top"><a id="ga0499a81eacb51cf06f95c0df6ce57c56"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0499a81eacb51cf06f95c0df6ce57c56">fw_update_states_t</a> { <br />
&#160;&#160;<b>FW_UPDATE_NONE</b> = 0, 
<br />
&#160;&#160;<b>FW_UPDATE_FWCT</b>, 
<br />
&#160;&#160;<b>FW_UPDATE_FWCT_SIG</b>, 
<br />
&#160;&#160;<b>FW_UPDATE_ENABLE_FLASH</b>, 
<br />
&#160;&#160;<b>FW_UPDATE_ROW_WRITE</b>
<br />
 }<tr class="memdesc:ga0499a81eacb51cf06f95c0df6ce57c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to indicate firmware status. <br /></td></tr>
</td></tr>
<tr class="separator:ga0499a81eacb51cf06f95c0df6ce57c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8651b8b577a26ca726537b6e68128a61"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8651b8b577a26ca726537b6e68128a61">valid_fwct_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8651b8b577a26ca726537b6e68128a61a2e3c1bcf8be020e9e04a66ed936078e5">FWCT_VALID_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8651b8b577a26ca726537b6e68128a61acde5268c85b9ea997fec79cc6825b0c9">FWCT_IDX_0_VALID</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8651b8b577a26ca726537b6e68128a61af7fbc3bf0a2999507745a849b3a3540c">FWCT_IDX_1_VALID</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8651b8b577a26ca726537b6e68128a61a97df7cdf8841bc652b0b7af856a75898">MAX_VALID_FWCT</a>
<br />
 }<tr class="memdesc:ga8651b8b577a26ca726537b6e68128a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to indicate fwct validity.  <a href="group__group__ccgxAppCommon.html#ga8651b8b577a26ca726537b6e68128a61">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8651b8b577a26ca726537b6e68128a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b0bf3323a9975def8556ab35cf6ac"><td class="memItemLeft" align="right" valign="top"><a id="ga097b0bf3323a9975def8556ab35cf6ac"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga097b0bf3323a9975def8556ab35cf6ac">crypto_algo_t</a> { <br />
&#160;&#160;<b>SHA256_RSA2048</b> = 0, 
<br />
&#160;&#160;<b>SHA256_uECC</b>
<br />
 }<tr class="memdesc:ga097b0bf3323a9975def8556ab35cf6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for crypto algorithm choice. <br /></td></tr>
</td></tr>
<tr class="separator:ga097b0bf3323a9975def8556ab35cf6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1472d4978873442e3b2040b9279c7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8c1472d4978873442e3b2040b9279c7b">inst_evt_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8c1472d4978873442e3b2040b9279c7ba9ee6c3e15702ef5bc0f5473cbd599f2b">INST_EVT_WDT_RESET</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga8c1472d4978873442e3b2040b9279c7ba883dcd2a5cbbee9a781c26be1c5422e7">INST_EVT_HARD_FAULT</a> = 1
<br />
 }<tr class="memdesc:ga8c1472d4978873442e3b2040b9279c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of all instrumentation fault events.  <a href="group__group__ccgxAppCommon.html#ga8c1472d4978873442e3b2040b9279c7b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8c1472d4978873442e3b2040b9279c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e3ae39360ed4676f284cfcbd27f090"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf9e3ae39360ed4676f284cfcbd27f090a391a0ea21acffd327faf3aa4565e0879">SYS_FW_MODE_BOOTLOADER</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf9e3ae39360ed4676f284cfcbd27f090a05e2081c251f80b012212b2ef0d7a8d7">SYS_FW_MODE_FWIMAGE_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf9e3ae39360ed4676f284cfcbd27f090a736e0fe38ba8493821e4a7b5076bdd79">SYS_FW_MODE_FWIMAGE_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggaf9e3ae39360ed4676f284cfcbd27f090a608b1bf5157307c4a7735afe6cae3d20">SYS_FW_MODE_INVALID</a>
<br />
 }<tr class="memdesc:gaf9e3ae39360ed4676f284cfcbd27f090"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of CCG firmware modes.  <a href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaf9e3ae39360ed4676f284cfcbd27f090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebb36a46a6b7abb6d95ff1847116864"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gacebb36a46a6b7abb6d95ff1847116864">i2c_scb_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864a15041879a3dc1884dc1a8936ae835378">I2C_SCB_STATE_DISABLED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864ac50d8b58e54cb0faa1bd5f7c34cabfeb">I2C_SCB_STATE_INIT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864a596bf12eea8f8ab26ba27a4626b99a93">I2C_SCB_STATE_IDLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864a59f356243d6645440b91bdd864b29806">I2C_SCB_STATE_PREAMBLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864af45f9af5cfa42f4af56471457b722b7e">I2C_SCB_STATE_READ</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864a2a7603c06a234c402f23b6b8207fc4e0">I2C_SCB_STATE_WRITE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864ab764a31bdc6446345931019d3b5dd618">I2C_SCB_STATE_CLK_STRETCH</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864ad62d35142d956e849487d792991d0a5f">I2C_SCB_STATE_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#ggacebb36a46a6b7abb6d95ff1847116864a6627483a8d6bc8a9ead5f2a78581f4f7">I2C_SCB_NUM_STATES</a>
<br />
 }<tr class="memdesc:gacebb36a46a6b7abb6d95ff1847116864"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible I2C block states.  <a href="group__group__ccgxAppCommon.html#gacebb36a46a6b7abb6d95ff1847116864">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gacebb36a46a6b7abb6d95ff1847116864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929dc6e6ed7bb0e330bcbd1285acc0d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga929dc6e6ed7bb0e330bcbd1285acc0d1a20256ed7ecac9e0284e50fd79272dc59">I2C_SCB_MODE_MASTER</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga929dc6e6ed7bb0e330bcbd1285acc0d1abf718bae34faeb8416886b96aef6f4ac">I2C_SCB_MODE_HPI</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga929dc6e6ed7bb0e330bcbd1285acc0d1a9903c0821e9aeea1e6121bd1d80413e0">I2C_SCB_MODE_ALP_RIDGE</a>
<br />
 }<tr class="memdesc:ga929dc6e6ed7bb0e330bcbd1285acc0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible I2C block operating modes.  <a href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga929dc6e6ed7bb0e330bcbd1285acc0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39039019bd1c23cdc1d45a1bf0ea8b74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga39039019bd1c23cdc1d45a1bf0ea8b74ac7f1880c89328e79010975bc5ad4a368">I2C_SCB_CLOCK_FREQ_100_KHZ</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga39039019bd1c23cdc1d45a1bf0ea8b74a4db4a21e3d10ab9a4aa3d030dfa7a15b">I2C_SCB_CLOCK_FREQ_400_KHZ</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga39039019bd1c23cdc1d45a1bf0ea8b74a3e40b72ad3944d135f3d0125a741fb5c">I2C_SCB_CLOCK_FREQ_1_MHZ</a>
<br />
 }<tr class="memdesc:ga39039019bd1c23cdc1d45a1bf0ea8b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of possible I2C bus bit rates.  <a href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga39039019bd1c23cdc1d45a1bf0ea8b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459a4d34fea4545cb049bcbc0aa2924c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga459a4d34fea4545cb049bcbc0aa2924c">i2c_cb_cmd_t</a> { <br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga459a4d34fea4545cb049bcbc0aa2924cafe582baaa37c28d2b37e009c4d9b6e4c">I2C_CB_CMD_READ</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga459a4d34fea4545cb049bcbc0aa2924cade77d0bd54e7e1f2e1e793f356c01942">I2C_CB_CMD_WRITE</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga459a4d34fea4545cb049bcbc0aa2924ca9ac7449667cd3b27fdc767c1c513f6c0">I2C_CB_CMD_XFER_END</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga459a4d34fea4545cb049bcbc0aa2924ca5a5a7ed3afc68d0a0f9a7281dbea598c">I2C_CB_CMD_TIMEOUT</a>, 
<br />
&#160;&#160;<a class="el" href="group__group__ccgxAppCommon.html#gga459a4d34fea4545cb049bcbc0aa2924ca7b437836f5a0ae3eb59a7fa1710ad712">I2C_CB_SLAVE_ADDR_MATCH</a>
<br />
 }<tr class="memdesc:ga459a4d34fea4545cb049bcbc0aa2924c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of I2C operation being notified through a callback function.  <a href="group__group__ccgxAppCommon.html#ga459a4d34fea4545cb049bcbc0aa2924c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga459a4d34fea4545cb049bcbc0aa2924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga987e808055c53d2d3138625e94ce0c8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga987e808055c53d2d3138625e94ce0c8d">app_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga987e808055c53d2d3138625e94ce0c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application level init function.  <a href="#ga987e808055c53d2d3138625e94ce0c8d">More...</a><br /></td></tr>
<tr class="separator:ga987e808055c53d2d3138625e94ce0c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga41c615b2b4410be1d5f90f454b2a6b5e">app_is_port_enabled</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the specified PD port is enabled in the system configuration.  <a href="#ga41c615b2b4410be1d5f90f454b2a6b5e">More...</a><br /></td></tr>
<tr class="separator:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad066f25e9c4975fadc25bfbdeeb88bb1">app_task</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for application level asynchronous tasks.  <a href="#gad066f25e9c4975fadc25bfbdeeb88bb1">More...</a><br /></td></tr>
<tr class="separator:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd2bdc30aa59479a77d28857789cff2"><td class="memItemLeft" align="right" valign="top">cy_stc_pdstack_app_cbk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3dd2bdc30aa59479a77d28857789cff2">app_get_callback_ptr</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3dd2bdc30aa59479a77d28857789cff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return the App callback structure pointer.  <a href="#ga3dd2bdc30aa59479a77d28857789cff2">More...</a><br /></td></tr>
<tr class="separator:ga3dd2bdc30aa59479a77d28857789cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cd70e9e221ab79f671ce87143afe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad1cd70e9e221ab79f671ce87143afe79">app_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *dat)</td></tr>
<tr class="memdesc:gad1cd70e9e221ab79f671ce87143afe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for event notifications from the PD stack.  <a href="#gad1cd70e9e221ab79f671ce87143afe79">More...</a><br /></td></tr>
<tr class="separator:gad1cd70e9e221ab79f671ce87143afe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaadfeec58882d5ff9434208ef0f07af6"><td class="memItemLeft" align="right" valign="top">app_resp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaaadfeec58882d5ff9434208ef0f07af6">app_get_resp_buf</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaaadfeec58882d5ff9434208ef0f07af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the application provide PD command response buffer.  <a href="#gaaadfeec58882d5ff9434208ef0f07af6">More...</a><br /></td></tr>
<tr class="separator:gaaadfeec58882d5ff9434208ef0f07af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d7c64e58560deaffc50953f364124b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#structapp__status__t">app_status_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga93d7c64e58560deaffc50953f364124b">app_get_status</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga93d7c64e58560deaffc50953f364124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get handle to structure containing information about the system status for a PD port.  <a href="#ga93d7c64e58560deaffc50953f364124b">More...</a><br /></td></tr>
<tr class="separator:ga93d7c64e58560deaffc50953f364124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae9332fe6e441fbc8c3ee70b1e90a0f77">app_update_sys_battery_status</a> (uint32_t bsdo)</td></tr>
<tr class="memdesc:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the system battery status.  <a href="#gae9332fe6e441fbc8c3ee70b1e90a0f77">More...</a><br /></td></tr>
<tr class="separator:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ab189c440f4561aebd58aa78d6621d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga37ab189c440f4561aebd58aa78d6621d">app_sleep</a> (void)</td></tr>
<tr class="memdesc:ga37ab189c440f4561aebd58aa78d6621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the APP handlers are ready to allow device deep sleep.  <a href="#ga37ab189c440f4561aebd58aa78d6621d">More...</a><br /></td></tr>
<tr class="separator:ga37ab189c440f4561aebd58aa78d6621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5e5b5fbf3a976f0f88688f3bca95908c">app_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the APP handler state after CCG device wakes from deep-sleep.  <a href="#ga5e5b5fbf3a976f0f88688f3bca95908c">More...</a><br /></td></tr>
<tr class="separator:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772c8b861e18d101c97e0dfc901a9e0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga772c8b861e18d101c97e0dfc901a9e0e">system_sleep</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga772c8b861e18d101c97e0dfc901a9e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to place CCG device in power saving mode if possible.  <a href="#ga772c8b861e18d101c97e0dfc901a9e0e">More...</a><br /></td></tr>
<tr class="separator:ga772c8b861e18d101c97e0dfc901a9e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga257a11c7349f3f402f3b5071e8ac9b04">vconn_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t channel)</td></tr>
<tr class="memdesc:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables VCONN power.  <a href="#ga257a11c7349f3f402f3b5071e8ac9b04">More...</a><br /></td></tr>
<tr class="separator:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635c202b5b7794044060fe53283c0ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga635c202b5b7794044060fe53283c0ca1">vconn_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t channel)</td></tr>
<tr class="memdesc:ga635c202b5b7794044060fe53283c0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables VCONN power.  <a href="#ga635c202b5b7794044060fe53283c0ca1">More...</a><br /></td></tr>
<tr class="separator:ga635c202b5b7794044060fe53283c0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b195995f6b6224c6284f4224bdadf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga62b195995f6b6224c6284f4224bdadf0">vconn_is_present</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga62b195995f6b6224c6284f4224bdadf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if power is present on VConn.  <a href="#ga62b195995f6b6224c6284f4224bdadf0">More...</a><br /></td></tr>
<tr class="separator:ga62b195995f6b6224c6284f4224bdadf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ddce48424ce3539552456b460083d08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5ddce48424ce3539552456b460083d08">vbus_is_present</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt, int8 per)</td></tr>
<tr class="memdesc:ga5ddce48424ce3539552456b460083d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if power is present on VBus.  <a href="#ga5ddce48424ce3539552456b460083d08">More...</a><br /></td></tr>
<tr class="separator:ga5ddce48424ce3539552456b460083d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c527850e02f68c9c1072b58921fe533"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0c527850e02f68c9c1072b58921fe533">vbus_get_value</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga0c527850e02f68c9c1072b58921fe533"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return current VBUS voltage in mV.  <a href="#ga0c527850e02f68c9c1072b58921fe533">More...</a><br /></td></tr>
<tr class="separator:ga0c527850e02f68c9c1072b58921fe533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631d47609bcac183d47133c3a0bc55e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga631d47609bcac183d47133c3a0bc55e2">vbus_discharge_on</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga631d47609bcac183d47133c3a0bc55e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns on discharge FET on selected port.  <a href="#ga631d47609bcac183d47133c3a0bc55e2">More...</a><br /></td></tr>
<tr class="separator:ga631d47609bcac183d47133c3a0bc55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370b31502ed6b6794b00652450930ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga370b31502ed6b6794b00652450930ce1">vbus_discharge_off</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga370b31502ed6b6794b00652450930ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns off discharge FET on selected port.  <a href="#ga370b31502ed6b6794b00652450930ce1">More...</a><br /></td></tr>
<tr class="separator:ga370b31502ed6b6794b00652450930ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197c17a51bae827c86006723dd28b561"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga197c17a51bae827c86006723dd28b561">system_vconn_ocp_en</a> (cy_stc_pdstack_context_t *context, cy_cb_vbus_fault_t cbk)</td></tr>
<tr class="memdesc:ga197c17a51bae827c86006723dd28b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable vconn ocp.  <a href="#ga197c17a51bae827c86006723dd28b561">More...</a><br /></td></tr>
<tr class="separator:ga197c17a51bae827c86006723dd28b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3ceb8e80d5c01c5157484bf30f85925d">system_vconn_ocp_dis</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable vconn ocp.  <a href="#ga3ceb8e80d5c01c5157484bf30f85925d">More...</a><br /></td></tr>
<tr class="separator:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128a0e6e3970ac63087ee51a55999429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga128a0e6e3970ac63087ee51a55999429">app_ovp_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt_mV, bool pfet, cy_cb_vbus_fault_t ovp_cb)</td></tr>
<tr class="memdesc:ga128a0e6e3970ac63087ee51a55999429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and configure the Over-Voltage protection circuitry.  <a href="#ga128a0e6e3970ac63087ee51a55999429">More...</a><br /></td></tr>
<tr class="separator:ga128a0e6e3970ac63087ee51a55999429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b919168d11183f7e6d5816b773a327e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9b919168d11183f7e6d5816b773a327e">app_ovp_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, bool pfet)</td></tr>
<tr class="memdesc:ga9b919168d11183f7e6d5816b773a327e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Over-Voltage protection circuitry.  <a href="#ga9b919168d11183f7e6d5816b773a327e">More...</a><br /></td></tr>
<tr class="separator:ga9b919168d11183f7e6d5816b773a327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1d2dc98c12ea2ccc48072cb1b911a077">system_vconn_scp_en</a> (cy_stc_pdstack_context_t *context, cy_cb_vbus_fault_t cbk)</td></tr>
<tr class="memdesc:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable vconn scp.  <a href="#ga1d2dc98c12ea2ccc48072cb1b911a077">More...</a><br /></td></tr>
<tr class="separator:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a402bfbaeee99955bb644bb5ee19838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6a402bfbaeee99955bb644bb5ee19838">system_vconn_scp_dis</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga6a402bfbaeee99955bb644bb5ee19838"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable vconn scp.  <a href="#ga6a402bfbaeee99955bb644bb5ee19838">More...</a><br /></td></tr>
<tr class="separator:ga6a402bfbaeee99955bb644bb5ee19838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3c78977d8cc1e0753a16ea9bd1269b41">app_uvp_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt_mV, bool pfet, cy_cb_vbus_fault_t uvp_cb)</td></tr>
<tr class="memdesc:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and configure the Under-Voltage protection circuitry.  <a href="#ga3c78977d8cc1e0753a16ea9bd1269b41">More...</a><br /></td></tr>
<tr class="separator:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8979eabd2d152c80b65239cf08c601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8a8979eabd2d152c80b65239cf08c601">app_uvp_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, bool pfet)</td></tr>
<tr class="memdesc:ga8a8979eabd2d152c80b65239cf08c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Under-Voltage protection circuitry.  <a href="#ga8a8979eabd2d152c80b65239cf08c601">More...</a><br /></td></tr>
<tr class="separator:ga8a8979eabd2d152c80b65239cf08c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a1416d128b2d3ddb2444c4ea645750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae2a1416d128b2d3ddb2444c4ea645750">app_update_bc_src_snk_support</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t enable)</td></tr>
<tr class="memdesc:gae2a1416d128b2d3ddb2444c4ea645750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the BC 1.2 source support.  <a href="#gae2a1416d128b2d3ddb2444c4ea645750">More...</a><br /></td></tr>
<tr class="separator:gae2a1416d128b2d3ddb2444c4ea645750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa2efd4f1d1b83a9cdda00443a3fd6209">app_update_bc_src_support</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t enable)</td></tr>
<tr class="memdesc:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the BC 1.2 source support.  <a href="#gaa2efd4f1d1b83a9cdda00443a3fd6209">More...</a><br /></td></tr>
<tr class="separator:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039b5432fa3f08d7671a83b853e634fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga039b5432fa3f08d7671a83b853e634fe">app_update_sys_pwr_state</a> (uint8_t state)</td></tr>
<tr class="memdesc:ga039b5432fa3f08d7671a83b853e634fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the system power state.  <a href="#ga039b5432fa3f08d7671a83b853e634fe">More...</a><br /></td></tr>
<tr class="separator:ga039b5432fa3f08d7671a83b853e634fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga14afafc3b67eb20f3ed48beb857fbbb3">app_disable_pd_port</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_pdstack_dpm_typec_cmd_cbk_t cbk)</td></tr>
<tr class="memdesc:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for PD port disable.  <a href="#ga14afafc3b67eb20f3ed48beb857fbbb3">More...</a><br /></td></tr>
<tr class="separator:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09a34f2ede57568665767f0abe152dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad09a34f2ede57568665767f0abe152dd">app_validate_configtable_offsets</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gad09a34f2ede57568665767f0abe152dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the configuration table specified.  <a href="#gad09a34f2ede57568665767f0abe152dd">More...</a><br /></td></tr>
<tr class="separator:gad09a34f2ede57568665767f0abe152dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">ccg_app_task_init</a> (void)</td></tr>
<tr class="memdesc:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CCGx periodic application level tasks.  <a href="#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">More...</a><br /></td></tr>
<tr class="separator:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9f2f76f0c59231e3c1d65082b42c48dc">app_bc_12_sm_start</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the simplified BC 1.2 (DCP/CDP) state machine for CCG5 device on detection of a Type-C sink connection.  <a href="#ga9f2f76f0c59231e3c1d65082b42c48dc">More...</a><br /></td></tr>
<tr class="separator:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e89461be3b772f36c3e68e0aca3615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga72e89461be3b772f36c3e68e0aca3615">sln_pd_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *data)</td></tr>
<tr class="memdesc:ga72e89461be3b772f36c3e68e0aca3615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution handler for PD events reported from the stack.  <a href="#ga72e89461be3b772f36c3e68e0aca3615">More...</a><br /></td></tr>
<tr class="separator:ga72e89461be3b772f36c3e68e0aca3615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d83af407e9c4eb2d50686a0713eec4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga77d83af407e9c4eb2d50686a0713eec4">mux_ctrl_init</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga77d83af407e9c4eb2d50686a0713eec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Type-C Data Mux for a specific PD port.  <a href="#ga77d83af407e9c4eb2d50686a0713eec4">More...</a><br /></td></tr>
<tr class="separator:ga77d83af407e9c4eb2d50686a0713eec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a513df4f3b093f6680470327a38456e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5a513df4f3b093f6680470327a38456e">mux_ctrl_set_cfg</a> (uint8_t port, <a class="el" href="group__group__ccgxAppCommon.html#ga8b1a30fd54c54d07259ea52e0c3ea200">mux_select_t</a> cfg, uint8_t polarity)</td></tr>
<tr class="memdesc:ga5a513df4f3b093f6680470327a38456e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Type-C MUX to the desired configuration.  <a href="#ga5a513df4f3b093f6680470327a38456e">More...</a><br /></td></tr>
<tr class="separator:ga5a513df4f3b093f6680470327a38456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga067c4788c2e2c0b38fa1631d05f8adab">mux_ctrl_bb_enable</a> (uint8_t port, uint8_t polarity)</td></tr>
<tr class="memdesc:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable BB device enumeration on the board.  <a href="#ga067c4788c2e2c0b38fa1631d05f8adab">More...</a><br /></td></tr>
<tr class="separator:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafe5c906c34d42ac62e4aab9b7f19a278">fault_handler_init_vars</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize fault-handling related variables from the configuration table.  <a href="#gafe5c906c34d42ac62e4aab9b7f19a278">More...</a><br /></td></tr>
<tr class="separator:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df995227d611d600d71fc616589e086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6df995227d611d600d71fc616589e086">fault_handler_register_cbks</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga6df995227d611d600d71fc616589e086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register solution space function handlers.  <a href="#ga6df995227d611d600d71fc616589e086">More...</a><br /></td></tr>
<tr class="separator:ga6df995227d611d600d71fc616589e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57725e00da96b711d9567afd66a2f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab57725e00da96b711d9567afd66a2f93">fault_handler_clear_counts</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gab57725e00da96b711d9567afd66a2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fault occurrence counts after a Type-C detach is detected.  <a href="#gab57725e00da96b711d9567afd66a2f93">More...</a><br /></td></tr>
<tr class="separator:gab57725e00da96b711d9567afd66a2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13092468da8be42cf1497719f2392d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae13092468da8be42cf1497719f2392d3">fault_handler_task</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gae13092468da8be42cf1497719f2392d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any fault handler related tasks.  <a href="#gae13092468da8be42cf1497719f2392d3">More...</a><br /></td></tr>
<tr class="separator:gae13092468da8be42cf1497719f2392d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49cfd10d337a7d188bf27f25193a35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad49cfd10d337a7d188bf27f25193a35b">fault_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *dat)</td></tr>
<tr class="memdesc:gad49cfd10d337a7d188bf27f25193a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle any application events associated with fault handling logic.  <a href="#gad49cfd10d337a7d188bf27f25193a35b">More...</a><br /></td></tr>
<tr class="separator:gad49cfd10d337a7d188bf27f25193a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf3cc2e31b87f603f5da78321083a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1cf3cc2e31b87f603f5da78321083a02">app_otp_enable</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga1cf3cc2e31b87f603f5da78321083a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Over-Temperature Protection logic.  <a href="#ga1cf3cc2e31b87f603f5da78321083a02">More...</a><br /></td></tr>
<tr class="separator:ga1cf3cc2e31b87f603f5da78321083a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e6cabefd046b9b84a228775afddd54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf1e6cabefd046b9b84a228775afddd54">app_otp_check_temp</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaf1e6cabefd046b9b84a228775afddd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform OTP check.  <a href="#gaf1e6cabefd046b9b84a228775afddd54">More...</a><br /></td></tr>
<tr class="separator:gaf1e6cabefd046b9b84a228775afddd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae5a0e8856cdbd01ca2f848245c6b8a60">app_otp_status</a> (uint8_t port)</td></tr>
<tr class="memdesc:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of Over-Temperature Protection.  <a href="#gae5a0e8856cdbd01ca2f848245c6b8a60">More...</a><br /></td></tr>
<tr class="separator:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf604c26013002a29a736c0b618c405cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf604c26013002a29a736c0b618c405cf">vconn_change_handler</a> (cy_stc_pdstack_context_t *context, bool vconn_on)</td></tr>
<tr class="memdesc:gaf604c26013002a29a736c0b618c405cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to handle VConn supply state change due to OCP condition or V5V supply change.  <a href="#gaf604c26013002a29a736c0b618c405cf">More...</a><br /></td></tr>
<tr class="separator:gaf604c26013002a29a736c0b618c405cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2e060850f2d33f08d9ae4654ee7629f3">app_is_host_hpd_virtual</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the solution is configured to support virtual HPD.  <a href="#ga2e060850f2d33f08d9ae4654ee7629f3">More...</a><br /></td></tr>
<tr class="separator:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbafde1e08b787d570f69c5e8378b10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1cbafde1e08b787d570f69c5e8378b10">set_custom_host_cap_control</a> (uint8_t port, uint8_t host_config)</td></tr>
<tr class="memdesc:ga1cbafde1e08b787d570f69c5e8378b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update custom host capabilities HPI register with the value provided by EC.  <a href="#ga1cbafde1e08b787d570f69c5e8378b10">More...</a><br /></td></tr>
<tr class="separator:ga1cbafde1e08b787d570f69c5e8378b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4a21460df3b3ee4cc8f22b2b856e668b">app_power_share_init</a> (void)</td></tr>
<tr class="memdesc:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the power sharing across ports on a dual-port CCG device.  <a href="#ga4a21460df3b3ee4cc8f22b2b856e668b">More...</a><br /></td></tr>
<tr class="separator:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68110542f5463158989749753e37632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac68110542f5463158989749753e37632">app_contract_handler</a> (uint8_t port)</td></tr>
<tr class="memdesc:gac68110542f5463158989749753e37632"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called at the end of a PD contract to check whether any role swaps need to be triggered.  <a href="#gac68110542f5463158989749753e37632">More...</a><br /></td></tr>
<tr class="separator:gac68110542f5463158989749753e37632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619740c578362ebb487c68e54c86c83e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga619740c578362ebb487c68e54c86c83e">pd_get_ptr_cfg_sub_tbl</a> (uint8_t port, uint8_t type)</td></tr>
<tr class="memdesc:ga619740c578362ebb487c68e54c86c83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve desired sub-table from the configuration table.  <a href="#ga619740c578362ebb487c68e54c86c83e">More...</a><br /></td></tr>
<tr class="separator:ga619740c578362ebb487c68e54c86c83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcee026b0d0cdeec924f9b46abcc479c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabcee026b0d0cdeec924f9b46abcc479c">timer_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gabcee026b0d0cdeec924f9b46abcc479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize timer callbacks.  <a href="#gabcee026b0d0cdeec924f9b46abcc479c">More...</a><br /></td></tr>
<tr class="separator:gabcee026b0d0cdeec924f9b46abcc479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08054935adf625b7ed2d5e6076f8ba52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga08054935adf625b7ed2d5e6076f8ba52">app_conf_for_faulty_dev_removal</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga08054935adf625b7ed2d5e6076f8ba52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the CCG to wait for physical detach of faulty port partner.  <a href="#ga08054935adf625b7ed2d5e6076f8ba52">More...</a><br /></td></tr>
<tr class="separator:ga08054935adf625b7ed2d5e6076f8ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa561ba390c4db0bce122405dedffb75d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa561ba390c4db0bce122405dedffb75d">app_port_fault_count_exceeded</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gaa561ba390c4db0bce122405dedffb75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any fault count has exceeded limit for the specified PD port.  <a href="#gaa561ba390c4db0bce122405dedffb75d">More...</a><br /></td></tr>
<tr class="separator:gaa561ba390c4db0bce122405dedffb75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9fbef10605b1f75b463c5bc07f3b04e6">app_retrieve_fault_status</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">To retrieve the fault sticky status.  <a href="#ga9fbef10605b1f75b463c5bc07f3b04e6">More...</a><br /></td></tr>
<tr class="separator:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae3f90a4aac402a773faf295e871e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4ae3f90a4aac402a773faf295e871e29">register_soln_function_handler</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, <a class="el" href="structapp__sln__handler__t.html">app_sln_handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga4ae3f90a4aac402a773faf295e871e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function registers solution level functions.  <a href="#ga4ae3f90a4aac402a773faf295e871e29">More...</a><br /></td></tr>
<tr class="separator:ga4ae3f90a4aac402a773faf295e871e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga48b852c3817507e93ac4f0cc8f5f58ba">app_vdm_layer_reset</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts alternate mode layer.  <a href="#ga48b852c3817507e93ac4f0cc8f5f58ba">More...</a><br /></td></tr>
<tr class="separator:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe0ced862d3cbf35b36334f47490339"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3fe0ced862d3cbf35b36334f47490339">app_is_typec_attached</a> (void)</td></tr>
<tr class="memdesc:ga3fe0ced862d3cbf35b36334f47490339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of Type-C attach on all Type-C ports.  <a href="#ga3fe0ced862d3cbf35b36334f47490339">More...</a><br /></td></tr>
<tr class="separator:ga3fe0ced862d3cbf35b36334f47490339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a79606a8a811589791b10712774b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga41a79606a8a811589791b10712774b85">pd_vbat_gnd_scp_cbk</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga41a79606a8a811589791b10712774b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function from interrupt handler to handle VBAT-GND SCP fault.  <a href="#ga41a79606a8a811589791b10712774b85">More...</a><br /></td></tr>
<tr class="separator:ga41a79606a8a811589791b10712774b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8da3d9d084dd05dbaa510b065198b6b8">pd_bb_ilim_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function from interrupt handler to handle buck-boost inductor current limit fault.  <a href="#ga8da3d9d084dd05dbaa510b065198b6b8">More...</a><br /></td></tr>
<tr class="separator:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a90b6242e88c2affb0817cff513751e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8a90b6242e88c2affb0817cff513751e">pd_brown_out_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga8a90b6242e88c2affb0817cff513751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for VDDD regulator brown out fault.  <a href="#ga8a90b6242e88c2affb0817cff513751e">More...</a><br /></td></tr>
<tr class="separator:ga8a90b6242e88c2affb0817cff513751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9f3f3e4de83a213874c00f309b1751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaab9f3f3e4de83a213874c00f309b1751">pd_vreg_inrush_det_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:gaab9f3f3e4de83a213874c00f309b1751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for VDDD regulator inrush current fault.  <a href="#gaab9f3f3e4de83a213874c00f309b1751">More...</a><br /></td></tr>
<tr class="separator:gaab9f3f3e4de83a213874c00f309b1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafdfb8d6bfce9507aea95f3f5451a7789">bc_init</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the Battery Charging block.  <a href="#gafdfb8d6bfce9507aea95f3f5451a7789">More...</a><br /></td></tr>
<tr class="separator:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae1304bc5281a4decfa9c205d720a47"><td class="memItemLeft" align="right" valign="top">const cy_stc_legacy_charging_cfg_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafae1304bc5281a4decfa9c205d720a47">bc_get_config</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gafae1304bc5281a4decfa9c205d720a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the current Battery Charging configuration.  <a href="#gafae1304bc5281a4decfa9c205d720a47">More...</a><br /></td></tr>
<tr class="separator:gafae1304bc5281a4decfa9c205d720a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c842c6a36610c26e86156463f956e1"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga83c842c6a36610c26e86156463f956e1">bc_start</a> (cy_stc_pdstack_context_t *context, <a class="el" href="group__group__ccgxAppCommon.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a> port_role)</td></tr>
<tr class="memdesc:ga83c842c6a36610c26e86156463f956e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the Battery Charging block with desired configuration.  <a href="#ga83c842c6a36610c26e86156463f956e1">More...</a><br /></td></tr>
<tr class="separator:ga83c842c6a36610c26e86156463f956e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bb91b4849ec00a7feed096d9e31dce"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga08bb91b4849ec00a7feed096d9e31dce">bc_stop</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga08bb91b4849ec00a7feed096d9e31dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the Battery Charging block.  <a href="#ga08bb91b4849ec00a7feed096d9e31dce">More...</a><br /></td></tr>
<tr class="separator:ga08bb91b4849ec00a7feed096d9e31dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa609c3d5f131d1259a9416fd5a7a5979">bc_is_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether the BC module is active or not.  <a href="#gaa609c3d5f131d1259a9416fd5a7a5979">More...</a><br /></td></tr>
<tr class="separator:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b0ddf5ed205702d4628341428a3bf4"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab4b0ddf5ed205702d4628341428a3bf4">bc_fsm</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gab4b0ddf5ed205702d4628341428a3bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the Battery Charging block state machine.  <a href="#gab4b0ddf5ed205702d4628341428a3bf4">More...</a><br /></td></tr>
<tr class="separator:gab4b0ddf5ed205702d4628341428a3bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeddb10ad3d52f33172877e7b46b7611a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaeddb10ad3d52f33172877e7b46b7611a">bc_port_is_cdp</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaeddb10ad3d52f33172877e7b46b7611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the port is currently functioning as a CDP (Charging Downstream Port).  <a href="#gaeddb10ad3d52f33172877e7b46b7611a">More...</a><br /></td></tr>
<tr class="separator:gaeddb10ad3d52f33172877e7b46b7611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90d6d317d6183bc5e277a66a3e9de18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae90d6d317d6183bc5e277a66a3e9de18">bc_sleep</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gae90d6d317d6183bc5e277a66a3e9de18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function puts the Battery Charging block to sleep.  <a href="#gae90d6d317d6183bc5e277a66a3e9de18">More...</a><br /></td></tr>
<tr class="separator:gae90d6d317d6183bc5e277a66a3e9de18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3638da0a0c79743d5db6127741635079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3638da0a0c79743d5db6127741635079">bc_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga3638da0a0c79743d5db6127741635079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function wakes up the Battery Charging block.  <a href="#ga3638da0a0c79743d5db6127741635079">More...</a><br /></td></tr>
<tr class="separator:ga3638da0a0c79743d5db6127741635079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be37ea9b028a57c60684196e3fcf905"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__group__ccgxAppCommon.html#structbc__status__t">bc_status_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1be37ea9b028a57c60684196e3fcf905">bc_get_status</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1be37ea9b028a57c60684196e3fcf905"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the current status of the BC state machine.  <a href="#ga1be37ea9b028a57c60684196e3fcf905">More...</a><br /></td></tr>
<tr class="separator:ga1be37ea9b028a57c60684196e3fcf905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8eb59136a5bc414a24d202a88ab500b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa8eb59136a5bc414a24d202a88ab500b">bc_pd_event_handler</a> (cy_stc_pdstack_context_t *context, cy_en_pdstack_app_evt_t evt)</td></tr>
<tr class="memdesc:gaa8eb59136a5bc414a24d202a88ab500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles events from USB-PD Device Policy Manager.  <a href="#gaa8eb59136a5bc414a24d202a88ab500b">More...</a><br /></td></tr>
<tr class="separator:gaa8eb59136a5bc414a24d202a88ab500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52979fd63b3499dfd069ba41d2bf28a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad52979fd63b3499dfd069ba41d2bf28a">bc_set_bc_evt</a> (cy_stc_pdstack_context_t *context, uint32_t evt_mask)</td></tr>
<tr class="memdesc:gad52979fd63b3499dfd069ba41d2bf28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets an event status for the BC state machine to process.  <a href="#gad52979fd63b3499dfd069ba41d2bf28a">More...</a><br /></td></tr>
<tr class="separator:gad52979fd63b3499dfd069ba41d2bf28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736c168139e927c108d7ef55e90fc7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga736c168139e927c108d7ef55e90fc7a9">bc_clear_bc_evt</a> (cy_stc_pdstack_context_t *context, uint32_t evt_mask)</td></tr>
<tr class="memdesc:ga736c168139e927c108d7ef55e90fc7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears one or more BC events after the state machine has dealt with them.  <a href="#ga736c168139e927c108d7ef55e90fc7a9">More...</a><br /></td></tr>
<tr class="separator:ga736c168139e927c108d7ef55e90fc7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3a9699353dc54d34ea5dce1c71b0466c">ccg_get_system_max_pdp</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the port PDP value.  <a href="#ga3a9699353dc54d34ea5dce1c71b0466c">More...</a><br /></td></tr>
<tr class="separator:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d2d443f2be2f1b549e8835870ddf95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab5d2d443f2be2f1b549e8835870ddf95">qc_set_cf_limit</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gab5d2d443f2be2f1b549e8835870ddf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables Current Foldback on the port when in QC mode.  <a href="#gab5d2d443f2be2f1b549e8835870ddf95">More...</a><br /></td></tr>
<tr class="separator:gab5d2d443f2be2f1b549e8835870ddf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9aa42ffefc5ac3d753b11847cb398fab">bc_afc_form_vi</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function forms the new AFC source capabilities based on the power passed.  <a href="#ga9aa42ffefc5ac3d753b11847cb398fab">More...</a><br /></td></tr>
<tr class="separator:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcee615842c5c62ebf8d36e83a919afe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabcee615842c5c62ebf8d36e83a919afe">bc_12_get_status</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gabcee615842c5c62ebf8d36e83a919afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current BC 1.2 status for a PD port.  <a href="#gabcee615842c5c62ebf8d36e83a919afe">More...</a><br /></td></tr>
<tr class="separator:gabcee615842c5c62ebf8d36e83a919afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0755713453a2b8aed13e4e11ae94354c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0755713453a2b8aed13e4e11ae94354c">bc_is_qc_afc_charging_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga0755713453a2b8aed13e4e11ae94354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether the QC or AFC charging modes are active or not.  <a href="#ga0755713453a2b8aed13e4e11ae94354c">More...</a><br /></td></tr>
<tr class="separator:ga0755713453a2b8aed13e4e11ae94354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf9f0a988f1e8c31a092c4f2c45256ad7">bc_is_bc_charging_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether legacy charging modes are active or not.  <a href="#gaf9f0a988f1e8c31a092c4f2c45256ad7">More...</a><br /></td></tr>
<tr class="separator:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ebf8bad9d327493c62bdf056fd2585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga92ebf8bad9d327493c62bdf056fd2585">bc_is_bc_connected</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga92ebf8bad9d327493c62bdf056fd2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether legacy charging connect negotiated or not.  <a href="#ga92ebf8bad9d327493c62bdf056fd2585">More...</a><br /></td></tr>
<tr class="separator:ga92ebf8bad9d327493c62bdf056fd2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b8bb762de654cf691bfa2d4910b373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae2b8bb762de654cf691bfa2d4910b373">gpio_set_value</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, bool value)</td></tr>
<tr class="memdesc:gae2b8bb762de654cf691bfa2d4910b373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the GPIO to the required state.  <a href="#gae2b8bb762de654cf691bfa2d4910b373">More...</a><br /></td></tr>
<tr class="separator:gae2b8bb762de654cf691bfa2d4910b373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4a340d82409454a45acd6068e69419b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab4a340d82409454a45acd6068e69419b">gpio_read_value</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:gab4a340d82409454a45acd6068e69419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GPIO current state.  <a href="#gab4a340d82409454a45acd6068e69419b">More...</a><br /></td></tr>
<tr class="separator:gab4a340d82409454a45acd6068e69419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81d9271ce686992981a09ab31509c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac81d9271ce686992981a09ab31509c0f">gpio_set_drv_mode</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a> drv_mode)</td></tr>
<tr class="memdesc:gac81d9271ce686992981a09ab31509c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the GPIO with the desired drive mode.  <a href="#gac81d9271ce686992981a09ab31509c0f">More...</a><br /></td></tr>
<tr class="separator:gac81d9271ce686992981a09ab31509c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga061aa6d28ccf3abfd22e9add75199b9c">gpio_int_set_config</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, uint8_t int_mode)</td></tr>
<tr class="memdesc:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the GPIO with the desired interrupt setting.  <a href="#ga061aa6d28ccf3abfd22e9add75199b9c">More...</a><br /></td></tr>
<tr class="separator:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6213d69fa12f6d561f97cb17358d9b40"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6213d69fa12f6d561f97cb17358d9b40">gpio_register_intr_cb</a> (uint8_t port, <a class="el" href="group__group__ccgxAppCommon.html#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">gpio_intr_cb_t</a> intr_cb)</td></tr>
<tr class="memdesc:ga6213d69fa12f6d561f97cb17358d9b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback to be called when a GPIO interrupt associated with a specific port is triggered.  <a href="#ga6213d69fa12f6d561f97cb17358d9b40">More...</a><br /></td></tr>
<tr class="separator:ga6213d69fa12f6d561f97cb17358d9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2ba473562725e5d2f2216f63dc504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga05d2ba473562725e5d2f2216f63dc504">hsiom_set_config</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a> hsiom_mode)</td></tr>
<tr class="memdesc:ga05d2ba473562725e5d2f2216f63dc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the IO mode for a CCG device IO.  <a href="#ga05d2ba473562725e5d2f2216f63dc504">More...</a><br /></td></tr>
<tr class="separator:ga05d2ba473562725e5d2f2216f63dc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a37e81fc0c0bf20c918954056bfa83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae5a37e81fc0c0bf20c918954056bfa83">gpio_hsiom_set_config</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a> hsiom_mode, <a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a> drv_mode, bool value)</td></tr>
<tr class="memdesc:gae5a37e81fc0c0bf20c918954056bfa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single function for complete configuration of a CCG IO.  <a href="#gae5a37e81fc0c0bf20c918954056bfa83">More...</a><br /></td></tr>
<tr class="separator:gae5a37e81fc0c0bf20c918954056bfa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac5e3a8c83eb6bae572d7e18cea59edd3">gpio_set_lvttl_mode</a> (uint8_t port)</td></tr>
<tr class="memdesc:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input buffer voltage for a port to LVTTL.  <a href="#gac5e3a8c83eb6bae572d7e18cea59edd3">More...</a><br /></td></tr>
<tr class="separator:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">gpio_get_intr</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the interrupt status on a specific GPIO.  <a href="#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">More...</a><br /></td></tr>
<tr class="separator:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bf50943ae651b4a773d6ada7d8da48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga68bf50943ae651b4a773d6ada7d8da48">gpio_clear_intr</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga68bf50943ae651b4a773d6ada7d8da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt status on the specified GPIO.  <a href="#ga68bf50943ae651b4a773d6ada7d8da48">More...</a><br /></td></tr>
<tr class="separator:ga68bf50943ae651b4a773d6ada7d8da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65daf9463b0aa6902604e565da854174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga65daf9463b0aa6902604e565da854174">lpm_gpio_init</a> (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga65daf9463b0aa6902604e565da854174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the LPM Functionality over GPIO.  <a href="#ga65daf9463b0aa6902604e565da854174">More...</a><br /></td></tr>
<tr class="separator:ga65daf9463b0aa6902604e565da854174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b615f84e123c6f244a3f00f83bfe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab35b615f84e123c6f244a3f00f83bfe9">lpm_gpio_get_lpm_stat</a> (void)</td></tr>
<tr class="memdesc:gab35b615f84e123c6f244a3f00f83bfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get the LPM Status.  <a href="#gab35b615f84e123c6f244a3f00f83bfe9">More...</a><br /></td></tr>
<tr class="separator:gab35b615f84e123c6f244a3f00f83bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ed132647d48c038a2b8f5fb663c97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga74ed132647d48c038a2b8f5fb663c97d">lpm_gpio_clr_lpm_stat</a> (void)</td></tr>
<tr class="memdesc:ga74ed132647d48c038a2b8f5fb663c97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To clear the LPM Status.  <a href="#ga74ed132647d48c038a2b8f5fb663c97d">More...</a><br /></td></tr>
<tr class="separator:ga74ed132647d48c038a2b8f5fb663c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6caaa2a2399383668c403e694d6d5758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6caaa2a2399383668c403e694d6d5758">lpm_gpio_set_intr</a> (<a class="el" href="group__group__ccgxAppCommon.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a> intr)</td></tr>
<tr class="memdesc:ga6caaa2a2399383668c403e694d6d5758"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Set the Interrupt.  <a href="#ga6caaa2a2399383668c403e694d6d5758">More...</a><br /></td></tr>
<tr class="separator:ga6caaa2a2399383668c403e694d6d5758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga19fbabfd67fd86ce7060a960b5c43d80">lpm_gpio_clr_intr</a> (void)</td></tr>
<tr class="memdesc:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Clear the Interrupt.  <a href="#ga19fbabfd67fd86ce7060a960b5c43d80">More...</a><br /></td></tr>
<tr class="separator:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464ab91815a8c55916d179cb924d6103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga464ab91815a8c55916d179cb924d6103">lpm_gpio_read</a> (void)</td></tr>
<tr class="memdesc:ga464ab91815a8c55916d179cb924d6103"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Read the LPM_GPIO.  <a href="#ga464ab91815a8c55916d179cb924d6103">More...</a><br /></td></tr>
<tr class="separator:ga464ab91815a8c55916d179cb924d6103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0c9ba09522c7b06b4f4b78965af64cfc">eval_src_cap</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *srcCap, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the PD stack to allow the application logic to evaluate the Source Capabilities received from the port partner and generate the desired request.  <a href="#ga0c9ba09522c7b06b4f4b78965af64cfc">More...</a><br /></td></tr>
<tr class="separator:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1aa9ecc53e672ff08c97ea9beb3905ed">eval_rdo</a> (cy_stc_pdstack_context_t *context, cy_pd_pd_do_t rdo, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the PD stack to allow the application to evaluate a power request data object received from the port partner and decide whether it should be satisfied.  <a href="#ga1aa9ecc53e672ff08c97ea9beb3905ed">More...</a><br /></td></tr>
<tr class="separator:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga92f950d9ddc50d8a7d3f69a23de108f1">app_update_rdo</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *srcCap, cy_pdstack_app_resp_cbk_t *appResp)</td></tr>
<tr class="memdesc:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only applicable in the case of the CCG6 device, and can be used by the application logic to modify the RDO generated by the ROM-ed version of the eval_src_cap function.  <a href="#ga92f950d9ddc50d8a7d3f69a23de108f1">More...</a><br /></td></tr>
<tr class="separator:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3817297cc85653d6201cd1e48159ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab3817297cc85653d6201cd1e48159ada">psrc_set_voltage</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:gab3817297cc85653d6201cd1e48159ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the VBus source voltage to the desired value.  <a href="#gab3817297cc85653d6201cd1e48159ada">More...</a><br /></td></tr>
<tr class="separator:gab3817297cc85653d6201cd1e48159ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1881bbbc0107059d70bc39920a6738f2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1881bbbc0107059d70bc39920a6738f2">psrc_get_voltage</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1881bbbc0107059d70bc39920a6738f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the VBus source voltage that is currently configured.  <a href="#ga1881bbbc0107059d70bc39920a6738f2">More...</a><br /></td></tr>
<tr class="separator:ga1881bbbc0107059d70bc39920a6738f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93e96d009a6e6717ffef86a79f7d223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad93e96d009a6e6717ffef86a79f7d223">psrc_set_current</a> (cy_stc_pdstack_context_t *context, uint16_t cur_10mA)</td></tr>
<tr class="memdesc:gad93e96d009a6e6717ffef86a79f7d223"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the VBus source current limit.  <a href="#gad93e96d009a6e6717ffef86a79f7d223">More...</a><br /></td></tr>
<tr class="separator:gad93e96d009a6e6717ffef86a79f7d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae078c31aa1f7fce6bba129df400dc862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae078c31aa1f7fce6bba129df400dc862">psrc_enable</a> (cy_stc_pdstack_context_t *context, cy_pdstack_pwr_ready_cbk_t pwr_ready_handler)</td></tr>
<tr class="memdesc:gae078c31aa1f7fce6bba129df400dc862"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the VBus power supply.  <a href="#gae078c31aa1f7fce6bba129df400dc862">More...</a><br /></td></tr>
<tr class="separator:gae078c31aa1f7fce6bba129df400dc862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae522dada2eb76d90d46a6f428a31eff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae522dada2eb76d90d46a6f428a31eff1">psrc_disable</a> (cy_stc_pdstack_context_t *context, cy_pdstack_pwr_ready_cbk_t pwr_ready_handler)</td></tr>
<tr class="memdesc:gae522dada2eb76d90d46a6f428a31eff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the VBus power supply.  <a href="#gae522dada2eb76d90d46a6f428a31eff1">More...</a><br /></td></tr>
<tr class="separator:gae522dada2eb76d90d46a6f428a31eff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad019aef09ac99508d3cca4d2315b7df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad019aef09ac99508d3cca4d2315b7df7">ccg_sensor_init</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gad019aef09ac99508d3cca4d2315b7df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the sensor check block.  <a href="#gad019aef09ac99508d3cca4d2315b7df7">More...</a><br /></td></tr>
<tr class="separator:gad019aef09ac99508d3cca4d2315b7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae913d9eb9a79f913e28c8d34de043686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae913d9eb9a79f913e28c8d34de043686">ccg_sensor_is_idle</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gae913d9eb9a79f913e28c8d34de043686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates to know if sensor check module is idle.  <a href="#gae913d9eb9a79f913e28c8d34de043686">More...</a><br /></td></tr>
<tr class="separator:gae913d9eb9a79f913e28c8d34de043686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaea471cf36a082dfaecfa15dc4b1028c3">ccg_sensor_check</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates caller to update system operating condition to the operating condition indicated by VIN and temperature of the sensors.  <a href="#gaea471cf36a082dfaecfa15dc4b1028c3">More...</a><br /></td></tr>
<tr class="separator:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b142ab3e283161f9e168c898afce86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6b142ab3e283161f9e168c898afce86a">ccg_sensor_debounce_task</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga6b142ab3e283161f9e168c898afce86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the debounce related checks.  <a href="#ga6b142ab3e283161f9e168c898afce86a">More...</a><br /></td></tr>
<tr class="separator:ga6b142ab3e283161f9e168c898afce86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546096050c83925d0c4099621f3486c0"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga546096050c83925d0c4099621f3486c0">ccg_sensor_temp_ec</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint8_t *buffer)</td></tr>
<tr class="memdesc:ga546096050c83925d0c4099621f3486c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current sensor temperature.  <a href="#ga546096050c83925d0c4099621f3486c0">More...</a><br /></td></tr>
<tr class="separator:ga546096050c83925d0c4099621f3486c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2cfae9d8db4a74aed03c538607b6b1a9">ccg_get_battery_voltage</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts VIN(Battery) voltage.  <a href="#ga2cfae9d8db4a74aed03c538607b6b1a9">More...</a><br /></td></tr>
<tr class="separator:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1372cb404e2fdc0104e55166417b5f9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad1372cb404e2fdc0104e55166417b5f9">ccg_get_sys_oc</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, <a class="el" href="group__group__ccgxAppCommon.html#gad456bb3be6173dae2997daf53c4aabc8">CCG_OC_BUFFER_DATE_TYPE</a> *oc_buffer)</td></tr>
<tr class="memdesc:gad1372cb404e2fdc0104e55166417b5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts undebounced OC specific information.  <a href="#gad1372cb404e2fdc0104e55166417b5f9">More...</a><br /></td></tr>
<tr class="separator:gad1372cb404e2fdc0104e55166417b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61443c0e3f64be9b85774528c6776eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga61443c0e3f64be9b85774528c6776eee">ccg_set_sensor_sleep_mode</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga61443c0e3f64be9b85774528c6776eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the VIN OV/UV comparators for sleep mode.  <a href="#ga61443c0e3f64be9b85774528c6776eee">More...</a><br /></td></tr>
<tr class="separator:ga61443c0e3f64be9b85774528c6776eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3e5f3c378ced3b9a9b88a864380db5a6">eval_dr_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates Data role swap request.  <a href="#ga3e5f3c378ced3b9a9b88a864380db5a6">More...</a><br /></td></tr>
<tr class="separator:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga28f7b458a4b35ab3a85dfec4aa969001">eval_pr_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates Power role swap request.  <a href="#ga28f7b458a4b35ab3a85dfec4aa969001">More...</a><br /></td></tr>
<tr class="separator:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bebef1cf20542c23c68e15ab2394fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga35bebef1cf20542c23c68e15ab2394fe">eval_vconn_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga35bebef1cf20542c23c68e15ab2394fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates VConn swap request.  <a href="#ga35bebef1cf20542c23c68e15ab2394fe">More...</a><br /></td></tr>
<tr class="separator:ga35bebef1cf20542c23c68e15ab2394fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga606d6f10e4bf215d5ecbae3ac5422220">ccg_volt_temp_map</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint16_t therm_volt)</td></tr>
<tr class="memdesc:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the thermal voltage read from thermistor to temperature value.  <a href="#ga606d6f10e4bf215d5ecbae3ac5422220">More...</a><br /></td></tr>
<tr class="separator:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10bbe4117fc4502f3ffe303a46a1819"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab10bbe4117fc4502f3ffe303a46a1819">ccg_get_sensor_temperature</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint8_t sensor_id)</td></tr>
<tr class="memdesc:gab10bbe4117fc4502f3ffe303a46a1819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the temperature of the specified sensor.  <a href="#gab10bbe4117fc4502f3ffe303a46a1819">More...</a><br /></td></tr>
<tr class="separator:gab10bbe4117fc4502f3ffe303a46a1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e2b20a4fb4669bdb692d782124c94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga81e2b20a4fb4669bdb692d782124c94e">register_thermistor_mapping_table</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, const uint16_t *volt_temp_table)</td></tr>
<tr class="memdesc:ga81e2b20a4fb4669bdb692d782124c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the thermal voltage read from thermistor to temperature value.  <a href="#ga81e2b20a4fb4669bdb692d782124c94e">More...</a><br /></td></tr>
<tr class="separator:ga81e2b20a4fb4669bdb692d782124c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5edab6846405e6f18f4d584bf20d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2b5edab6846405e6f18f4d584bf20d42">uvdm_get_cur_nb_cmd</a> (void)</td></tr>
<tr class="memdesc:ga2b5edab6846405e6f18f4d584bf20d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current non blocking command opcode.  <a href="#ga2b5edab6846405e6f18f4d584bf20d42">More...</a><br /></td></tr>
<tr class="separator:ga2b5edab6846405e6f18f4d584bf20d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga88917f34345b4c2ffbd7f05e004cbbcb">uvdm_reset_nb_cmd_state</a> (void)</td></tr>
<tr class="memdesc:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets internal state and trackers related to Non Blocking flash write operation at the end of write operation.  <a href="#ga88917f34345b4c2ffbd7f05e004cbbcb">More...</a><br /></td></tr>
<tr class="separator:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f4e6875801da6056c0c87f2785cae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaa6f4e6875801da6056c0c87f2785cae8">uvdm_enter_cy_alt_mode</a> (void)</td></tr>
<tr class="memdesc:gaa6f4e6875801da6056c0c87f2785cae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Mode Entry Handler This function is called when CCG enters CY Flashing Alternate mode.  <a href="#gaa6f4e6875801da6056c0c87f2785cae8">More...</a><br /></td></tr>
<tr class="separator:gaa6f4e6875801da6056c0c87f2785cae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0e712a6dac921e9a12c1519f162132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaee0e712a6dac921e9a12c1519f162132">uvdm_exit_cy_alt_mode</a> (void)</td></tr>
<tr class="memdesc:gaee0e712a6dac921e9a12c1519f162132"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Mode Exit Handler This function is called when CCG exits CY Flashing Alternate mode.  <a href="#gaee0e712a6dac921e9a12c1519f162132">More...</a><br /></td></tr>
<tr class="separator:gaee0e712a6dac921e9a12c1519f162132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48049492908c61b5a2bcb7869611cf89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga48049492908c61b5a2bcb7869611cf89">uvdm_get_flashing_mode</a> (void)</td></tr>
<tr class="memdesc:ga48049492908c61b5a2bcb7869611cf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CY Flashing Mode Status This function returns the current state of CY Flashing Alternate Mode.  <a href="#ga48049492908c61b5a2bcb7869611cf89">More...</a><br /></td></tr>
<tr class="separator:ga48049492908c61b5a2bcb7869611cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae932229b8c737c4f5f9605d19c64c439"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae932229b8c737c4f5f9605d19c64c439">uvdm_handle_device_reset</a> (uint32_t reset_sig)</td></tr>
<tr class="memdesc:gae932229b8c737c4f5f9605d19c64c439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle Device Reset Command This function handles device Reset command.  <a href="#gae932229b8c737c4f5f9605d19c64c439">More...</a><br /></td></tr>
<tr class="separator:gae932229b8c737c4f5f9605d19c64c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a21400ab342fd3552ed6791a834f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga45a21400ab342fd3552ed6791a834f88">uvdm_handle_cmd</a> (cy_stc_pdstack_context_t *context, uint32_t *rx_pkt, cy_pd_pd_do_t **vdm_rspn_pkt, uint8_t *vdo_count, flash_cbk_t flash_cb)</td></tr>
<tr class="memdesc:ga45a21400ab342fd3552ed6791a834f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Alternate Mode UVDM Command Handler.  <a href="#ga45a21400ab342fd3552ed6791a834f88">More...</a><br /></td></tr>
<tr class="separator:ga45a21400ab342fd3552ed6791a834f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace292f2968c8a0fbe52bd5fb817219d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gace292f2968c8a0fbe52bd5fb817219d9">uvdm_qc_pps_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint32_t *rx_pkt, cy_pd_pd_do_t **vdm_rspn_pkt, uint8_t *vdo_count)</td></tr>
<tr class="memdesc:gace292f2968c8a0fbe52bd5fb817219d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles all QC 5.0/4.0 Protocol UVDM commands.  <a href="#gace292f2968c8a0fbe52bd5fb817219d9">More...</a><br /></td></tr>
<tr class="separator:gace292f2968c8a0fbe52bd5fb817219d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9937839e0df56ab2ae92677a3c4fc89c">sln_flashing_uvdm_handler</a> (uint32_t *rx_pkt, cy_pd_pd_do_t *vdm_rspn_pkt, uint8_t *vdo_count, cy_en_pdstack_status_t *response_code)</td></tr>
<tr class="memdesc:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flashing Alternate Mode UVDM Command solution space extension handler.  <a href="#ga9937839e0df56ab2ae92677a3c4fc89c">More...</a><br /></td></tr>
<tr class="separator:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9d243d72311578fc26927b0d8b3d18"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaba9d243d72311578fc26927b0d8b3d18">pwm_get_duty_cycle</a> (uint16_t vbus, uint16_t min_volt, uint16_t max_volt, uint16_t pwm_period)</td></tr>
<tr class="memdesc:gaba9d243d72311578fc26927b0d8b3d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function computes PWM duty cycle needed to generate requested VBUS.  <a href="#gaba9d243d72311578fc26927b0d8b3d18">More...</a><br /></td></tr>
<tr class="separator:gaba9d243d72311578fc26927b0d8b3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0176c9ee7a447e6d05e118ec148581c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0176c9ee7a447e6d05e118ec148581c3">vbus_ctrl_pwm_turn_on</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga0176c9ee7a447e6d05e118ec148581c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the PWM signal that turns VBus ON.  <a href="#ga0176c9ee7a447e6d05e118ec148581c3">More...</a><br /></td></tr>
<tr class="separator:ga0176c9ee7a447e6d05e118ec148581c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbe2b31bf4f30e721228591b8420357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1dbe2b31bf4f30e721228591b8420357">vbus_ctrl_pwm_turn_off</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1dbe2b31bf4f30e721228591b8420357"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function disables the PWM signal thus turning VBus OFF.  <a href="#ga1dbe2b31bf4f30e721228591b8420357">More...</a><br /></td></tr>
<tr class="separator:ga1dbe2b31bf4f30e721228591b8420357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2bd5743b05e845340eea6f5c7054c0e0">vbus_ctrl_pwm_set_volt</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the Type-C VBUS voltage to requested level using PWM.  <a href="#ga2bd5743b05e845340eea6f5c7054c0e0">More...</a><br /></td></tr>
<tr class="separator:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabcd12abd4dc2a695f0aca4fcc9e9b9be">vbus_ctrl_fb_enable</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the Type-C VBUS voltage feedback logic.  <a href="#gabcd12abd4dc2a695f0aca4fcc9e9b9be">More...</a><br /></td></tr>
<tr class="separator:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf7e37244c8eb9e2b5a85195fb5aa04c1">vbus_ctrl_fb_disable</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function disables the Type-C VBUS voltage feedback logic.  <a href="#gaf7e37244c8eb9e2b5a85195fb5aa04c1">More...</a><br /></td></tr>
<tr class="separator:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5534b8c6f4249d42f6719791ed55ff38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5534b8c6f4249d42f6719791ed55ff38">vbus_ctrl_fb_set_volt</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:ga5534b8c6f4249d42f6719791ed55ff38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the Type-C VBUS voltage to requested level using FB (feedback).  <a href="#ga5534b8c6f4249d42f6719791ed55ff38">More...</a><br /></td></tr>
<tr class="separator:ga5534b8c6f4249d42f6719791ed55ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5f522c241cad2d51bac5a524312fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7c5f522c241cad2d51bac5a524312fe7">vbus_ctrl_set_is_idle</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga7c5f522c241cad2d51bac5a524312fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns whether the vbus voltage transition is over or not.  <a href="#ga7c5f522c241cad2d51bac5a524312fe7">More...</a><br /></td></tr>
<tr class="separator:ga7c5f522c241cad2d51bac5a524312fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d395b4a3c133de574b7362d20540c8b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga7d395b4a3c133de574b7362d20540c8b">vbus_ctrl_get_trim_idac</a> (cy_stc_usbpd_context_t *context, uint16_t volt_mv)</td></tr>
<tr class="memdesc:ga7d395b4a3c133de574b7362d20540c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns trimmed IDAC value for the required voltage.  <a href="#ga7d395b4a3c133de574b7362d20540c8b">More...</a><br /></td></tr>
<tr class="separator:ga7d395b4a3c133de574b7362d20540c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7b269e24c8f4fec661273d02586fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga3d7b269e24c8f4fec661273d02586fa3">vdm_data_init</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3d7b269e24c8f4fec661273d02586fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the VDM data from the configuration table.  <a href="#ga3d7b269e24c8f4fec661273d02586fa3">More...</a><br /></td></tr>
<tr class="separator:ga3d7b269e24c8f4fec661273d02586fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae954f67f0c7fc0fa4d0b77e86d39efa9">vdm_update_data</a> (cy_stc_pdstack_context_t *context, uint8_t id_vdo_cnt, uint8_t *id_vdo_p, uint8_t svid_vdo_cnt, uint8_t *svid_vdo_p, uint16_t mode_resp_len, uint8_t *mode_resp_p)</td></tr>
<tr class="memdesc:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the VDM data for CCG to be changed.  <a href="#gae954f67f0c7fc0fa4d0b77e86d39efa9">More...</a><br /></td></tr>
<tr class="separator:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b760125b3e49c10b90e064750acb68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4b760125b3e49c10b90e064750acb68e">eval_vdm</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *vdm, cy_pdstack_vdm_resp_cbk_t vdm_resp_handler)</td></tr>
<tr class="memdesc:ga4b760125b3e49c10b90e064750acb68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible for analyzing and processing received VDM.  <a href="#ga4b760125b3e49c10b90e064750acb68e">More...</a><br /></td></tr>
<tr class="separator:ga4b760125b3e49c10b90e064750acb68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga4d682bedad7997cf296ac7b472ccb4e5">eval_enter_usb</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *eudo, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to evaluate an Enter_USB request and report whether it should be accepted or rejected.  <a href="#ga4d682bedad7997cf296ac7b472ccb4e5">More...</a><br /></td></tr>
<tr class="separator:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga07f91bf53ad0b7c9ce8bc3727ef8512d">vdm_assign_port_num</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign unique port number in a CCG3PA multiport system.  <a href="#ga07f91bf53ad0b7c9ce8bc3727ef8512d">More...</a><br /></td></tr>
<tr class="separator:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7f98716771b456abbe7bd132d8255f"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga5a7f98716771b456abbe7bd132d8255f">boot_validate_configtable</a> (uint8_t *table_p)</td></tr>
<tr class="memdesc:ga5a7f98716771b456abbe7bd132d8255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the configuration table specified.  <a href="#ga5a7f98716771b456abbe7bd132d8255f">More...</a><br /></td></tr>
<tr class="separator:ga5a7f98716771b456abbe7bd132d8255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edb32e1e45d388147185b053875f8fe"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga1edb32e1e45d388147185b053875f8fe">boot_validate_fw</a> (<a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *fw_metadata)</td></tr>
<tr class="memdesc:ga1edb32e1e45d388147185b053875f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the firmware image associated with the given metadata.  <a href="#ga1edb32e1e45d388147185b053875f8fe">More...</a><br /></td></tr>
<tr class="separator:ga1edb32e1e45d388147185b053875f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861588454fc735f940e5cdaaaa65cce9"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga861588454fc735f940e5cdaaaa65cce9">boot_handle_validate_fw_cmd</a> (<a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a> fw_mode)</td></tr>
<tr class="memdesc:ga861588454fc735f940e5cdaaaa65cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the VALIDATE_FW command from HPI or UVDM.  <a href="#ga861588454fc735f940e5cdaaaa65cce9">More...</a><br /></td></tr>
<tr class="separator:ga861588454fc735f940e5cdaaaa65cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86165e9d25f534b61706bce73087523a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga86165e9d25f534b61706bce73087523a">boot_get_wait_time</a> (void)</td></tr>
<tr class="memdesc:ga86165e9d25f534b61706bce73087523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boot-wait delay configured for the application.  <a href="#ga86165e9d25f534b61706bce73087523a">More...</a><br /></td></tr>
<tr class="separator:ga86165e9d25f534b61706bce73087523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">boot_start</a> (void)</td></tr>
<tr class="memdesc:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the firmware binary to be loaded.  <a href="#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">More...</a><br /></td></tr>
<tr class="separator:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12781921cca4e29d0c7516cc7431da31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga12781921cca4e29d0c7516cc7431da31">boot_check_for_valid_fw</a> (void)</td></tr>
<tr class="memdesc:ga12781921cca4e29d0c7516cc7431da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the presence of alternate firmware waiting to be validated.  <a href="#ga12781921cca4e29d0c7516cc7431da31">More...</a><br /></td></tr>
<tr class="separator:ga12781921cca4e29d0c7516cc7431da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga8c99ecc08d4d9906ab7cea73c403241d">iecs_check_for_valid_fw</a> (uint8_t *first_row)</td></tr>
<tr class="memdesc:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a alternate firmware according to IECS SFWv command.  <a href="#ga8c99ecc08d4d9906ab7cea73c403241d">More...</a><br /></td></tr>
<tr class="separator:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t">fw_img_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga734e1c7b35b3b51709c1997cf4b27adc">get_boot_mode_reason</a> (void)</td></tr>
<tr class="memdesc:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmap containing the reason for boot mode.  <a href="#ga734e1c7b35b3b51709c1997cf4b27adc">More...</a><br /></td></tr>
<tr class="separator:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga06f1bc2f59ba8e0476dd349d1d2970eb">boot_jump_to_fw</a> (void)</td></tr>
<tr class="memdesc:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer control to the firmware binary identified by boot_start.  <a href="#ga06f1bc2f59ba8e0476dd349d1d2970eb">More...</a><br /></td></tr>
<tr class="separator:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d02f78bb5df076263df291bb175ea0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae7d02f78bb5df076263df291bb175ea0">boot_get_boot_seq</a> (uint8_t fwid)</td></tr>
<tr class="memdesc:gae7d02f78bb5df076263df291bb175ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boot sequence number value for the specified firmware image.  <a href="#gae7d02f78bb5df076263df291bb175ea0">More...</a><br /></td></tr>
<tr class="separator:gae7d02f78bb5df076263df291bb175ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea7548753e977c3e1509c663150b39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga9ea7548753e977c3e1509c663150b39c">boot_update_fw_status</a> (void)</td></tr>
<tr class="memdesc:ga9ea7548753e977c3e1509c663150b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to validate firmware images and update image status.  <a href="#ga9ea7548753e977c3e1509c663150b39c">More...</a><br /></td></tr>
<tr class="separator:ga9ea7548753e977c3e1509c663150b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a19c1628a70d606e705085976c8c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga92a19c1628a70d606e705085976c8c3a">boot_jump_to_app</a> (uint32_t appId)</td></tr>
<tr class="memdesc:ga92a19c1628a70d606e705085976c8c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to jump from bootloader to application.  <a href="#ga92a19c1628a70d606e705085976c8c3a">More...</a><br /></td></tr>
<tr class="separator:ga92a19c1628a70d606e705085976c8c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333040c32b526560e0189685c2477943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga333040c32b526560e0189685c2477943">instrumentation_init</a> (void)</td></tr>
<tr class="memdesc:ga333040c32b526560e0189685c2477943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data structures associated with application instrumentation.  <a href="#ga333040c32b526560e0189685c2477943">More...</a><br /></td></tr>
<tr class="separator:ga333040c32b526560e0189685c2477943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad367c15b42304176602a24ab5cc659a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad367c15b42304176602a24ab5cc659a8">instrumentation_start</a> (void)</td></tr>
<tr class="memdesc:gad367c15b42304176602a24ab5cc659a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start any timers or tasks associated with application instrumentation.  <a href="#gad367c15b42304176602a24ab5cc659a8">More...</a><br /></td></tr>
<tr class="separator:gad367c15b42304176602a24ab5cc659a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafe5f4d31cceda3638f9d2c3831c34cdc">instrumentation_task</a> (void)</td></tr>
<tr class="memdesc:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform tasks associated with application instrumentation.  <a href="#gafe5f4d31cceda3638f9d2c3831c34cdc">More...</a><br /></td></tr>
<tr class="separator:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8347fe4114de4120402ee8a63fce69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab8347fe4114de4120402ee8a63fce69b">instrumentation_register_cb</a> (<a class="el" href="group__group__ccgxAppCommon.html#gaa07a7ee21510d24dac6326ec163d8e3c">instrumentation_cb_t</a> cb)</td></tr>
<tr class="memdesc:gab8347fe4114de4120402ee8a63fce69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register solution level callback function to be executed when instrumentation fault occurs.  <a href="#gab8347fe4114de4120402ee8a63fce69b">More...</a><br /></td></tr>
<tr class="separator:gab8347fe4114de4120402ee8a63fce69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e95b70077dc7b63704262bff2cbf0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gad8e95b70077dc7b63704262bff2cbf0d">watchdog_timer_cb</a> (cy_timer_id_t id, void *callbackContext)</td></tr>
<tr class="memdesc:gad8e95b70077dc7b63704262bff2cbf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback to reset device if main loop has not been run as expected.  <a href="#gad8e95b70077dc7b63704262bff2cbf0d">More...</a><br /></td></tr>
<tr class="separator:gad8e95b70077dc7b63704262bff2cbf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15c4225e91f14e2f6a65b7364072218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac15c4225e91f14e2f6a65b7364072218">sys_set_device_mode</a> (<a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a> fw_mode)</td></tr>
<tr class="memdesc:gac15c4225e91f14e2f6a65b7364072218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current firmware mode.  <a href="#gac15c4225e91f14e2f6a65b7364072218">More...</a><br /></td></tr>
<tr class="separator:gac15c4225e91f14e2f6a65b7364072218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf3055e3da9c959dc80ddc470b6b55f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gafcf3055e3da9c959dc80ddc470b6b55f">sys_get_device_mode</a> (void)</td></tr>
<tr class="memdesc:gafcf3055e3da9c959dc80ddc470b6b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current firmware mode.  <a href="#gafcf3055e3da9c959dc80ddc470b6b55f">More...</a><br /></td></tr>
<tr class="separator:gafcf3055e3da9c959dc80ddc470b6b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6397ed1dc06c18b5cb4a9319d541fea"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gac6397ed1dc06c18b5cb4a9319d541fea">sys_get_boot_version</a> (void)</td></tr>
<tr class="memdesc:gac6397ed1dc06c18b5cb4a9319d541fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bootloader version.  <a href="#gac6397ed1dc06c18b5cb4a9319d541fea">More...</a><br /></td></tr>
<tr class="separator:gac6397ed1dc06c18b5cb4a9319d541fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdba5beea711269ed3f46634e94bc3a7"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gabdba5beea711269ed3f46634e94bc3a7">sys_get_img1_fw_version</a> (void)</td></tr>
<tr class="memdesc:gabdba5beea711269ed3f46634e94bc3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version for firmware image-1.  <a href="#gabdba5beea711269ed3f46634e94bc3a7">More...</a><br /></td></tr>
<tr class="separator:gabdba5beea711269ed3f46634e94bc3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947940b9e622ee4149fbfaf274490e89"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga947940b9e622ee4149fbfaf274490e89">sys_get_img2_fw_version</a> (void)</td></tr>
<tr class="memdesc:ga947940b9e622ee4149fbfaf274490e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get version for firmware image-2.  <a href="#ga947940b9e622ee4149fbfaf274490e89">More...</a><br /></td></tr>
<tr class="separator:ga947940b9e622ee4149fbfaf274490e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb25d6f6fbd3f83cd52490a7f512036f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gadb25d6f6fbd3f83cd52490a7f512036f">sys_get_fw_img1_start_addr</a> (void)</td></tr>
<tr class="memdesc:gadb25d6f6fbd3f83cd52490a7f512036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash start address of firmware image-1.  <a href="#gadb25d6f6fbd3f83cd52490a7f512036f">More...</a><br /></td></tr>
<tr class="separator:gadb25d6f6fbd3f83cd52490a7f512036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e435a4db3c7f52b66028130122d1f0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gab4e435a4db3c7f52b66028130122d1f0">sys_get_fw_img2_start_addr</a> (void)</td></tr>
<tr class="memdesc:gab4e435a4db3c7f52b66028130122d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flash start address of firmware image-2.  <a href="#gab4e435a4db3c7f52b66028130122d1f0">More...</a><br /></td></tr>
<tr class="separator:gab4e435a4db3c7f52b66028130122d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fc9cd3057ac95b0e49757f71e574ae"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga05fc9cd3057ac95b0e49757f71e574ae">sys_get_recent_fw_image</a> (void)</td></tr>
<tr class="memdesc:ga05fc9cd3057ac95b0e49757f71e574ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the more recently update firmware image.  <a href="#ga05fc9cd3057ac95b0e49757f71e574ae">More...</a><br /></td></tr>
<tr class="separator:ga05fc9cd3057ac95b0e49757f71e574ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3269855f28bae98095f7438d6fdba14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaf3269855f28bae98095f7438d6fdba14">sys_get_silicon_id</a> (uint32_t *silicon_id)</td></tr>
<tr class="memdesc:gaf3269855f28bae98095f7438d6fdba14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Silicon ID of device.  <a href="#gaf3269855f28bae98095f7438d6fdba14">More...</a><br /></td></tr>
<tr class="separator:gaf3269855f28bae98095f7438d6fdba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a74c2da279eb11649cd6833b7a238f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga57a74c2da279eb11649cd6833b7a238f">get_silicon_revision</a> (void)</td></tr>
<tr class="memdesc:ga57a74c2da279eb11649cd6833b7a238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Silicon revision.  <a href="#ga57a74c2da279eb11649cd6833b7a238f">More...</a><br /></td></tr>
<tr class="separator:ga57a74c2da279eb11649cd6833b7a238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97534834ce00cff0659df470096e9ee1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga97534834ce00cff0659df470096e9ee1">sys_get_custom_info_addr</a> (void)</td></tr>
<tr class="memdesc:ga97534834ce00cff0659df470096e9ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start address of Customer info section.  <a href="#ga97534834ce00cff0659df470096e9ee1">More...</a><br /></td></tr>
<tr class="separator:ga97534834ce00cff0659df470096e9ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae9d856b58a5f1f45b2be1cad8aea0ab"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaae9d856b58a5f1f45b2be1cad8aea0ab">sys_get_bcdDevice_version</a> (uint32_t ver_addr)</td></tr>
<tr class="memdesc:gaae9d856b58a5f1f45b2be1cad8aea0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get bcdDevice version of device.  <a href="#gaae9d856b58a5f1f45b2be1cad8aea0ab">More...</a><br /></td></tr>
<tr class="separator:gaae9d856b58a5f1f45b2be1cad8aea0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0744c70187ce4c00822179005c6c0b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0744c70187ce4c00822179005c6c0b2b">i2c_scb_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t scb_index, <a class="el" href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a> mode, <a class="el" href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a> clock_freq, uint8_t slave_addr, uint8_t slave_mask, <a class="el" href="group__group__ccgxAppCommon.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a> cb_fun_ptr, uint8_t *scratch_buffer, uint16_t scratch_buffer_size)</td></tr>
<tr class="memdesc:ga0744c70187ce4c00822179005c6c0b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure one of the I2C blocks as required.  <a href="#ga0744c70187ce4c00822179005c6c0b2b">More...</a><br /></td></tr>
<tr class="separator:ga0744c70187ce4c00822179005c6c0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f4c815aac116cc730b5166787962a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga64f4c815aac116cc730b5166787962a1">i2c_scb_deinit</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga64f4c815aac116cc730b5166787962a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize a previously initialized SCB block.  <a href="#ga64f4c815aac116cc730b5166787962a1">More...</a><br /></td></tr>
<tr class="separator:ga64f4c815aac116cc730b5166787962a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378575c70ffa0b89f129860177848143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga378575c70ffa0b89f129860177848143">i2c_scb_write</a> (uint8_t scb_index, uint8_t *source_ptr, uint8_t size, uint8_t *count)</td></tr>
<tr class="memdesc:ga378575c70ffa0b89f129860177848143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the transmit FIFO associated with the I2C block.  <a href="#ga378575c70ffa0b89f129860177848143">More...</a><br /></td></tr>
<tr class="separator:ga378575c70ffa0b89f129860177848143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cbeecd552d2640e432e2c57111f35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gae2cbeecd552d2640e432e2c57111f35c">i2c_reset</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:gae2cbeecd552d2640e432e2c57111f35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the I2C block specified.  <a href="#gae2cbeecd552d2640e432e2c57111f35c">More...</a><br /></td></tr>
<tr class="separator:gae2cbeecd552d2640e432e2c57111f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga472c6396fd36ea9ddda27cc6ef9e6986">i2c_slave_ack_ctrl</a> (uint8_t scb_index, bool enable)</td></tr>
<tr class="memdesc:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable the I2C slave acknowledgement.  <a href="#ga472c6396fd36ea9ddda27cc6ef9e6986">More...</a><br /></td></tr>
<tr class="separator:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c52132c4b3089409dac99443ed4a231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga2c52132c4b3089409dac99443ed4a231">i2c_scb_is_idle</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga2c52132c4b3089409dac99443ed4a231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the I2C block is idle.  <a href="#ga2c52132c4b3089409dac99443ed4a231">More...</a><br /></td></tr>
<tr class="separator:ga2c52132c4b3089409dac99443ed4a231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga706524d3e4a8d5a195d7cb940e9149e4">i2c_scb_enable_wakeup</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable deep-sleep wakeup due to address match on the specified SCB block.  <a href="#ga706524d3e4a8d5a195d7cb940e9149e4">More...</a><br /></td></tr>
<tr class="separator:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga0d55f6c9d1f49de78bd51450f176d24d">i2c_timer_cb</a> (cy_timer_id_t id, void *callbackContext)</td></tr>
<tr class="memdesc:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback that indicates I2C transaction that has timed out.  <a href="#ga0d55f6c9d1f49de78bd51450f176d24d">More...</a><br /></td></tr>
<tr class="separator:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga85a9c9e60bdf6a05fcb7fdba90406a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga85a9c9e60bdf6a05fcb7fdba90406a1c">gl_img1_fw_metadata</a></td></tr>
<tr class="memdesc:ga85a9c9e60bdf6a05fcb7fdba90406a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to metadata associated with the Image-1 FW binary.  <a href="#ga85a9c9e60bdf6a05fcb7fdba90406a1c">More...</a><br /></td></tr>
<tr class="separator:ga85a9c9e60bdf6a05fcb7fdba90406a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6dccbc6cb6e0410853a38bdcccb6af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga6e6dccbc6cb6e0410853a38bdcccb6af">gl_img2_fw_metadata</a></td></tr>
<tr class="memdesc:ga6e6dccbc6cb6e0410853a38bdcccb6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to metadata associated with the Image-2 FW binary.  <a href="#ga6e6dccbc6cb6e0410853a38bdcccb6af">More...</a><br /></td></tr>
<tr class="separator:ga6e6dccbc6cb6e0410853a38bdcccb6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977a6217be08fd77b2dd8ba0bc82e9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga977a6217be08fd77b2dd8ba0bc82e9c5">gl_img1_fw_pseudo_metadata</a></td></tr>
<tr class="memdesc:ga977a6217be08fd77b2dd8ba0bc82e9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to pseudo metadata associated with the Image-1 FW binary.  <a href="#ga977a6217be08fd77b2dd8ba0bc82e9c5">More...</a><br /></td></tr>
<tr class="separator:ga977a6217be08fd77b2dd8ba0bc82e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58312a28a5af18f3fe3f5e5673d13855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga58312a28a5af18f3fe3f5e5673d13855">gl_img2_fw_pseudo_metadata</a></td></tr>
<tr class="memdesc:ga58312a28a5af18f3fe3f5e5673d13855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to pseudo metadata associated with the Image-2 FW binary.  <a href="#ga58312a28a5af18f3fe3f5e5673d13855">More...</a><br /></td></tr>
<tr class="separator:ga58312a28a5af18f3fe3f5e5673d13855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2fd46b2891d6b8cb7aad1d2dac6fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t">fw_img_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#gaec2fd46b2891d6b8cb7aad1d2dac6fd3">gl_img_status</a></td></tr>
<tr class="memdesc:gaec2fd46b2891d6b8cb7aad1d2dac6fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current firmware image status.  <a href="#gaec2fd46b2891d6b8cb7aad1d2dac6fd3">More...</a><br /></td></tr>
<tr class="separator:gaec2fd46b2891d6b8cb7aad1d2dac6fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574f405ef4ef66e82b34bd7fbe117b9f"><td class="memItemLeft" align="right" valign="top"><a id="ga574f405ef4ef66e82b34bd7fbe117b9f"></a>
<a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga574f405ef4ef66e82b34bd7fbe117b9f">gl_active_fw</a></td></tr>
<tr class="memdesc:ga574f405ef4ef66e82b34bd7fbe117b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable representing the current firmware mode. <br /></td></tr>
<tr class="separator:ga574f405ef4ef66e82b34bd7fbe117b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861ab3087452424e2b5e9396766ac014"><td class="memItemLeft" align="right" valign="top"><a id="ga861ab3087452424e2b5e9396766ac014"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon.html#ga861ab3087452424e2b5e9396766ac014">gl_invalid_version</a> [8]</td></tr>
<tr class="memdesc:ga861ab3087452424e2b5e9396766ac014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid firmware version. <br /></td></tr>
<tr class="separator:ga861ab3087452424e2b5e9396766ac014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structvdm__info__config__t" id="structvdm__info__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structvdm__info__config__t">&#9670;&nbsp;</a></span>vdm_info_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct vdm_info_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a39ef72456c064700206dad3d6de7d524"></a>uint32_t</td>
<td class="fieldname">
discId[7]</td>
<td class="fielddoc">
Discover ID response. </td></tr>
<tr><td class="fieldtype">
<a id="a4f555322ecc6034f3f3d10893f3017d5"></a>uint16_t</td>
<td class="fieldname">
dIdLength</td>
<td class="fielddoc">
Discover ID response length. </td></tr>
<tr><td class="fieldtype">
<a id="a7322bfc658c96e696d72af5f23480a69"></a>uint32_t</td>
<td class="fieldname">
sVid[7]</td>
<td class="fielddoc">
SVID array. </td></tr>
<tr><td class="fieldtype">
<a id="a9c3ce0813f0940369ddcf31e3a320215"></a>uint16_t</td>
<td class="fieldname">
sVidLength</td>
<td class="fielddoc">
SVID length. </td></tr>
<tr><td class="fieldtype">
<a id="a8e910f020f2f110ada9d34494b715b52"></a>uint32_t</td>
<td class="fieldname">
discMode[7]</td>
<td class="fielddoc">
Discover mode response. </td></tr>
<tr><td class="fieldtype">
<a id="a7cb02a5d67bed268208c8cd525df064b"></a>uint16_t</td>
<td class="fieldname">
disModeLength</td>
<td class="fielddoc">
Discover mode length. </td></tr>
</table>

</div>
</div>
<a name="structalt__mode__config__t" id="structalt__mode__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structalt__mode__config__t">&#9670;&nbsp;</a></span>alt_mode_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct alt_mode_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab4c4988d1b916323d75a52b3d2aae68c"></a>uint8_t volatile</td>
<td class="fieldname">
dpCfgSupported</td>
<td class="fielddoc">
DP supported configuration. </td></tr>
<tr><td class="fieldtype">
<a id="ac0487cf242f4d01b9b3afef515449579"></a>uint8_t volatile</td>
<td class="fieldname">
dpMuxControl</td>
<td class="fielddoc">
DP Mux control mode. </td></tr>
<tr><td class="fieldtype">
<a id="aa6eff7e65790874ce8264acda806b81d"></a>uint8_t volatile</td>
<td class="fieldname">
altModeTrig</td>
<td class="fielddoc">
DP Alt mode trigger. </td></tr>
<tr><td class="fieldtype">
<a id="aa1ee6de7eab1eb332c5358c124a36329"></a>uint8_t</td>
<td class="fieldname">
dpOper</td>
<td class="fielddoc">
DP operating mode. </td></tr>
<tr><td class="fieldtype">
<a id="af93bc8f09d6cb8bcb7c565f16da1da89"></a>uint8_t</td>
<td class="fieldname">
dpPrefMode</td>
<td class="fielddoc">
DP preferred operating mode. </td></tr>
</table>

</div>
</div>
<a name="structapp__status__t" id="structapp__status__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structapp__status__t">&#9670;&nbsp;</a></span>app_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct app_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a65b5d4ce2881f7aca80accd3e2bacfd9"></a>cy_pdstack_pwr_ready_cbk_t</td>
<td class="fieldname">
pwr_ready_cbk</td>
<td class="fielddoc">
Registered Power source callback. </td></tr>
<tr><td class="fieldtype">
<a id="a8251a6a124e91a512c25fd34dccdd513"></a>cy_pdstack_sink_discharge_off_cbk_t</td>
<td class="fieldname">
snk_dis_cbk</td>
<td class="fielddoc">
Registered Power sink callback. </td></tr>
<tr><td class="fieldtype">
<a id="ae11bef8d7fcd525554235dd3a6ad33fb"></a>app_resp_t</td>
<td class="fieldname">
appResp</td>
<td class="fielddoc">
Buffer for APP responses. </td></tr>
<tr><td class="fieldtype">
<a id="a4759dfb70eef3c606220f029bfc172ed"></a>vdm_resp_t</td>
<td class="fieldname">
vdmResp</td>
<td class="fielddoc">
Buffer for VDM responses. </td></tr>
<tr><td class="fieldtype">
<a id="ae0e6fea91120502ceb4e6fc158ef0e4b"></a>uint16_t</td>
<td class="fieldname">
psrc_volt</td>
<td class="fielddoc">
Current Psource voltage in mV. </td></tr>
<tr><td class="fieldtype">
<a id="a4a5f6e7b9649ece29695bf5f29b3d350"></a>uint16_t</td>
<td class="fieldname">
psrc_volt_old</td>
<td class="fielddoc">
Old Psource voltage in mV. </td></tr>
<tr><td class="fieldtype">
<a id="a22dff32dd497be0d25b720d8bab2338b"></a>uint16_t</td>
<td class="fieldname">
psnk_volt</td>
<td class="fielddoc">
Current PSink voltage in mV units. </td></tr>
<tr><td class="fieldtype">
<a id="ac74a6c65c7452d667f2b29c0177a6d9c"></a>uint16_t</td>
<td class="fieldname">
psnk_cur</td>
<td class="fielddoc">
Current PSink current in 10mA units. </td></tr>
<tr><td class="fieldtype">
<a id="aba303870b751f8a985aefe7cdabfe2bf"></a>uint8_t</td>
<td class="fieldname">
vdm_task_en</td>
<td class="fielddoc">
Flag to indicate is vdm task manager enabled. </td></tr>
<tr><td class="fieldtype">
<a id="a1b238f0e0b55a69971772716ea7e5b79"></a>uint8_t</td>
<td class="fieldname">
disc_cbl_pending</td>
<td class="fielddoc">
Flag to indicate is cable discovery is pending. </td></tr>
<tr><td class="fieldtype">
<a id="a4b9e5136dd8505b5b4e1e081dcf7fe2b"></a>uint8_t</td>
<td class="fieldname">
cbl_disc_id_finished</td>
<td class="fielddoc">
Flag to indicate that cable disc id finished. </td></tr>
<tr><td class="fieldtype">
<a id="afaafca370784c82770c042f9b608d4a9"></a>uint8_t</td>
<td class="fieldname">
vdm_version</td>
<td class="fielddoc">
Live VDM version. </td></tr>
<tr><td class="fieldtype">
<a id="a87cb4e0541a343a91da403cd335adeeb"></a>uint8_t</td>
<td class="fieldname">
alt_mode_trig_mask</td>
<td class="fielddoc">
Mask to indicate which alt mode should be enabled by EC. </td></tr>
<tr><td class="fieldtype">
<a id="a7c64100ca719df89579bbf3b70ae575a"></a>uint8_t</td>
<td class="fieldname">
dfp_alt_mode_mask</td>
<td class="fielddoc">
Mask to enable DFP alternate modes. </td></tr>
<tr><td class="fieldtype">
<a id="a0c8db6d75f3f12f9ecda10f5e8456b7b"></a>uint8_t</td>
<td class="fieldname">
ufp_alt_mode_mask</td>
<td class="fielddoc">
Mask to enable UFP alternate modes. </td></tr>
<tr><td class="fieldtype">
<a id="a92aae67fa29f895da5e58468c62fba0a"></a>uint16_t</td>
<td class="fieldname">
custom_hpi_svid</td>
<td class="fielddoc">
Holds custom alternate mode SVID received from HPI. </td></tr>
<tr><td class="fieldtype">
<a id="a95481e8ce67e925f5fcdefee2f0f8256"></a>volatile uint8_t</td>
<td class="fieldname">
fault_status</td>
<td class="fielddoc">
Fault status bits for this port. </td></tr>
<tr><td class="fieldtype">
<a id="a8dc7c28fdd685df922c21cebe19270c3"></a>bool</td>
<td class="fieldname">
alt_mode_entered</td>
<td class="fielddoc">
Flag to indicate is alternate modes currently entered. </td></tr>
<tr><td class="fieldtype">
<a id="aedb235ddb19fce2eb4023ffa76b2247f"></a>bool</td>
<td class="fieldname">
vdm_prcs_failed</td>
<td class="fielddoc">
Flag to indicate is vdm process failed. </td></tr>
<tr><td class="fieldtype">
<a id="a62e3af9024cfc9974b7e5519aeafdeca"></a>bool</td>
<td class="fieldname">
is_vbus_on</td>
<td class="fielddoc">
Is supplying VBUS flag. </td></tr>
<tr><td class="fieldtype">
<a id="ac1af2016c765989d13346b03bb3aaa83"></a>bool</td>
<td class="fieldname">
is_vconn_on</td>
<td class="fielddoc">
Is supplying VCONN flag. </td></tr>
<tr><td class="fieldtype">
<a id="a480da28cb0b295fefe77974f62b3e378"></a>bool</td>
<td class="fieldname">
vdm_retry_pending</td>
<td class="fielddoc">
Whether VDM retry on timeout is pending. </td></tr>
<tr><td class="fieldtype">
<a id="af3b290fa27cbceda48f5b0f974d61755"></a>bool</td>
<td class="fieldname">
psrc_rising</td>
<td class="fielddoc">
Voltage ramp up/down. </td></tr>
<tr><td class="fieldtype">
<a id="aac95114f4081b1297a1108033de2fb04"></a>bool</td>
<td class="fieldname">
cbl_rst_done</td>
<td class="fielddoc">
Flag to indicate that cable reset was provided. </td></tr>
<tr><td class="fieldtype">
<a id="a29a23e3e3b3a167b845e40f6666ab41c"></a>bool</td>
<td class="fieldname">
trig_cbl_rst</td>
<td class="fielddoc">
Flag to trigger cable reset. </td></tr>
<tr><td class="fieldtype">
<a id="a8bf5ba984ecd77f5050f489a99e81372"></a>bool</td>
<td class="fieldname">
cur_fb_enabled</td>
<td class="fielddoc">
Indicates that current foldback is enabled. </td></tr>
<tr><td class="fieldtype">
<a id="ae26a6d6bf4db94d483a12affa8455b2c"></a>bool</td>
<td class="fieldname">
ld_sw_ctrl</td>
<td class="fielddoc">
Indicates whether the VBUS load switch control is active or not. </td></tr>
<tr><td class="fieldtype">
<a id="aee17ba5d49b495a006f9efd7b5d6133b"></a>bool</td>
<td class="fieldname">
bc_12_src_disabled</td>
<td class="fielddoc">
BC 1.2 source disabled flag. </td></tr>
<tr><td class="fieldtype">
<a id="a575e39d8b1e6c88c6f263faf96a51420"></a>bool</td>
<td class="fieldname">
bc_snk_disabled</td>
<td class="fielddoc">
BC 1.2 sink disabled flag. </td></tr>
<tr><td class="fieldtype">
<a id="a41e14984ac88d19882fd0aabc5dec636"></a>bool</td>
<td class="fieldname">
is_mux_busy</td>
<td class="fielddoc">
Flag to indicate that mux is switching. </td></tr>
<tr><td class="fieldtype">
<a id="a5f8b77b8b48e7247f81126c5c3f3c759"></a>cy_pdstack_vdm_resp_cbk_t</td>
<td class="fieldname">
vdm_resp_cbk</td>
<td class="fielddoc">
VDM response handler callback. </td></tr>
<tr><td class="fieldtype">
<a id="a30801f4abe3771c45b70fded9948192f"></a>bool</td>
<td class="fieldname">
is_vdm_pending</td>
<td class="fielddoc">
VDM handling flag for MUX callback. </td></tr>
<tr><td class="fieldtype">
<a id="aeba023241d0697d2bc6016b2bad1caed"></a>bool</td>
<td class="fieldname">
keep_vconn_src</td>
<td class="fielddoc">
Flag indicating that we should keep VConn source role. </td></tr>
<tr><td class="fieldtype">
<a id="a3972096e7f7b764796ff6c666cffa2f3"></a>uint8_t</td>
<td class="fieldname">
app_pending_swaps</td>
<td class="fielddoc">
Variable denoting the types of swap operation that are pending. </td></tr>
<tr><td class="fieldtype">
<a id="a0788033ffac992e0dfa6d53785505ed4"></a>uint8_t</td>
<td class="fieldname">
actv_swap_type</td>
<td class="fielddoc">
Denotes the active Swap operation. </td></tr>
<tr><td class="fieldtype">
<a id="a1052e2bd009403deca557ca9e34a2c80"></a>uint8_t</td>
<td class="fieldname">
actv_swap_count</td>
<td class="fielddoc">
Denotes number of active swap attempts completed. </td></tr>
<tr><td class="fieldtype">
<a id="aad040c998eb01494a675369125cb4ef1"></a>uint16_t</td>
<td class="fieldname">
actv_swap_delay</td>
<td class="fielddoc">
Delay to be applied between repeated swap attempts. </td></tr>
<tr><td class="fieldtype">
<a id="a091bbe03473aa5eef29189eeef5a166e"></a>uint8_t</td>
<td class="fieldname">
turn_on_temp_limit</td>
<td class="fielddoc">
Temperature threshold to turn on internal FET after turn off condition. </td></tr>
<tr><td class="fieldtype">
<a id="a0f1726ea9b041de29684122bdee8e2f3"></a>uint8_t</td>
<td class="fieldname">
turn_off_temp_limit</td>
<td class="fielddoc">
Temperature threshold to turn off internal FET. </td></tr>
<tr><td class="fieldtype">
<a id="a9d60dc240288359ff986784132bd55a1"></a>bool</td>
<td class="fieldname">
is_hot_shutdown</td>
<td class="fielddoc">
Indicates that hot shutdown detected. </td></tr>
<tr><td class="fieldtype">
<a id="afc84ce4de3967666d9816c564092ac65"></a>bool</td>
<td class="fieldname">
usb4_active</td>
<td class="fielddoc">
Indicates that USB4 mode was entered. </td></tr>
<tr><td class="fieldtype">
<a id="a004720f4849053cc349eba922c69f6f8"></a>uint8_t</td>
<td class="fieldname">
usb4_data_rst_cnt</td>
<td class="fielddoc">
Indicates number of Dat Reset retries. </td></tr>
<tr><td class="fieldtype">
<a id="a7a3be9c65a2b7d4583ff9d92547ae9a6"></a>bool</td>
<td class="fieldname">
debug_acc_attached</td>
<td class="fielddoc">
Debug accessory attach status. </td></tr>
<tr><td class="fieldtype">
<a id="aaff0d7fbb70b1fcae0b24e41c871b90f"></a>bool</td>
<td class="fieldname">
retimer_dis_req</td>
<td class="fielddoc">
Flag to indicate disable Retimer request in ridge layer. </td></tr>
<tr><td class="fieldtype">
<a id="aabdd0f707d2b9b70f0963b36125ab9d1"></a>bool</td>
<td class="fieldname">
usb2Supp</td>
<td class="fielddoc">
USB2 supported flag for Ridge related applications. </td></tr>
<tr><td class="fieldtype">
<a id="af24c254a73dc5185dae07103b3080f2e"></a>bool</td>
<td class="fieldname">
usb3_supp</td>
<td class="fielddoc">
USB3 supported flag for Ridge related applications. </td></tr>
<tr><td class="fieldtype">
<a id="ac6282b5c48b52b1400bf89d23c47c4b8"></a>bool</td>
<td class="fieldname">
skip_mux_config</td>
<td class="fielddoc">
Flag to indicate do not configure MUX. </td></tr>
<tr><td class="fieldtype">
<a id="addf6ea2710c3ec3c545e161952dd4bbb"></a>bool</td>
<td class="fieldname">
cable_retimer_supp</td>
<td class="fielddoc">
Retimer supported flag for Ridge related applications. </td></tr>
<tr><td class="fieldtype">
<a id="ab4b630dafcb771257203d0f3cadeee9d"></a><a class="el" href="group__group__ccgxAppCommon.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a></td>
<td class="fieldname">
mux_stat</td>
<td class="fielddoc">
Indicates current MUX status. </td></tr>
<tr><td class="fieldtype">
<a id="a67b070586b67c405a9fa99675d9995a9"></a>bool</td>
<td class="fieldname">
apu_reset_pending</td>
<td class="fielddoc">
Flag to indicate that APU reset is in progress. </td></tr>
<tr><td class="fieldtype">
<a id="ae7001e5f5c6291842a1e865c93d438af"></a>cy_pd_pd_do_t</td>
<td class="fieldname">
tbt_cbl_vdo</td>
<td class="fielddoc">
Holds TBT cable VDO. </td></tr>
</table>

</div>
</div>
<a name="unionbc__dp__dm__state__t" id="unionbc__dp__dm__state__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionbc__dp__dm__state__t">&#9670;&nbsp;</a></span>bc_dp_dm_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union bc_dp_dm_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac83e5ba916f89ad8ccae8616f8ff78c2"></a>uint16_t</td>
<td class="fieldname">
state</td>
<td class="fielddoc">
Combined status of Dp and Dm. </td></tr>
<tr><td class="fieldtype">
<a id="a4d0aab5184470fce18128589e7518abb"></a>uint8_t</td>
<td class="fieldname">
d[2]</td>
<td class="fielddoc">
Individual status of Dp(d[0]) and Dm(d[1]). </td></tr>
</table>

</div>
</div>
<a name="structbc__status__t" id="structbc__status__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structbc__status__t">&#9670;&nbsp;</a></span>bc_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bc_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a9025a82c17af5995bb24215bfc080b0a"></a><a class="el" href="group__group__ccgxAppCommon.html#gaf6b59aae9342e308eac3d4c7447edabe">bc_charge_mode_t</a></td>
<td class="fieldname">
cur_mode</td>
<td class="fielddoc">
Active charging scheme. </td></tr>
<tr><td class="fieldtype">
<a id="a2cd298e6662711515e60fe7bb951046e"></a><a class="el" href="group__group__ccgxAppCommon.html#ga9aa71d2453ce7697ebd7b34f8c951392">bc_state_t</a></td>
<td class="fieldname">
bc_fsm_state</td>
<td class="fielddoc">
Current state of the BC state machine. </td></tr>
<tr><td class="fieldtype">
<a id="ad9d2536065213cd3f9c5451804edd60d"></a>uint32_t volatile</td>
<td class="fieldname">
bc_evt</td>
<td class="fielddoc">
Bitmap representing event notifications to the state machine. </td></tr>
<tr><td class="fieldtype">
<a id="a8d3c18234c89459f1e5b5e60dedecc49"></a>uint16_t</td>
<td class="fieldname">
max_volt</td>
<td class="fielddoc">
Maximum Sink VBus voltage in mV units. </td></tr>
<tr><td class="fieldtype">
<a id="ab8eb7052d7e973493cf390816300cbb3"></a>uint16_t</td>
<td class="fieldname">
min_volt</td>
<td class="fielddoc">
Minimum Sink VBus voltage in mV units. </td></tr>
<tr><td class="fieldtype">
<a id="ac7e68e9a2a25ff9db725c9f18f51a3b3"></a>uint16_t</td>
<td class="fieldname">
max_amp</td>
<td class="fielddoc">
Maximum Sink current in 10 mA units. </td></tr>
<tr><td class="fieldtype">
<a id="a1742afd1c9e0685c68e47b48de68a62b"></a>uint16_t</td>
<td class="fieldname">
min_amp</td>
<td class="fielddoc">
Minimum Sink current in 10 mA units. </td></tr>
<tr><td class="fieldtype">
<a id="a7ad286e796f7712b9256e1cc18279f9f"></a>uint16_t</td>
<td class="fieldname">
cur_volt</td>
<td class="fielddoc">
Active VBus voltage in mV units. </td></tr>
<tr><td class="fieldtype">
<a id="a29192ce0e36355688fa07f61531a8221"></a>uint16_t</td>
<td class="fieldname">
cur_amp</td>
<td class="fielddoc">
Active supply current in 10 mA units. </td></tr>
<tr><td class="fieldtype">
<a id="a34249da55933632fe8d3103ec555659d"></a>bool volatile</td>
<td class="fieldname">
connected</td>
<td class="fielddoc">
Whether BC connection is detected. </td></tr>
<tr><td class="fieldtype">
<a id="a25da7d543cd457602c5cb2e969393e0e"></a>bool volatile</td>
<td class="fieldname">
mismatch</td>
<td class="fielddoc">
Whether BC voltage/current mismatch is detected. </td></tr>
<tr><td class="fieldtype">
<a id="a20dcaaa5d689dd21fbb1c9563476566e"></a>bool volatile</td>
<td class="fieldname">
comp_rising</td>
<td class="fielddoc">
Whether comparator is looking for a rising edge or falling edge. </td></tr>
<tr><td class="fieldtype">
<a id="aab57aa7d8b60d451cc1b145dd99e9d10"></a><a class="el" href="group__group__ccgxAppCommon.html#unionbc__dp__dm__state__t">bc_dp_dm_state_t</a> volatile</td>
<td class="fieldname">
dp_dm_status</td>
<td class="fielddoc">
Debounced status of the DP/DM pins. </td></tr>
<tr><td class="fieldtype">
<a id="a61c614da9f4c74770c083560f43f2457"></a><a class="el" href="group__group__ccgxAppCommon.html#unionbc__dp__dm__state__t">bc_dp_dm_state_t</a> volatile</td>
<td class="fieldname">
old_dp_dm_status</td>
<td class="fielddoc">
Previous status of the DP/DM pins. </td></tr>
<tr><td class="fieldtype">
<a id="a72308361338885e4f37405a085c44689"></a><a class="el" href="group__group__ccgxAppCommon.html#gab9b85b4ed92d797ea6bcb9c869f2fd47">bc_sink_timer_t</a></td>
<td class="fieldname">
cur_timer</td>
<td class="fielddoc">
Identifies the BC timer that is running. </td></tr>
<tr><td class="fieldtype">
<a id="ab77e27b74abb657761f79c058287628c"></a>uint16_t</td>
<td class="fieldname">
requested_qc_volt</td>
<td class="fielddoc">
Recently requested voltage from QC Source in mV units. </td></tr>
<tr><td class="fieldtype">
<a id="a3bdd5dfbaa6a53bf417604c27303da4f"></a>uint8_t</td>
<td class="fieldname">
afc_src_msg_count</td>
<td class="fielddoc">
Number of successful AFC message transfers. <p>3 transfers have to be successful before we can make any VI changes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac391cc6a0866adfef9b1a190697d31db"></a>bool volatile</td>
<td class="fieldname">
afc_src_is_matched</td>
<td class="fielddoc">
Status of VI match from the last received AFC byte. </td></tr>
<tr><td class="fieldtype">
<a id="a2f1616b42e0db580a62745050e52fbfe"></a>uint8_t</td>
<td class="fieldname">
afc_src_cur_match_byte</td>
<td class="fielddoc">
The currently matched AFC VI value. </td></tr>
<tr><td class="fieldtype">
<a id="a93dd3e27b785108d9c26a7b458ed88c5"></a>uint8_t</td>
<td class="fieldname">
afc_src_last_match_byte</td>
<td class="fielddoc">
Previously matched AFC VI value. </td></tr>
<tr><td class="fieldtype">
<a id="a496b0b81b0ff2e1645c7a574718f90f5"></a>uint8_t</td>
<td class="fieldname">
afc_src_matched_byte</td>
<td class="fielddoc">
Holds the VI byte that is matched in two out of the last three messages. </td></tr>
<tr><td class="fieldtype">
<a id="aecf5b5e23f122eaa5bb9f4039feb942a"></a>uint8_t</td>
<td class="fieldname">
afc_src_match_count</td>
<td class="fielddoc">
Number of AFC VI byte matches detected. </td></tr>
<tr><td class="fieldtype">
<a id="ac51e739cdbe05652c4462dacd688f593"></a>uint8_t</td>
<td class="fieldname">
afc_tx_active</td>
<td class="fielddoc">
Whether AFC message transmission is active. </td></tr>
<tr><td class="fieldtype">
<a id="a970ce029cfe65d6129a267132e8b0cb5"></a>uint8_t</td>
<td class="fieldname">
afc_snk_cur_vi_byte</td>
<td class="fielddoc">
AFC VI value recently sent by Sink. </td></tr>
<tr><td class="fieldtype">
<a id="a33ba77411136f5fc7786f20acb13020f"></a>uint8_t</td>
<td class="fieldname">
afc_retry_count</td>
<td class="fielddoc">
Sink tx retries counter. </td></tr>
<tr><td class="fieldtype">
<a id="a29c68e23978f60c92ce84331486bbd68"></a>bool</td>
<td class="fieldname">
attach</td>
<td class="fielddoc">
Whether BC attach has been detected. </td></tr>
</table>

</div>
</div>
<a name="unionfw__img__status__t" id="unionfw__img__status__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionfw__img__status__t">&#9670;&nbsp;</a></span>fw_img_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union fw_img_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a601557347e858d7a85d4b29e3e7e65fb"></a>uint8_t</td>
<td class="fieldname">
val</td>
<td class="fielddoc">
Integer field used for direct manipulation of reason code. </td></tr>
<tr><td class="fieldtype">
<a id="a40bf87946c2741c25deb6b7fa55546e7"></a>struct <a class="el" href="group__group__ccgxAppCommon.html#structfw__img__status__t_1_1fw__mode__reason__t">fw_mode_reason_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
Struct containing the status fields in the boot mode reason value. </td></tr>
</table>

</div>
</div>
<a name="structfw__img__status__t_1_1fw__mode__reason__t" id="structfw__img__status__t_1_1fw__mode__reason__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structfw__img__status__t_1_1fw__mode__reason__t">&#9670;&nbsp;</a></span>fw_img_status_t::fw_mode_reason_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fw_img_status_t::fw_mode_reason_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ada0644f3a35275852a0a323efa756e79"></a>uint8_t</td>
<td class="fieldname">
boot_mode_request: 1</td>
<td class="fielddoc">
Boot mode request made by FW. </td></tr>
<tr><td class="fieldtype">
<a id="a4c561bc2c8805f2d4c05b6d7e80da962"></a>uint8_t</td>
<td class="fieldname">
reserved: 1</td>
<td class="fielddoc">
Reserved field: Will be zero. </td></tr>
<tr><td class="fieldtype">
<a id="aea283bd75c9af62fbad8c5763c63aa43"></a>uint8_t</td>
<td class="fieldname">
fw1_invalid: 1</td>
<td class="fielddoc">
FW1 image invalid: 0=Valid, 1=Invalid. </td></tr>
<tr><td class="fieldtype">
<a id="ab7b8524592e8068e4c07f624b60dd97b"></a>uint8_t</td>
<td class="fieldname">
fw2_invalid: 1</td>
<td class="fielddoc">
FW2 image invalid: 0=Valid, 1=Invalid. </td></tr>
<tr><td class="fieldtype">
<a id="a53d3a215cfe5eced7d6ecd3c9b64ab11"></a>uint8_t</td>
<td class="fieldname">
reserved1: 4</td>
<td class="fielddoc">
Reserved for later use. </td></tr>
</table>

</div>
</div>
<a name="structsys__fw__metadata__t" id="structsys__fw__metadata__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsys__fw__metadata__t">&#9670;&nbsp;</a></span>sys_fw_metadata_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sys_fw_metadata_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0ef33b8320d56f4e1297543f66aea255"></a>uint8_t</td>
<td class="fieldname">
fw_checksum</td>
<td class="fielddoc">
Offset 00: Single Byte FW Checksum. </td></tr>
<tr><td class="fieldtype">
<a id="a02801268b70a818bbe6946579e75316d"></a>uint32_t</td>
<td class="fieldname">
fw_entry</td>
<td class="fielddoc">
Offset 01: FW Entry Address. </td></tr>
<tr><td class="fieldtype">
<a id="ae76ad5f73de5373d751bec42314055c5"></a>uint16_t</td>
<td class="fieldname">
boot_last_row</td>
<td class="fielddoc">
Offset 05: Last Flash row of Bootloader or previous firmware. </td></tr>
<tr><td class="fieldtype">
<a id="a2c15e26edcdae49aa7c25509d27c995a"></a>uint8_t</td>
<td class="fieldname">
reserved1[2]</td>
<td class="fielddoc">
Offset 07: Reserved. </td></tr>
<tr><td class="fieldtype">
<a id="a94164d6018969fc42383facf2eea9241"></a>uint32_t</td>
<td class="fieldname">
fw_size</td>
<td class="fielddoc">
Offset 09: Size of Firmware. </td></tr>
<tr><td class="fieldtype">
<a id="a6475228efc222f5996632d0a00a7f5bd"></a>uint8_t</td>
<td class="fieldname">
reserved2[3]</td>
<td class="fielddoc">
Offset 0D: Reserved. </td></tr>
<tr><td class="fieldtype">
<a id="a3c153f29aca9fd434ae31cf669a51bc3"></a>uint8_t</td>
<td class="fieldname">
active_boot_app</td>
<td class="fielddoc">
Offset 10: Creator specific field. <p>Not used in this implementation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af33d54f61c5c41ae19ff53472a77a32c"></a>uint8_t</td>
<td class="fieldname">
boot_app_ver_status</td>
<td class="fielddoc">
Offset 11: Creator specific field. <p>Not used in this implementation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a3268019eda1848ce6adf41ee21a913db"></a>uint16_t</td>
<td class="fieldname">
boot_app_version</td>
<td class="fielddoc">
Offset 12: Creator specific field. <p>Not used in this implementation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a57a2a20f81d7d4d336a8578885b2e552"></a>uint16_t</td>
<td class="fieldname">
boot_app_id</td>
<td class="fielddoc">
Offset 14: Creator specific field. <p>Not used in this implementation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a4f8475ca7e48abb3007be311fe8c78e0"></a>uint16_t</td>
<td class="fieldname">
metadata_valid</td>
<td class="fielddoc">
Offset 16: Metadata Valid field. <p>Valid if contains "CY". </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a595c9bef832cf16866373325d39b5e91"></a>uint32_t</td>
<td class="fieldname">
fw_version</td>
<td class="fielddoc">
Offset 18: Creator specific field. <p>Not used in this implementation. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="aa3e580adac4d97b876efab291211ade1"></a>uint32_t</td>
<td class="fieldname">
boot_seq</td>
<td class="fielddoc">
Offset 1C: Boot sequence number field. <p>Boot-loader will load the valid FW copy that has the higher sequence number associated with it. </p>
</td></tr>
</table>

</div>
</div>
<a name="structsFWCT__ROW__NO__T" id="structsFWCT__ROW__NO__T"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsFWCT__ROW__NO__T">&#9670;&nbsp;</a></span>sFWCT_ROW_NO_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sFWCT_ROW_NO_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ad710a44db79528811e31d0c5a311381f"></a>uint16_t</td>
<td class="fieldname">
active_row_num</td>
<td class="fielddoc">
Active Row number. </td></tr>
<tr><td class="fieldtype">
<a id="a09636843c722ca67b6ad2278fdaaed5f"></a>uint16_t</td>
<td class="fieldname">
inactive_row_num</td>
<td class="fielddoc">
Inactive row number. </td></tr>
</table>

</div>
</div>
<a name="structi2c__scb__config__t" id="structi2c__scb__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structi2c__scb__config__t">&#9670;&nbsp;</a></span>i2c_scb_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct i2c_scb_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a22d4822b3dae3ec78ca08346881fcdcf"></a><a class="el" href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a></td>
<td class="fieldname">
mode</td>
<td class="fielddoc">
I2C operating mode. </td></tr>
<tr><td class="fieldtype">
<a id="a23f8ad3f4ee39bab05e1fcad201b30ee"></a>uint8_t</td>
<td class="fieldname">
slave_address</td>
<td class="fielddoc">
Slave address. <p>Only valid in slave modes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="adb4813a9ea1010593c0301e07b22357d"></a>uint8_t</td>
<td class="fieldname">
slave_mask</td>
<td class="fielddoc">
Slave address mask. <p>Only valid in slave modes. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab03a8d60517795b884d73684eb041d3f"></a><a class="el" href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a></td>
<td class="fieldname">
clock_freq</td>
<td class="fielddoc">
Clock frequency. <p>Only valid in master mode. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae860b60991edd0d4f990a7df7a5cf0ef"></a><a class="el" href="group__group__ccgxAppCommon.html#gacebb36a46a6b7abb6d95ff1847116864">i2c_scb_state_t</a></td>
<td class="fieldname">
i2c_state</td>
<td class="fielddoc">
Current state of the I2C block. </td></tr>
<tr><td class="fieldtype">
<a id="a635717240d8f88203f1c111629aafd7a"></a>uint8_t *</td>
<td class="fieldname">
buffer</td>
<td class="fielddoc">
Buffer to be used to receive data. </td></tr>
<tr><td class="fieldtype">
<a id="a924becbc569f123db9eb54a0a94e3056"></a>uint16_t</td>
<td class="fieldname">
buf_size</td>
<td class="fielddoc">
Size of receive buffer. </td></tr>
<tr><td class="fieldtype">
<a id="a3d2721566023723a6d1c727fcd4278a0"></a><a class="el" href="group__group__ccgxAppCommon.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a></td>
<td class="fieldname">
cb_fun_ptr</td>
<td class="fielddoc">
Callback function pointer. </td></tr>
<tr><td class="fieldtype">
<a id="a8b5cdedc92ebdc0a253d8879753b6296"></a>volatile uint16_t</td>
<td class="fieldname">
i2c_write_count</td>
<td class="fielddoc">
Current index into receive buffer. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga48ee8ba9b1f5d5aac3735b589ec17807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ee8ba9b1f5d5aac3735b589ec17807">&#9670;&nbsp;</a></span>ADC_VBUS_MIN_OVP_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_VBUS_MIN_OVP_LEVEL&#160;&#160;&#160;(6500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum OVP detection voltage when ADC is used to implement OVP (applies to CCG4). </p>

</div>
</div>
<a id="ga48ed46a1a9fe9a580080492ad6a49ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ed46a1a9fe9a580080492ad6a49ac4">&#9670;&nbsp;</a></span>APP_MAX_SWAP_ATTEMPT_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_MAX_SWAP_ATTEMPT_COUNT&#160;&#160;&#160;(10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of swap attempts to be made when port partner is sending a WAIT response. </p>

</div>
</div>
<a id="ga6e89d3194795f8ca29bfefce338e1bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e89d3194795f8ca29bfefce338e1bbf">&#9670;&nbsp;</a></span>APP_PSOURCE_CF_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSOURCE_CF_TIMER_PERIOD&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duration of Power Source Current Foldback timer (in ms). </p>

</div>
</div>
<a id="ga01f00fd60d39f9d7c1a72828ee27912d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f00fd60d39f9d7c1a72828ee27912d">&#9670;&nbsp;</a></span>APP_PSOURCE_DIS_EXT_DIS_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSOURCE_DIS_EXT_DIS_TIMER_PERIOD&#160;&#160;&#160;(10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duration of extra VBus discharge after voltage drops below desired level (in ms). </p>

</div>
</div>
<a id="ga464f5ed341fd5c0aac3229b534acd2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464f5ed341fd5c0aac3229b534acd2e0">&#9670;&nbsp;</a></span>APP_PSINK_DIS_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSINK_DIS_TIMER_PERIOD&#160;&#160;&#160;(250u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum time allowed for power sink disable operation (in ms). </p>

</div>
</div>
<a id="ga0ea059dcf5842b4a8ab4246f9024d0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea059dcf5842b4a8ab4246f9024d0d6">&#9670;&nbsp;</a></span>APP_PSINK_DIS_MONITOR_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSINK_DIS_MONITOR_TIMER_PERIOD&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period of VBus voltage checks performed during power sink disable operation. </p>

</div>
</div>
<a id="ga436c6ec5ca5d949a16db4f6009ce2f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436c6ec5ca5d949a16db4f6009ce2f3b">&#9670;&nbsp;</a></span>APP_PSINK_DIS_VBUS_IN_DIS_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSINK_DIS_VBUS_IN_DIS_PERIOD&#160;&#160;&#160;(20u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duration of discharge sequence on the VBUS_IN supply in CCG3PA/CCG3PA2 designs. </p>

</div>
</div>
<a id="gaba5cc2e3b98ffc6a577ebb5b84f08bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5cc2e3b98ffc6a577ebb5b84f08bb6">&#9670;&nbsp;</a></span>APP_FAULT_RECOVERY_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_FAULT_RECOVERY_TIMER_PERIOD&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period of VBus presence checks after a fault (Over-Voltage) detection while in a sink contract. </p>

</div>
</div>
<a id="gaf14b4da3bddac22bb8662640ca8991e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14b4da3bddac22bb8662640ca8991e4">&#9670;&nbsp;</a></span>APP_FAULT_RECOVERY_MAX_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_FAULT_RECOVERY_MAX_WAIT&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time for which VBus will be monitored to ensure removal of VBus by a faulty power source. </p>

</div>
</div>
<a id="gaeb5a29913d04b49fe1887530f5324d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5a29913d04b49fe1887530f5324d69">&#9670;&nbsp;</a></span>APP_SBU_DELAYED_CONNECT_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_SBU_DELAYED_CONNECT_PERIOD&#160;&#160;&#160;(25u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay (in ms) between Thunderbolt mode entry and SBU path configuration. </p>

</div>
</div>
<a id="ga160c322e22c2802918fe27bcaa395a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160c322e22c2802918fe27bcaa395a5d">&#9670;&nbsp;</a></span>APP_CBL_DISC_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_CBL_DISC_TIMER_PERIOD&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay to be used between cable discovery init commands. </p>

</div>
</div>
<a id="ga0c17e4678455f70881ee50f56a9a04c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c17e4678455f70881ee50f56a9a04c6">&#9670;&nbsp;</a></span>APP_UFP_RECOV_VCONN_SWAP_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_UFP_RECOV_VCONN_SWAP_TIMER_PERIOD&#160;&#160;&#160;(1000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer period used to run Vconn swap after V5V was lost and recovered while UFP. </p>

</div>
</div>
<a id="ga621922005aa15762f154e6aaec8e7f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga621922005aa15762f154e6aaec8e7f9e">&#9670;&nbsp;</a></span>APP_VDM_BUSY_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_VDM_BUSY_TIMER_PERIOD&#160;&#160;&#160;(50u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VDM busy timer period (in ms). </p>

</div>
</div>
<a id="ga01f8ad95f104da54535e6acfa7cb339d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f8ad95f104da54535e6acfa7cb339d">&#9670;&nbsp;</a></span>APP_VDM_FAIL_RETRY_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_VDM_FAIL_RETRY_PERIOD&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VDM retry (on failure) timer period in ms. </p>

</div>
</div>
<a id="ga6d0121c9b69da45b418d4731d0560088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d0121c9b69da45b418d4731d0560088">&#9670;&nbsp;</a></span>APP_CABLE_POWER_UP_DELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_CABLE_POWER_UP_DELAY&#160;&#160;&#160;(55u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time allowed for cable power up to be complete. </p>

</div>
</div>
<a id="gae8f383b7187d91a8cf26679f43f88da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8f383b7187d91a8cf26679f43f88da4">&#9670;&nbsp;</a></span>APP_CABLE_VDM_START_DELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_CABLE_VDM_START_DELAY&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cable query delay period in ms. </p>

</div>
</div>
<a id="gac49241b8ddc59d66a473403a3cdeefa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac49241b8ddc59d66a473403a3cdeefa2">&#9670;&nbsp;</a></span>APP_AME_TIMEOUT_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_AME_TIMEOUT_TIMER_PERIOD&#160;&#160;&#160;(800u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tAME timer period (in ms). </p>

</div>
</div>
<a id="ga6e5076cbaeb4b140f90b4cbb5676fda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e5076cbaeb4b140f90b4cbb5676fda6">&#9670;&nbsp;</a></span>APP_DB_SNK_FET_DIS_DELAY_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_DB_SNK_FET_DIS_DELAY_TIMER_PERIOD&#160;&#160;&#160;(50u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dead battery Sink Fet disable delay timer period. </p>

</div>
</div>
<a id="ga739551acfec5c2a24be219159a4aeb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga739551acfec5c2a24be219159a4aeb7b">&#9670;&nbsp;</a></span>APP_BB_ON_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BB_ON_TIMER_PERIOD&#160;&#160;&#160;(250u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Billboard ON delay timer period. </p>
<p>This should be long enough for a host to properly recognize the disconnection and reconnection of the USB Billboard device. </p>

</div>
</div>
<a id="gaa0483129151558270208971691a02404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0483129151558270208971691a02404">&#9670;&nbsp;</a></span>APP_INITIATE_DR_SWAP_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_INITIATE_DR_SWAP_TIMER_PERIOD&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time delay between successive DR_SWAP attempts (in ms). </p>

</div>
</div>
<a id="gaba55f9dd8d47c88610b92a4c1912e6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba55f9dd8d47c88610b92a4c1912e6dc">&#9670;&nbsp;</a></span>APP_INITIATE_PR_SWAP_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_INITIATE_PR_SWAP_TIMER_PERIOD&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time delay between successive PR_SWAP attempts (in ms). </p>
<p>PR_SWAP attempts are kept slow to allow other sequences such as alternate mode negotiation to complete. </p>

</div>
</div>
<a id="gacfbcf0b242232e4ab0fc9d55a030a044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbcf0b242232e4ab0fc9d55a030a044">&#9670;&nbsp;</a></span>APP_INITIATE_SEND_IRQ_CLEAR_ACK_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_INITIATE_SEND_IRQ_CLEAR_ACK_PERIOD&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer period for initiating Virtual HPD IRQ CLEAR ACK. </p>

</div>
</div>
<a id="gaf3c1d0927ce4e392cf0a81e34d3551b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c1d0927ce4e392cf0a81e34d3551b3">&#9670;&nbsp;</a></span>RIDGE_INIT_HPD_DEQUEUE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RIDGE_INIT_HPD_DEQUEUE_TIMER_PERIOD&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer period in ms for initiating virtual HPD dequeue. </p>

</div>
</div>
<a id="ga032924b23e74967dd4c2660dc952ca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032924b23e74967dd4c2660dc952ca57">&#9670;&nbsp;</a></span>UCSI_CONNECT_EVENT_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCSI_CONNECT_EVENT_PERIOD&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay (in ms) between Type-C connection and sending UCSI event notification. </p>

</div>
</div>
<a id="ga07aa785fe5652792c75864247c857f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07aa785fe5652792c75864247c857f23">&#9670;&nbsp;</a></span>APP_BC_CDP_SM_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_CDP_SM_TIMER_PERIOD&#160;&#160;&#160;(30000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CDP state machine timeout period. </p>

</div>
</div>
<a id="ga952b6239190fbe12347840ac65095060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952b6239190fbe12347840ac65095060">&#9670;&nbsp;</a></span>APP_BC_VDP_DM_SRC_ON_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_VDP_DM_SRC_ON_PERIOD&#160;&#160;&#160;(50u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VDP_SRC or VDM_SRC minimum turn on time (the minimum from BC 1.2 spec is 40 ms). </p>

</div>
</div>
<a id="ga802e17b67ddf6c5bc540e6781465386c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802e17b67ddf6c5bc540e6781465386c">&#9670;&nbsp;</a></span>APP_BC_VDMSRC_EN_DIS_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_VDMSRC_EN_DIS_PERIOD&#160;&#160;&#160;(30u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VDM_SRC enable/disable maximum period. </p>

</div>
</div>
<a id="gac8f6cb8dc3b43c84c8da2d3d98478d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8f6cb8dc3b43c84c8da2d3d98478d88">&#9670;&nbsp;</a></span>APP_BC_AFC_SNK_VI_BYTE_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_AFC_SNK_VI_BYTE_PERIOD&#160;&#160;&#160;(80u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AFC SNK period between VI_BYTE sending. </p>

</div>
</div>
<a id="ga2cab124e91cc9acc71c6f7adb9038cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cab124e91cc9acc71c6f7adb9038cf3">&#9670;&nbsp;</a></span>CCG_ACTIVITY_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_ACTIVITY_TIMER_PERIOD&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CCG activity timer period in ms. </p>

</div>
</div>
<a id="ga77d29a70d473dc904258a9b17d6514ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d29a70d473dc904258a9b17d6514ea">&#9670;&nbsp;</a></span>CCG_ACTIVITY_TIMER_PERIOD_SLEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_ACTIVITY_TIMER_PERIOD_SLEEP&#160;&#160;&#160;(1000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CCG activity timer period during sleep in ms. </p>

</div>
</div>
<a id="gaf24fe082de56f01659d0c627f4cd40c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24fe082de56f01659d0c627f4cd40c8">&#9670;&nbsp;</a></span>OTP_DEBOUNCE_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OTP_DEBOUNCE_PERIOD&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OTP debounce timer period in ms. </p>

</div>
</div>
<a id="gab822a1f5024e9e63df33384a051d6723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab822a1f5024e9e63df33384a051d6723">&#9670;&nbsp;</a></span>TYPE_A_CUR_SENSE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TYPE_A_CUR_SENSE_TIMER_PERIOD&#160;&#160;&#160;(30000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TYPE-A current sense timer period. </p>

</div>
</div>
<a id="gae3739e828b77c953e208a78b55f0a04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3739e828b77c953e208a78b55f0a04f">&#9670;&nbsp;</a></span>TYPE_A_REG_SWITCH_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TYPE_A_REG_SWITCH_TIMER_PERIOD&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TYPE-A regulator switch timer period in ms. </p>

</div>
</div>
<a id="ga25de3e7acfb2fcfbbd1cf174a751681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25de3e7acfb2fcfbbd1cf174a751681b">&#9670;&nbsp;</a></span>TYPE_A_PWM_STEP_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TYPE_A_PWM_STEP_TIMER_PERIOD&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TYPE-A port PWM step change time in ms. </p>

</div>
</div>
<a id="gaf434604ddd01da1bc02558a54e62b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf434604ddd01da1bc02558a54e62b1da">&#9670;&nbsp;</a></span>PB_DEBOUNCE_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PB_DEBOUNCE_PERIOD&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PB debounce timer period in ms. </p>

</div>
</div>
<a id="ga93b44e1d2929781e8eb43d55b5dc15a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b44e1d2929781e8eb43d55b5dc15a8">&#9670;&nbsp;</a></span>APP_PB_VBATT_DEBOUNCE_IN_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PB_VBATT_DEBOUNCE_IN_MS&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PB debounce period in ms. </p>

</div>
</div>
<a id="ga30d0eeffd004a72632bc988f5ac8b854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d0eeffd004a72632bc988f5ac8b854">&#9670;&nbsp;</a></span>THROTTLE_DEBOUNCE_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THROTTLE_DEBOUNCE_PERIOD&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THROTTLE time period in ms. </p>

</div>
</div>
<a id="ga3950c3b31b9b63c51169e591f7dbfcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3950c3b31b9b63c51169e591f7dbfcc4">&#9670;&nbsp;</a></span>THROTTLE_WAIT_FOR_PD_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THROTTLE_WAIT_FOR_PD_PERIOD&#160;&#160;&#160;(500)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THROTTLE time period in ms. </p>

</div>
</div>
<a id="gac0b7d908764a2e9b3383d5ed01e1a575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b7d908764a2e9b3383d5ed01e1a575">&#9670;&nbsp;</a></span>APP_BAD_SINK_TIMEOUT_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BAD_SINK_TIMEOUT_TIMER_PERIOD&#160;&#160;&#160;(1000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PD bad sink timeout timer period in ms. </p>

</div>
</div>
<a id="ga481a8ad0214a446fb2b53c8ad7d45ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481a8ad0214a446fb2b53c8ad7d45ee0">&#9670;&nbsp;</a></span>APP_PSOURCE_VBUS_SET_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSOURCE_VBUS_SET_TIMER_PERIOD&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power source VBUS set timer period in ms. </p>

</div>
</div>
<a id="ga2741da6b697d084158e5df64a11226e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2741da6b697d084158e5df64a11226e8">&#9670;&nbsp;</a></span>APP_PSOURCE_SAFE_FET_ON_MONITOR_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PSOURCE_SAFE_FET_ON_MONITOR_TIMER_PERIOD&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power source safe FET monitor timer period in ms. </p>

</div>
</div>
<a id="ga91ed86145c53b6af4e5604355fe69ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ed86145c53b6af4e5604355fe69ffe">&#9670;&nbsp;</a></span>APP_BC_VBUS_CYCLE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_VBUS_CYCLE_TIMER_PERIOD&#160;&#160;&#160;(200u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VBUS OFF time to do a VBUS power cycle. </p>

</div>
</div>
<a id="gaa1309484de31486b864d441874ff27cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1309484de31486b864d441874ff27cc">&#9670;&nbsp;</a></span>APP_BC_SINK_CONTACT_STABLE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_SINK_CONTACT_STABLE_TIMER_PERIOD&#160;&#160;&#160;(50u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sink DCD stable time period. </p>

</div>
</div>
<a id="ga5fcc63cdef84679e47d4bda8c78ce918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fcc63cdef84679e47d4bda8c78ce918">&#9670;&nbsp;</a></span>APP_BC_DCP_DETECT_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_DCP_DETECT_TIMER_PERIOD&#160;&#160;&#160;(1100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tglitch_done time waiting for the portable device to complete detection. </p>
<p>This is used by QC/AFC devices to proceed with subsequent detection. </p>

</div>
</div>
<a id="gabbdc8c28067120799b71088017945a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbdc8c28067120799b71088017945a3c">&#9670;&nbsp;</a></span>APP_BC_APPLE_DETECT_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_APPLE_DETECT_TIMER_PERIOD&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debounce time to verify if the attached device is Apple or not. </p>
<p>Apple devices create a glitch on DP line whereas BC devices continue to drive DP lower. This period is used when Apple and BC 1.2 source protocols are supported together. </p>

</div>
</div>
<a id="ga2dfeb8f9222c7099880e85531a291263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dfeb8f9222c7099880e85531a291263">&#9670;&nbsp;</a></span>APP_BC_DP_DM_DEBOUNCE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_DP_DM_DEBOUNCE_TIMER_PERIOD&#160;&#160;&#160;(40u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debounce time for identifying state change for DP and DM lines. </p>

</div>
</div>
<a id="gae5831ab48406ec2f5b93fee7a198bae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5831ab48406ec2f5b93fee7a198bae6">&#9670;&nbsp;</a></span>APP_BC_AFC_DETECT_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_AFC_DETECT_TIMER_PERIOD&#160;&#160;&#160;(100u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AFC detection time. </p>

</div>
</div>
<a id="gad6b9461a32dea72256e1ee05ff5215e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b9461a32dea72256e1ee05ff5215e7">&#9670;&nbsp;</a></span>APP_BC_GLITCH_BC_DONE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_GLITCH_BC_DONE_TIMER_PERIOD&#160;&#160;&#160;(1500)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TGLITCH_BC_DONE timer period. </p>
<p>This timer is used in sink mode to detect QC charger. </p>

</div>
</div>
<a id="gadb5607ce7ae0d7510f37cb91f6f9be2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb5607ce7ae0d7510f37cb91f6f9be2a">&#9670;&nbsp;</a></span>APP_BC_GLITCH_DM_HIGH_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_GLITCH_DM_HIGH_TIMER_PERIOD&#160;&#160;&#160;(40)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>T_GLITCH_DM_HIGH timer period. </p>
<p>After DCP opens D+/- short, sink shall wait for this time before requesting VBUS. </p>

</div>
</div>
<a id="ga0803a425ecfebb6c53d88873cefc0190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0803a425ecfebb6c53d88873cefc0190">&#9670;&nbsp;</a></span>APP_BC_V_NEW_REQUEST_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_BC_V_NEW_REQUEST_TIMER_PERIOD&#160;&#160;&#160;(200)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>T_V_NEW_REQUEST timer period. </p>
<p>After entering QC mode, sink must wait this much time before requesting next voltage. </p>

</div>
</div>
<a id="ga9c91055c6218bcd4672cca20a3baa7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c91055c6218bcd4672cca20a3baa7a8">&#9670;&nbsp;</a></span>APP_RESET_VDM_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_RESET_VDM_TIMER_PERIOD&#160;&#160;&#160;(2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset VDM layer time period. </p>

</div>
</div>
<a id="gacdbd4d51697948f0f14270b57d56e31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdbd4d51697948f0f14270b57d56e31d">&#9670;&nbsp;</a></span>APP_OT_VBE_LOW_TEMP_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_OT_VBE_LOW_TEMP_ADDR&#160;&#160;&#160;(0x0FFFF427)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low temperature VBJT code sflash address. </p>

</div>
</div>
<a id="ga3ad01527eda77352d7a2e171b106c374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad01527eda77352d7a2e171b106c374">&#9670;&nbsp;</a></span>APP_OT_VBE_HIGH_TEMP_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_OT_VBE_HIGH_TEMP_ADDR&#160;&#160;&#160;(0x0FFFF426)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High temperature VBJT code sflash address. </p>

</div>
</div>
<a id="gadbbcabdfeba09aa754c2b172fd5d6116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbbcabdfeba09aa754c2b172fd5d6116">&#9670;&nbsp;</a></span>APP_OT_VBE_25_C_TEMP_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_OT_VBE_25_C_TEMP_ADDR&#160;&#160;&#160;(0x0FFFF428)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>25C temperature VBJT code sflash address. </p>

</div>
</div>
<a id="gabfd9d464994f7b3443d914d35efe8425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd9d464994f7b3443d914d35efe8425">&#9670;&nbsp;</a></span>APP_VCONN_SWAP_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_VCONN_SWAP_PENDING&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VConn swap pending bit in the app. </p>
<p>level pending swaps flag. </p>

</div>
</div>
<a id="ga0cec0c41df24ed096ba250ca1be687b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cec0c41df24ed096ba250ca1be687b2">&#9670;&nbsp;</a></span>APP_DR_SWAP_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_DR_SWAP_PENDING&#160;&#160;&#160;(2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data Role swap pending bit in the app. </p>
<p>level pending swaps flag. </p>

</div>
</div>
<a id="gae878a7dfb84422d20c3bad027b37a31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae878a7dfb84422d20c3bad027b37a31f">&#9670;&nbsp;</a></span>APP_PR_SWAP_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PR_SWAP_PENDING&#160;&#160;&#160;(4u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power Role swap pending bit in the app. </p>
<p>level pending swaps flag. </p>

</div>
</div>
<a id="gace142939d09e99d20d8fcdd027e953e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace142939d09e99d20d8fcdd027e953e4">&#9670;&nbsp;</a></span>APP_VCONN_RECOVERY_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_VCONN_RECOVERY_PERIOD&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay between VConn fault and recovery attempt. </p>

</div>
</div>
<a id="gac2e4ee6e3ce4dbd59288aa094f5f4a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e4ee6e3ce4dbd59288aa094f5f4a77">&#9670;&nbsp;</a></span>APP_ALT_MODE_POLL_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_ALT_MODE_POLL_PERIOD&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Periodicity of checking if alt mode which is on pause could be run. </p>

</div>
</div>
<a id="ga5a3f1edb8df276dbddb0385a169af773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3f1edb8df276dbddb0385a169af773">&#9670;&nbsp;</a></span>APP_HPD_DEQUE_POLL_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_HPD_DEQUE_POLL_PERIOD&#160;&#160;&#160;(3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Periodicity of checking if paused HPD dequeuing could be run. </p>

</div>
</div>
<a id="ga4b118f6f434f969af4e453f3b2dbe439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b118f6f434f969af4e453f3b2dbe439">&#9670;&nbsp;</a></span>APP_HPI_VPRO_SUPP_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_HPI_VPRO_SUPP_MASK&#160;&#160;&#160;(0x10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to identify is vPro mode supported in HPI host capabilities register. </p>

</div>
</div>
<a id="gae5da197a5ba89711e55b66c4ee524164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5da197a5ba89711e55b66c4ee524164">&#9670;&nbsp;</a></span>APP_ALT_MODE_STAT_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_ALT_MODE_STAT_MASK&#160;&#160;&#160;(0x3Fu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to identify active alternate modes. </p>

</div>
</div>
<a id="gace0fe1c4450a13d4961e29e02b54e445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0fe1c4450a13d4961e29e02b54e445">&#9670;&nbsp;</a></span>APP_USB4_ACTIVE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_USB4_ACTIVE_MASK&#160;&#160;&#160;(0x40u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to identify is USB4 mode entered. </p>

</div>
</div>
<a id="ga18bb4085b98dd8670330e54c3a8d6b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18bb4085b98dd8670330e54c3a8d6b38">&#9670;&nbsp;</a></span>APP_DATA_RESET_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_DATA_RESET_TIMER_PERIOD&#160;&#160;&#160;(205u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tDataReset period used by DFP to delay MUX state updates. </p>

</div>
</div>
<a id="ga1ca75f713628a2f98b4c139cfa4a472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca75f713628a2f98b4c139cfa4a472c">&#9670;&nbsp;</a></span>APP_DATA_RESET_FAIL_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_DATA_RESET_FAIL_TIMEOUT&#160;&#160;&#160;(295u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tDataResetFail timeout period used by the DFP after expiry of tDataReset timer. </p>

</div>
</div>
<a id="ga167af7fb2cd95a22cab0f67525ddb212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167af7fb2cd95a22cab0f67525ddb212">&#9670;&nbsp;</a></span>BC_CMP_0_IDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BC_CMP_0_IDX&#160;&#160;&#160;(0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Battery charger comparator #1. </p>

</div>
</div>
<a id="ga4f87efabf0db12be8187e184829a4545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f87efabf0db12be8187e184829a4545">&#9670;&nbsp;</a></span>BC_CMP_1_IDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BC_CMP_1_IDX&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Battery charger comparator #2. </p>

</div>
</div>
<a id="gaea3657458ae00450c7f70e5fc8155a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea3657458ae00450c7f70e5fc8155a4b">&#9670;&nbsp;</a></span>BC_AMP_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BC_AMP_LIMIT&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum current across various BC modes: 3.0 A. </p>

</div>
</div>
<a id="ga46845bb54e7a35f44014fb12885a5f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46845bb54e7a35f44014fb12885a5f22">&#9670;&nbsp;</a></span>APPLE_AMP_1A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APPLE_AMP_1A&#160;&#160;&#160;(100)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Apple 1.0A brick. </p>

</div>
</div>
<a id="ga3f70e97e177a422a76a1d219fd613fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f70e97e177a422a76a1d219fd613fd7">&#9670;&nbsp;</a></span>APPLE_AMP_2_1A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APPLE_AMP_2_1A&#160;&#160;&#160;(210)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Apple 2.1A brick. </p>

</div>
</div>
<a id="gac24a361f0070e432edf5b883a13b4f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24a361f0070e432edf5b883a13b4f85">&#9670;&nbsp;</a></span>APPLE_AMP_2_4A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APPLE_AMP_2_4A&#160;&#160;&#160;(240)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Apple 2.4A brick. </p>

</div>
</div>
<a id="gab359d0ceede9e3b2d8885c82e7557506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab359d0ceede9e3b2d8885c82e7557506">&#9670;&nbsp;</a></span>APPLE_AMP_3A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APPLE_AMP_3A&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Apple 3.0A brick. </p>

</div>
</div>
<a id="gad5ed46d75073c3e336a26f0221610af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ed46d75073c3e336a26f0221610af8">&#9670;&nbsp;</a></span>QC_AMP_5V</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_AMP_5V&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Quick Charge at 5 V. </p>

</div>
</div>
<a id="gaa7cc8cd2cbef886c34b765e5cc4ca963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7cc8cd2cbef886c34b765e5cc4ca963">&#9670;&nbsp;</a></span>QC_AMP_9V</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_AMP_9V&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Quick Charge at 9 V. </p>

</div>
</div>
<a id="ga1be09768ea825e054fea1e1e512e9e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be09768ea825e054fea1e1e512e9e34">&#9670;&nbsp;</a></span>QC_AMP_12V</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_AMP_12V&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Quick Charge at 12 V. </p>

</div>
</div>
<a id="ga7b570cbe892ecb1b9bd19b3cf5c353cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b570cbe892ecb1b9bd19b3cf5c353cb">&#9670;&nbsp;</a></span>QC_AMP_20V</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_AMP_20V&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Quick Charge at 20 V. </p>

</div>
</div>
<a id="gab602a3aa3cd9cba505b22e953087bba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab602a3aa3cd9cba505b22e953087bba2">&#9670;&nbsp;</a></span>QC_AMP_CONT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_AMP_CONT&#160;&#160;&#160;(300)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current limit for Quick Charge continuous mode. </p>

</div>
</div>
<a id="ga402455722fd5e75286769924c8d30a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402455722fd5e75286769924c8d30a2e">&#9670;&nbsp;</a></span>QC_CONT_VOLT_CHANGE_PER_PULSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC_CONT_VOLT_CHANGE_PER_PULSE&#160;&#160;&#160;(200u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quick Charge continuous mode voltage change per pulse received. </p>

</div>
</div>
<a id="ga9297cf5a3585ae39c2b5e8651589c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9297cf5a3585ae39c2b5e8651589c321">&#9670;&nbsp;</a></span>QC3_MIN_VOLT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QC3_MIN_VOLT&#160;&#160;&#160;(3400u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum supply voltage used in QC charging. </p>

</div>
</div>
<a id="ga33bbd0c7ffe4f8305e24009f036345b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bbd0c7ffe4f8305e24009f036345b2">&#9670;&nbsp;</a></span>GPIO_DM_FIELD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_DM_FIELD_SIZE&#160;&#160;&#160;(3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO drive mode field size. </p>

</div>
</div>
<a id="ga6cb5fee6197441b63d00a3f368cb009e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb5fee6197441b63d00a3f368cb009e">&#9670;&nbsp;</a></span>GPIO_DM_FIELD_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_DM_FIELD_MASK&#160;&#160;&#160;((uint32_t)7u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO drive mode field mask without offset. </p>

</div>
</div>
<a id="ga3dbcad622cbfcc0ed0c8220d4bab44cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dbcad622cbfcc0ed0c8220d4bab44cb">&#9670;&nbsp;</a></span>GPIO_INT_FIELD_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_INT_FIELD_MASK&#160;&#160;&#160;((uint32_t)3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO interrupt configuration field mask. </p>

</div>
</div>
<a id="ga3978a4eeb5db98937242ef759c4a68da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3978a4eeb5db98937242ef759c4a68da">&#9670;&nbsp;</a></span>HSIOM_FIELD_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HSIOM_FIELD_SHIFT&#160;&#160;&#160;(2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HSIOM configuration field size as left shift value. </p>

</div>
</div>
<a id="gae6b028c0e2c77b7e38d60367696a8d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b028c0e2c77b7e38d60367696a8d8e">&#9670;&nbsp;</a></span>GPIO_PORT0_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT0_INTR_NO&#160;&#160;&#160;(0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P0.x pins. </p>

</div>
</div>
<a id="ga117d20f6c81874047d283112454fcbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga117d20f6c81874047d283112454fcbdf">&#9670;&nbsp;</a></span>GPIO_PORT1_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT1_INTR_NO&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P1.x pins. </p>

</div>
</div>
<a id="gae778674e0e5e0ee2f56fd75d000608ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae778674e0e5e0ee2f56fd75d000608ed">&#9670;&nbsp;</a></span>GPIO_PORT2_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT2_INTR_NO&#160;&#160;&#160;(2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P2.x pins. </p>
<p>Only valid if P2.x pins are present. </p>

</div>
</div>
<a id="ga2d547bcf05ff8cc9c49a9f564bd1f2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d547bcf05ff8cc9c49a9f564bd1f2b6">&#9670;&nbsp;</a></span>GPIO_PORT3_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT3_INTR_NO&#160;&#160;&#160;(3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P3.x pins. </p>
<p>Only valid if P3.x pins are present. </p>

</div>
</div>
<a id="ga22a3f154d45ef0f4b2109665d3d17a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a3f154d45ef0f4b2109665d3d17a52">&#9670;&nbsp;</a></span>GPIO_PORT4_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT4_INTR_NO&#160;&#160;&#160;(4u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P4.x pins. </p>
<p>Only valid if P4.x pins are present. </p>

</div>
</div>
<a id="gabcf90602703a9c22b87bcabf22dec6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcf90602703a9c22b87bcabf22dec6e3">&#9670;&nbsp;</a></span>GPIO_PORT5_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT5_INTR_NO&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P5.x pins. </p>
<p>Only valid if P5.x pins are present. </p>

</div>
</div>
<a id="ga477235d634a356497e227232e51c50e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477235d634a356497e227232e51c50e4">&#9670;&nbsp;</a></span>GPIO_PORT6_INTR_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PORT6_INTR_NO&#160;&#160;&#160;(6u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vector number for P6.x pins. </p>
<p>Only valid if P6.x pins are present. </p>

</div>
</div>
<a id="ga25c68b2056bc85a439c873aae5b0aea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25c68b2056bc85a439c873aae5b0aea4">&#9670;&nbsp;</a></span>APP_PPS_SNK_CONTRACT_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PPS_SNK_CONTRACT_PERIOD&#160;&#160;&#160;(9000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period after which a PPS Sink repeats PD contract attempts. </p>
<p>This should be faster than once in 10 seconds. </p>

</div>
</div>
<a id="ga96924b0d3e724956428b4a679b956fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96924b0d3e724956428b4a679b956fea">&#9670;&nbsp;</a></span>APP_PPS_SNK_CONTRACT_RETRY_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_PPS_SNK_CONTRACT_RETRY_PERIOD&#160;&#160;&#160;(5u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period after which a failed PPS sink re-contract attempt will be retried. </p>

</div>
</div>
<a id="gab2954a974990f62ac8ff354585f89c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2954a974990f62ac8ff354585f89c50">&#9670;&nbsp;</a></span>UVDM_RESPONSE_MAX_NO_OF_VDO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_RESPONSE_MAX_NO_OF_VDO&#160;&#160;&#160;(0x07u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of VDOs in U_VDM response. </p>

</div>
</div>
<a id="gad3b05992ad9a5802c9b2f87887e11730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3b05992ad9a5802c9b2f87887e11730">&#9670;&nbsp;</a></span>UVDM_HEADER_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_HEADER_INDEX&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VDM Header index in U_VDM Response. </p>

</div>
</div>
<a id="ga5f345c8631d3864e38ef43e376017500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f345c8631d3864e38ef43e376017500">&#9670;&nbsp;</a></span>UVDM_SIGNATURE_BYTE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SIGNATURE_BYTE_OFFSET&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>U_VDM commands signature byte offset. </p>

</div>
</div>
<a id="gab5c2ca2ef07580bcc2388df9b272d859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c2ca2ef07580bcc2388df9b272d859">&#9670;&nbsp;</a></span>UVDM_DEVICE_MODE_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_DEVICE_MODE_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response U_VDM DEVICE_MODE VDO index. </p>

</div>
</div>
<a id="ga90596a2d4b0963940bea7b40b75d48fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90596a2d4b0963940bea7b40b75d48fd">&#9670;&nbsp;</a></span>UVDM_BOOT_LAST_ROW_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_BOOT_LAST_ROW_VDO_INDEX&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BOOT LAST ROW VDO Index. </p>

</div>
</div>
<a id="gabd6f0b7289a1dfeae40466fa81609cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd6f0b7289a1dfeae40466fa81609cf0">&#9670;&nbsp;</a></span>UVDM_BOOT_VERSION_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_BOOT_VERSION_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response U_VDM BOOT VERSION VDO index. </p>

</div>
</div>
<a id="gaca7f57d458c1b477b4ff79dede370015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7f57d458c1b477b4ff79dede370015">&#9670;&nbsp;</a></span>UVDM_IMG1_VERSION_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_IMG1_VERSION_VDO_INDEX&#160;&#160;&#160;(0x03u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response U_VDM FW Image 1 VERSION VDO index. </p>

</div>
</div>
<a id="ga39f926c2c27a7a33cc5afa04ef43a81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f926c2c27a7a33cc5afa04ef43a81d">&#9670;&nbsp;</a></span>UVDM_IMG2_VERSION_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_IMG2_VERSION_VDO_INDEX&#160;&#160;&#160;(0x05u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response U_VDM FW Image 2 VERSION VDO index. </p>

</div>
</div>
<a id="gab43b2696ff167c8ddc29352f1070f463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab43b2696ff167c8ddc29352f1070f463">&#9670;&nbsp;</a></span>UVDM_VERSION_NUM_SIZE_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_VERSION_NUM_SIZE_BYTES&#160;&#160;&#160;(0x08u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version number size in bytes. </p>

</div>
</div>
<a id="ga8c7c9912fa838757eca10599f716b7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7c9912fa838757eca10599f716b7fd">&#9670;&nbsp;</a></span>UVDM_GET_VERSION_U_VDM_NO_OF_VDO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_VERSION_U_VDM_NO_OF_VDO&#160;&#160;&#160;(0x06u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of VDOs in GET_VERSION U_VDM Response. </p>

</div>
</div>
<a id="ga83e4c0243c7f18f2b5e37270464aff60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e4c0243c7f18f2b5e37270464aff60">&#9670;&nbsp;</a></span>UVDM_GET_SILICON_ID_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_SILICON_ID_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_SILICON_ID Command size in bytes. </p>

</div>
</div>
<a id="ga80b4ba91c5e1986f8c27bd1a2564d3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b4ba91c5e1986f8c27bd1a2564d3d0">&#9670;&nbsp;</a></span>UVDM_FW1_START_ADDR_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FW1_START_ADDR_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response UVDM_FW1_START_ADDR VDO index. </p>

</div>
</div>
<a id="gabe2538b360e06eb5c365691588fbc2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe2538b360e06eb5c365691588fbc2d6">&#9670;&nbsp;</a></span>UVDM_FW2_START_ADDR_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FW2_START_ADDR_VDO_INDEX&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response UVDM_FW2_START_ADDR VDO index. </p>

</div>
</div>
<a id="ga57792eef4b15e00e098fcf406b974f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57792eef4b15e00e098fcf406b974f36">&#9670;&nbsp;</a></span>UVDM_GET_FW_START_ADDR_UVDM_NO_OF_VDO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_FW_START_ADDR_UVDM_NO_OF_VDO&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of VDOs in GET_FW_START_ADDRESS_UVDM response. </p>

</div>
</div>
<a id="gab0867f1eab1166708b321a85939d780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0867f1eab1166708b321a85939d780a">&#9670;&nbsp;</a></span>UVDM_SILICON_ID_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SILICON_ID_VDO_INDEX&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SILICON_ID VDO index in U_VDM response. </p>

</div>
</div>
<a id="gaa34e8997d907c8bd48f870d8b4d0e4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34e8997d907c8bd48f870d8b4d0e4a8">&#9670;&nbsp;</a></span>UVDM_DEVICE_RESET_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_DEVICE_RESET_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEVICE_RESET Command size in bytes. </p>

</div>
</div>
<a id="gaa890eca2eaf632155b801b141d87e242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa890eca2eaf632155b801b141d87e242">&#9670;&nbsp;</a></span>UVDM_JUMP_TO_BOOT_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_JUMP_TO_BOOT_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JUMP_TO_BOOT Command size in bytes. </p>

</div>
</div>
<a id="gaa3a5be1bb44697ec8de515c4051e56e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a5be1bb44697ec8de515c4051e56e0">&#9670;&nbsp;</a></span>UVDM_ENTER_FLASHING_MODE_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_ENTER_FLASHING_MODE_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ENTER_FLASHING_MODE Command size in bytes. </p>

</div>
</div>
<a id="gab43690cb24e3f8a2517756425b148c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab43690cb24e3f8a2517756425b148c8b">&#9670;&nbsp;</a></span>UVDM_FLASH_READ_WRITE_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FLASH_READ_WRITE_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash write and read command size. </p>

</div>
</div>
<a id="ga875522284456917153b40096d0a6d658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga875522284456917153b40096d0a6d658">&#9670;&nbsp;</a></span>UVDM_FLASH_ROW_NUM_LSB_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FLASH_ROW_NUM_LSB_OFFSET&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Write and Read command row num LSB offset. </p>

</div>
</div>
<a id="ga3169e34f384e1e2ba4d72c4ec655d817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3169e34f384e1e2ba4d72c4ec655d817">&#9670;&nbsp;</a></span>UVDM_FLASH_ROW_NUM_MSB_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FLASH_ROW_NUM_MSB_OFFSET&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Write and Read command row num MSB offset. </p>

</div>
</div>
<a id="ga677fbbc4ae6b40e81a9012ccecb7c8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677fbbc4ae6b40e81a9012ccecb7c8c8">&#9670;&nbsp;</a></span>UVDM_READ_DATA_RESPONSE_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_READ_DATA_RESPONSE_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>READ_DATA Response VDO index. </p>

</div>
</div>
<a id="gaf63ba216a1decad34a39f3d6e9dc4261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf63ba216a1decad34a39f3d6e9dc4261">&#9670;&nbsp;</a></span>UVDM_RESPONSE_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_RESPONSE_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>U_VDM Response VDO index. </p>

</div>
</div>
<a id="gaec5616636103518742a7f4301711aa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5616636103518742a7f4301711aa26">&#9670;&nbsp;</a></span>UVDM_READ_DATA_NO_OF_VDO_ERROR_CASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_READ_DATA_NO_OF_VDO_ERROR_CASE&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>READ_DATA response no of VDOs in error case. </p>

</div>
</div>
<a id="gadcecbc396e48b4e434148ccbf8d0ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcecbc396e48b4e434148ccbf8d0ae55">&#9670;&nbsp;</a></span>UVDM_VALIDATE_FW_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_VALIDATE_FW_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VALIDATE_FW command size. </p>

</div>
</div>
<a id="gac168c8f26511e6900e643a7d6a8cee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac168c8f26511e6900e643a7d6a8cee20">&#9670;&nbsp;</a></span>UVDM_VALIDATE_FW_MODE_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_VALIDATE_FW_MODE_INDEX&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VALIDATE_FW Register FW MODE offset. </p>

</div>
</div>
<a id="gad3abb3c5f66cdd2a05367f2e8ab902bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3abb3c5f66cdd2a05367f2e8ab902bc">&#9670;&nbsp;</a></span>UVDM_REASON_FOR_BOOT_MODE_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_REASON_FOR_BOOT_MODE_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>REASON_FOR_BOOT_MODE VDO index. </p>

</div>
</div>
<a id="ga994d17a568700bed304773a08ec5b931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994d17a568700bed304773a08ec5b931">&#9670;&nbsp;</a></span>UVDM_GET_CHECKSUM_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_CHECKSUM_CMD_SIZE&#160;&#160;&#160;(0x08u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CHECKSUM command size. </p>

</div>
</div>
<a id="ga6ea5056961cdabc3683e735e7fe9fc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea5056961cdabc3683e735e7fe9fc5d">&#9670;&nbsp;</a></span>UVDM_FLASH_ADDR_LSB_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FLASH_ADDR_LSB_OFFSET&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CHECKSUM CMD FLASH ADDR LSB offset. </p>

</div>
</div>
<a id="ga91b6c19ca2fe56f68f970fc466c3fcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b6c19ca2fe56f68f970fc466c3fcfb">&#9670;&nbsp;</a></span>UVDM_FLASH_SIZE_LSB_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_FLASH_SIZE_LSB_OFFSET&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CHECKSUM CMD FLASH SIZE LSB offset. </p>

</div>
</div>
<a id="gad5f3e075f0704d8a696317c34f418faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f3e075f0704d8a696317c34f418faa">&#9670;&nbsp;</a></span>UVDM_CHECKSUM_VDO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_CHECKSUM_VDO_INDEX&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CHECKSUM response checksum VDO index. </p>

</div>
</div>
<a id="gac55891d85525f6df77dff2ff1fc2d734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55891d85525f6df77dff2ff1fc2d734">&#9670;&nbsp;</a></span>UVDM_SET_APP_PRIORITY_CMD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SET_APP_PRIORITY_CMD_SIZE&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SET_APP_PRIORITY command size. </p>

</div>
</div>
<a id="ga648b3420c1f04d165bcfbd70c02b9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648b3420c1f04d165bcfbd70c02b9f14">&#9670;&nbsp;</a></span>UVDM_SET_APP_PRIORITY_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SET_APP_PRIORITY_INDEX&#160;&#160;&#160;(0x00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SET_APP_PRIORITY FW Image priority offset. </p>

</div>
</div>
<a id="ga18d189dd40acbd5de1d0589fa7f8886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18d189dd40acbd5de1d0589fa7f8886f">&#9670;&nbsp;</a></span>UVDM_SEND_SIGN_SEQUENCE_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SEND_SIGN_SEQUENCE_1&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Signature UVDM Valid Sequence Number 1. </p>

</div>
</div>
<a id="gadbd66e1c3838ac98c2c8e76b2a9e4af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd66e1c3838ac98c2c8e76b2a9e4af7">&#9670;&nbsp;</a></span>UVDM_SEND_SIGN_SEQUENCE_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SEND_SIGN_SEQUENCE_2&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Signature UVDM Valid Sequence Number 2. </p>

</div>
</div>
<a id="gaf8c2d59daf349cdb793a6b15fa866e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8c2d59daf349cdb793a6b15fa866e6a">&#9670;&nbsp;</a></span>UVDM_SEND_SIGN_SEQUENCE_3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SEND_SIGN_SEQUENCE_3&#160;&#160;&#160;(0x03u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Signature UVDM Valid Sequence Number 3. </p>

</div>
</div>
<a id="gaa9b78b919d93184342809c6b492466dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b78b919d93184342809c6b492466dd">&#9670;&nbsp;</a></span>UVDM_SEND_SIGN_SEC_1_2_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SEND_SIGN_SEC_1_2_SIZE&#160;&#160;&#160;(0x18u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Signature UVDM Section 1 and 2 size in Bytes. </p>

</div>
</div>
<a id="ga5d6dcce53e0e3235a30a7b539d76635d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d6dcce53e0e3235a30a7b539d76635d">&#9670;&nbsp;</a></span>UVDM_SEND_SIGN_SEC_3_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_SEND_SIGN_SEC_3_SIZE&#160;&#160;&#160;(0x10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send Signature UVDM Section 3 size in Bytes. </p>

</div>
</div>
<a id="ga8ee3be55ab5d1b13a969d54595bb5584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ee3be55ab5d1b13a969d54595bb5584">&#9670;&nbsp;</a></span>UVDM_GET_CUSTOMER_INFO_SEQ_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_CUSTOMER_INFO_SEQ_1&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CUSTOMER_INFO VDM Sequence Number 1. </p>

</div>
</div>
<a id="ga65da41b1a3a90a4a403e86340e5bc005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65da41b1a3a90a4a403e86340e5bc005">&#9670;&nbsp;</a></span>UVDM_GET_CUSTOMER_INFO_SEQ_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_CUSTOMER_INFO_SEQ_2&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CUSTOMER_INFO VDM Sequence Number 2. </p>

</div>
</div>
<a id="gaff2cfa777dabb301ea53159d3dca70e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2cfa777dabb301ea53159d3dca70e2">&#9670;&nbsp;</a></span>UVDM_GET_CUSTOMER_INFO_RESPONSE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_CUSTOMER_INFO_RESPONSE_SIZE&#160;&#160;&#160;(0x10u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CUSTOMER_INFO Response Size in bytes. </p>

</div>
</div>
<a id="ga87505ea1aa920293446fa208eb2115d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87505ea1aa920293446fa208eb2115d6">&#9670;&nbsp;</a></span>UVDM_GET_CUSTOMER_INFO_RESPONSE_VDO_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UVDM_GET_CUSTOMER_INFO_RESPONSE_VDO_NUM&#160;&#160;&#160;(0x04u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GET_CUSTOMER_INFO number of VDOs in response. </p>

</div>
</div>
<a id="gade1bdc60e21d634fe2d4f5a748ab5486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1bdc60e21d634fe2d4f5a748ab5486">&#9670;&nbsp;</a></span>CCG_STATUS_TO_HPI_RESPONSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_STATUS_TO_HPI_RESPONSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;((c) + <a class="el" href="group__group__ccgxAppCommon.html#ga00fa9d10bf3bb3bc2b36904ae613bdc0">CCG_STATUS_CODE_OFFSET</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert CCG status code to HPI/UVDM response code. </p>

</div>
</div>
<a id="gaee1a6c53c66a4c6633597cc1e5f2a8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1a6c53c66a4c6633597cc1e5f2a8a7">&#9670;&nbsp;</a></span>CY_PD_IMG1_FW_STATUS_BIT_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CY_PD_IMG1_FW_STATUS_BIT_MASK&#160;&#160;&#160;(0x08)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for Image-1 FW status bit in Boot mode reason byte. </p>

</div>
</div>
<a id="ga4629436a6d068d87f0e28cb37aafd83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4629436a6d068d87f0e28cb37aafd83d">&#9670;&nbsp;</a></span>CCG_BOOT_MODE_RQT_SIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_BOOT_MODE_RQT_SIG&#160;&#160;&#160;(0x424Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature used for firmware to indicate boot mode request. </p>

</div>
</div>
<a id="ga46812a8cbac3d4dd71c4dc228572fb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46812a8cbac3d4dd71c4dc228572fb83">&#9670;&nbsp;</a></span>CCG_FW1_BOOT_RQT_SIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_FW1_BOOT_RQT_SIG&#160;&#160;&#160;(0x4231u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature used to indicate boot FW1 request. </p>

</div>
</div>
<a id="gaa2148e79850430d38916c2c984a9dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2148e79850430d38916c2c984a9dc64">&#9670;&nbsp;</a></span>CCG_FW2_BOOT_RQT_SIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_FW2_BOOT_RQT_SIG&#160;&#160;&#160;(0x4232u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature used to indicate boot FW2 request. </p>

</div>
</div>
<a id="gae2518cdc374b4223d58ebe712d8b0c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2518cdc374b4223d58ebe712d8b0c8d">&#9670;&nbsp;</a></span>CCG_FW_METADATA_BOOTSEQ_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_FW_METADATA_BOOTSEQ_OFFSET&#160;&#160;&#160;(0x1Cu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Firmware boot sequence number offset. </p>

</div>
</div>
<a id="ga2d83312efd628a2ae20735621eb2df0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d83312efd628a2ae20735621eb2df0d">&#9670;&nbsp;</a></span>CCG_FWMETA_APPID_WAIT_DEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_FWMETA_APPID_WAIT_DEF&#160;&#160;&#160;(0xFFFFu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FW metadata application ID value requesting default boot-wait window. </p>

</div>
</div>
<a id="gab112db7a8197e81a852641526d3f41d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab112db7a8197e81a852641526d3f41d6">&#9670;&nbsp;</a></span>CCG_FWMETA_APPID_WAIT_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCG_FWMETA_APPID_WAIT_0&#160;&#160;&#160;(0x4946u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FW metadata application ID value requesting a zero boot-wait window. </p>

</div>
</div>
<a id="ga31eb9aa72aa9164ccd72df617fbc81be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31eb9aa72aa9164ccd72df617fbc81be">&#9670;&nbsp;</a></span>CONFIGTABLE_SIZE_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIGTABLE_SIZE_OFFSET&#160;&#160;&#160;(6u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset to table size field in config table. </p>

</div>
</div>
<a id="ga6ec1266abf1be1cf53fa4c02a55ac2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec1266abf1be1cf53fa4c02a55ac2ea">&#9670;&nbsp;</a></span>CONFIGTABLE_CHECKSUM_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIGTABLE_CHECKSUM_OFFSET&#160;&#160;&#160;(8u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset to checksum field in config table. </p>

</div>
</div>
<a id="gaff74513994e58a5f54bacdde7839e515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff74513994e58a5f54bacdde7839e515">&#9670;&nbsp;</a></span>CONFIGTABLE_CHECKSUM_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIGTABLE_CHECKSUM_START&#160;&#160;&#160;(12u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset at which table checksum calculation starts. </p>

</div>
</div>
<a id="gac79f9e16114680b19eae3f38a6832fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79f9e16114680b19eae3f38a6832fde">&#9670;&nbsp;</a></span>SROM_API_PARAM_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SROM_API_PARAM_SIZE&#160;&#160;&#160;(8u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of flash write SROM API parameters in bytes. </p>

</div>
</div>
<a id="gad04efbaf3c874bd6f8c53bd351f1ace1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04efbaf3c874bd6f8c53bd351f1ace1">&#9670;&nbsp;</a></span>FLASH_INVALID_ROW_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_INVALID_ROW_NUMBER&#160;&#160;&#160;(0xFFFFu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid row numer is used to check against the read row number given to validate it. </p>

</div>
</div>
<a id="ga829e5d246f885d98ad982a48274a3a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829e5d246f885d98ad982a48274a3a33">&#9670;&nbsp;</a></span>CALL_MAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CALL_MAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str</td><td>)</td>
          <td>&#160;&#160;&#160;(str)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ROM/Flash function and variable access macro redirection. </p>
<p>Macro mapping section in each srom_vars_&lt;device&gt;.h file need to be updated when there is any change in ROM code base. Macro mapping sections must include all the CALL_MAP functions of the code base. Each call mapping function can be mapped to either direct function or variable call or through call_in/call_out function or get_in variable as per the ROM code definition of the device. </p>

</div>
</div>
<a id="ga52a56dcdff67c86033f0c01b8348ceef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a56dcdff67c86033f0c01b8348ceef">&#9670;&nbsp;</a></span>SYS_BOOT_VERSION_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_VERSION_ADDRESS&#160;&#160;&#160;(0x000000E0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boot loader version address in FLASH. </p>

</div>
</div>
<a id="ga8fb7d76d557aac1feaeffab0238c1a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb7d76d557aac1feaeffab0238c1a2c">&#9670;&nbsp;</a></span>SYS_FW_VERSION_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_FW_VERSION_OFFSET&#160;&#160;&#160;(0x000000E0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of FW version from start of FW image in flash. </p>

</div>
</div>
<a id="ga2053ccc9a3f265802af4480f97351f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053ccc9a3f265802af4480f97351f69">&#9670;&nbsp;</a></span>SYS_APP_VERSION_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_APP_VERSION_OFFSET&#160;&#160;&#160;(0x00000004u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of App version from start of firmware version. </p>

</div>
</div>
<a id="gac9db8ce72753c10e59e1317724d29bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9db8ce72753c10e59e1317724d29bd6">&#9670;&nbsp;</a></span>SYS_SILICON_ID_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_SILICON_ID_OFFSET&#160;&#160;&#160;(0x000000EAu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of Silicon ID stored in FW image in flash. </p>

</div>
</div>
<a id="gae1c7eb50fd605e56c5d8aeb962311999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c7eb50fd605e56c5d8aeb962311999">&#9670;&nbsp;</a></span>SYS_BOOT_TYPE_FIELD_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_TYPE_FIELD_OFFSET&#160;&#160;&#160;(0x000000ECu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of Bootloader type in Bootloader flash region. </p>

</div>
</div>
<a id="ga558779f9eb98a2b13d4a78c8b82019cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga558779f9eb98a2b13d4a78c8b82019cb">&#9670;&nbsp;</a></span>SYS_FW_CUSTOM_INFO_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_FW_CUSTOM_INFO_OFFSET&#160;&#160;&#160;(0x000000C0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Offset of Customer Specific Info from FW start. </p>

</div>
</div>
<a id="ga2c60fd38d0cf4391ea6185073aa4a90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c60fd38d0cf4391ea6185073aa4a90e">&#9670;&nbsp;</a></span>SYS_INVALID_FW_START_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_INVALID_FW_START_ADDR&#160;&#160;&#160;(0x00000000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid FW Start Address. </p>

</div>
</div>
<a id="gaacf755f850acb81fe1c79b2862c8f11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf755f850acb81fe1c79b2862c8f11c">&#9670;&nbsp;</a></span>SYS_BOOT_TYPE_SECURE_BOOT_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_TYPE_SECURE_BOOT_MASK&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get Secure Boot feature bit in BL type. </p>

</div>
</div>
<a id="ga318342e3edd398cec8a3d2faf13a7d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318342e3edd398cec8a3d2faf13a7d42">&#9670;&nbsp;</a></span>SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_POS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_POS&#160;&#160;&#160;(0x01u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of FW update interface bit in BL type. </p>

</div>
</div>
<a id="ga5b580e0f52dd71dc8653db16c9b66b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b580e0f52dd71dc8653db16c9b66b8e">&#9670;&nbsp;</a></span>SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_TYPE_FW_UPDATE_INTERFACE_MASK&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to get FW update interface bit in BL type. </p>

</div>
</div>
<a id="gac4c6da4c670474b3f3546572ea241fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c6da4c670474b3f3546572ea241fba">&#9670;&nbsp;</a></span>SYS_BOOT_TYPE_APP_PRIORITY_POS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_BOOT_TYPE_APP_PRIORITY_POS&#160;&#160;&#160;(0x02u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position of app priority bit in Bootloader type. </p>

</div>
</div>
<a id="gad24fc2b8e4c341d7abdcefc315bf4a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad24fc2b8e4c341d7abdcefc315bf4a1d">&#9670;&nbsp;</a></span>SYS_SILICON_ID_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYS_SILICON_ID_MASK&#160;&#160;&#160;(0xFF00u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask to extract the device ID from Silicon ID. </p>

</div>
</div>
<a id="gac455ffb620f153f74c1d077a3a50cbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac455ffb620f153f74c1d077a3a50cbb5">&#9670;&nbsp;</a></span>I2C_BLOCK_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_BLOCK_COUNT&#160;&#160;&#160;(4u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of I2C blocks supported by the device. </p>
<p>The CCG3 and CCG4 device families support 4 SCB blocks which can be used for I2C functionality. CCG3PA, CCG3PA2 supports two SCB blocks. If the target device using this stack supports a different number of SCBs, this macro value will need to be updated. </p>

</div>
</div>
<a id="ga6754f4029a711074afd8b63960b795bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6754f4029a711074afd8b63960b795bc">&#9670;&nbsp;</a></span>I2C_CLEAR_INTR_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLEAR_INTR_MASK&#160;&#160;&#160;(0x00000000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to clear Interrupt mask bits. </p>

</div>
</div>
<a id="gaedba4e22294441cbd1727dc45ab20a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedba4e22294441cbd1727dc45ab20a51">&#9670;&nbsp;</a></span>I2C_CLEAR_INTR_REQUEST_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLEAR_INTR_REQUEST_REG&#160;&#160;&#160;(0xFFFFFFFFu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to clear Interrupt request bits. </p>

</div>
</div>
<a id="ga02a38c7ab96be675f851393a68aea1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02a38c7ab96be675f851393a68aea1e0">&#9670;&nbsp;</a></span>I2C_SCB_FIFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCB_FIFO_SIZE&#160;&#160;&#160;(8u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of FIFO in the SCB block for I2C transfers. </p>

</div>
</div>
<a id="gac68bc5185f3c65ebbc2dce1d7c750bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac68bc5185f3c65ebbc2dce1d7c750bea">&#9670;&nbsp;</a></span>I2C_SCB_RX_FIFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCB_RX_FIFO_SIZE&#160;&#160;&#160;(<a class="el" href="group__group__ccgxAppCommon.html#ga02a38c7ab96be675f851393a68aea1e0">I2C_SCB_FIFO_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of FIFO provided by the SCB block for I2C read (incoming data) transfers. </p>

</div>
</div>
<a id="ga1363753bae06613ab2be5bdb52ba7bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1363753bae06613ab2be5bdb52ba7bba">&#9670;&nbsp;</a></span>I2C_SCB_TX_FIFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SCB_TX_FIFO_SIZE&#160;&#160;&#160;(<a class="el" href="group__group__ccgxAppCommon.html#ga02a38c7ab96be675f851393a68aea1e0">I2C_SCB_FIFO_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of FIFO provided by the SCB block for I2C write (outgoing data) transfers. </p>

</div>
</div>
<a id="ga8024fe32ce8273fce98e4f8c16455288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8024fe32ce8273fce98e4f8c16455288">&#9670;&nbsp;</a></span>I2C_SLAVE_ADDR_MASK_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_ADDR_MASK_DEFAULT&#160;&#160;&#160;(0xFEu)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Slave address mask to be applied on received preamble. </p>

</div>
</div>
<a id="gab7cd8596f98f94d90c2ec74c003f5a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7cd8596f98f94d90c2ec74c003f5a45">&#9670;&nbsp;</a></span>I2C_SLAVE_TIMER_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_TIMER_BASE&#160;&#160;&#160;(111)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base ID of timers reserved for I2C transfer timeout implementation. </p>

</div>
</div>
<a id="ga88834404a8fdafcbbfbb1f0266897165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88834404a8fdafcbbfbb1f0266897165">&#9670;&nbsp;</a></span>I2C_SLAVE_TIMER_PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVE_TIMER_PERIOD&#160;&#160;&#160;(500u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout period for I2C transfers in milliseconds. </p>
<p>The I2C block will be reset if any transaction does not complete within this time period. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga05e5e6e022e2fb8b6a30b303f9a0d2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">&#9670;&nbsp;</a></span>gpio_intr_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* gpio_intr_cb_t) (<a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, bool pin_state)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback type for GPIO interrupt notification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Parameter identifying the GPIO port and pin. </td></tr>
    <tr><td class="paramname">pin_state</td><td>State of the GPIO when at the beginning of ISR. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1091be6e2b432c69d3d21af326fa2243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1091be6e2b432c69d3d21af326fa2243">&#9670;&nbsp;</a></span>app_port_fault_status_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga1091be6e2b432c69d3d21af326fa2243">app_port_fault_status_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fault detection and handling related status bits tracked in the fault_status field. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243ae6e9ae0dff1b80979b9d82c25ca78e80"></a>APP_PORT_FAULT_NONE&#160;</td><td class="fielddoc"><p>System functioning without any fault. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a14f805c5f221be2f3523752ccd3cb99f"></a>APP_PORT_VCONN_FAULT_ACTIVE&#160;</td><td class="fielddoc"><p>Status bit that indicates VConn fault is active. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a746978b97a8c945dac70f8d323fa3391"></a>APP_PORT_SINK_FAULT_ACTIVE&#160;</td><td class="fielddoc"><p>Status bit that indicates sink fault handling is pending. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a9b9d2e82cf54849646723777d17d65a4"></a>APP_PORT_SRC_FAULT_ACTIVE&#160;</td><td class="fielddoc"><p>Status bit that indicates source fault handling is pending. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a1be76ddd79458e2d827f64bb8850a182"></a>APP_PORT_VBUS_DROP_WAIT_ACTIVE&#160;</td><td class="fielddoc"><p>Status bit that indicates wait for VBus drop is pending. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a02b6ba427b9bed14bda05f4af2bfe77c"></a>APP_PORT_V5V_SUPPLY_LOST&#160;</td><td class="fielddoc"><p>Status bit that indicates that V5V supply (for VConn) has been lost. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1091be6e2b432c69d3d21af326fa2243a5a496d7a46fb7c0dfccd37845e4faab3"></a>APP_PORT_DISABLE_IN_PROGRESS&#160;</td><td class="fielddoc"><p>Port disable operation is in progress. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaa2137d1a6e9ce52725c9677ce5a5b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2137d1a6e9ce52725c9677ce5a5b8ce">&#9670;&nbsp;</a></span>app_nb_sys_pwr_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gaa2137d1a6e9ce52725c9677ce5a5b8ce">app_nb_sys_pwr_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of system power states for Notebook/Desktop designs. </p>
<p>These states will be reported by the EC to CCG device through HPI registers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8ceaaf3d873168899417c392960172abf412"></a>NB_SYS_PWR_STATE_S0&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in active (S0) state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8ceaa1c1f259360b15c397915ec4fdd72adc"></a>NB_SYS_PWR_STATE_S3&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in Sleep (S3) state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8cea0b0296dbf5da772b85b7155c5a6016cc"></a>NB_SYS_PWR_STATE_S4&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in Hibernate (S4) state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8ceaae6d812fd459e73f898126a9ebccce3b"></a>NB_SYS_PWR_STATE_S5&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in Off (S5) state. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8cea8aea5281edfb1de8ed31bdff5cf877ae"></a>NB_SYS_PWR_STATE_MOD_STBY&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in Modern Standby State. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2137d1a6e9ce52725c9677ce5a5b8cea486495f7a6aa41e5fa82eb6236aef202"></a>NB_SYS_PWR_STATE_G3&#160;</td><td class="fielddoc"><p>Notebook/Desktop is in G3 State. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga28ca7d6bdea64e62f33e874641a230a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28ca7d6bdea64e62f33e874641a230a0">&#9670;&nbsp;</a></span>mux_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga28ca7d6bdea64e62f33e874641a230a0">mux_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>@ typedef mux_status_t @ brief Possible states for the MUX handler. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga28ca7d6bdea64e62f33e874641a230a0a188e72a84ccbdd0868fd135b6764049a"></a>MUX_STATE_IDLE&#160;</td><td class="fielddoc"><p>MUX idle state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28ca7d6bdea64e62f33e874641a230a0a037e061efc69e608af6613c741cd3354"></a>MUX_STATE_FAIL&#160;</td><td class="fielddoc"><p>MUX switch failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28ca7d6bdea64e62f33e874641a230a0a0222514ec6646d85b0a803cc82b8428f"></a>MUX_STATE_BUSY&#160;</td><td class="fielddoc"><p>MUX is busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28ca7d6bdea64e62f33e874641a230a0a5211ab41c8cdf35c0347fb675241952d"></a>MUX_STATE_SUCCESS&#160;</td><td class="fielddoc"><p>MUX switched successfully. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1bc325232edd54ae8343508768c79fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc325232edd54ae8343508768c79fef">&#9670;&nbsp;</a></span>sys_hw_error_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga1bc325232edd54ae8343508768c79fef">sys_hw_error_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible hardware errors defined for the system. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1bc325232edd54ae8343508768c79fefae54f28326798ea119fc858fbf0fb1701"></a>SYS_HW_ERROR_NONE&#160;</td><td class="fielddoc"><p>No error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1bc325232edd54ae8343508768c79fefa035c02d4e80976f054b4cc070a06d24b"></a>SYS_HW_ERROR_MUX_ACCESS&#160;</td><td class="fielddoc"><p>Error while accessing data MUX. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1bc325232edd54ae8343508768c79fefae54db6b5ffeabe75a5c7619bad60d774"></a>SYS_HW_ERROR_REG_ACCESS&#160;</td><td class="fielddoc"><p>Error while accessing regulator. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1bc325232edd54ae8343508768c79fefabbe38f41e36873d8e7d66c15acf05621"></a>SYS_HW_ERROR_BAD_VOLTAGE&#160;</td><td class="fielddoc"><p>Unexpected voltage generated by source regulator. </p>
</td></tr>
</table>

</div>
</div>
<a id="gabbca13754d3851031d9d2b4cb920a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbca13754d3851031d9d2b4cb920a6bb">&#9670;&nbsp;</a></span>app_thermistor_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gabbca13754d3851031d9d2b4cb920a6bb">app_thermistor_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible Thermistor types that can be configured. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabbca13754d3851031d9d2b4cb920a6bba556a98a3acd608e8696bda4de549c674"></a>APP_THERMISTOR_TYPE_NTC&#160;</td><td class="fielddoc"><p>NTC Thermistor type configured. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbca13754d3851031d9d2b4cb920a6bbabc2b791844205c626beda8f66bcccc3a"></a>APP_THERMISTOR_TYPE_PTC&#160;</td><td class="fielddoc"><p>PTC Thermistor type configured. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbca13754d3851031d9d2b4cb920a6bba198a89a0a851603ed0c3590268527327"></a>APP_THERMISTOR_TYPE_INTRNL&#160;</td><td class="fielddoc"><p>CCGx internal VBJT based temperature sensing. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabbca13754d3851031d9d2b4cb920a6bba2ef1b03d49da4397dac32989af4b58a6"></a>APP_THERMISTOR_TYPE_ERROR&#160;</td><td class="fielddoc"><p>Invalid Thermistor type configured. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8b1a30fd54c54d07259ea52e0c3ea200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1a30fd54c54d07259ea52e0c3ea200">&#9670;&nbsp;</a></span>mux_select_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga8b1a30fd54c54d07259ea52e0c3ea200">mux_select_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>@ typedef mux_select_t @ brief Possible settings for the Type-C Data MUX. </p>
<p>@ note This type should be extended to cover all possible modes for the MUX. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200acccf11b679f0f2696e77a4b1a6ffd70a"></a>MUX_CONFIG_ISOLATE&#160;</td><td class="fielddoc"><p>Isolate configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a8846b26e0fd62aa8068da135457180c1"></a>MUX_CONFIG_SAFE&#160;</td><td class="fielddoc"><p>USB Safe State (USB 2.0 lines remain active) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a8ed5f7d8bc79520a986d38ec4a8a65dd"></a>MUX_CONFIG_SS_ONLY&#160;</td><td class="fielddoc"><p>USB SS configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a3501b1c9fa8f965cb0329cf07d865a54"></a>MUX_CONFIG_USB4_CUSTOM&#160;</td><td class="fielddoc"><p>USB4 custom configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a4d9129047052be4c57fbe65bed006a6f"></a>MUX_CONFIG_RIDGE_CUSTOM&#160;</td><td class="fielddoc"><p>Alpine/Titan Ridge custom configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a5c4e0f7fc012c1dec422421f50079868"></a>MUX_CONFIG_INIT&#160;</td><td class="fielddoc"><p>Enables MUX functionality. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8b1a30fd54c54d07259ea52e0c3ea200a137f7fb9b6c14ef0b7be5d42daf3aad0"></a>MUX_CONFIG_DEINIT&#160;</td><td class="fielddoc"><p>Disables MUX functionality. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7a9af8ba98e8e424f8442e293f854f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a9af8ba98e8e424f8442e293f854f0f">&#9670;&nbsp;</a></span>ccg_supply_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga7a9af8ba98e8e424f8442e293f854f0f">ccg_supply_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of power supplies input to and monitored by the CCG5x and CCG6x devices. </p>
<p>This does not include the VBus supply which is monitored by all CCG devices as required by the Type-C and USB-PD specifications. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7a9af8ba98e8e424f8442e293f854f0faa4bc81152f4149de1af2c76aaef6f6cf"></a>CCG_SUPPLY_VSYS&#160;</td><td class="fielddoc"><p>Vsys supply input which powers the device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7a9af8ba98e8e424f8442e293f854f0fae5d6b6fec2d8a0c99fd941a27605ff67"></a>CCG_SUPPLY_V5V&#160;</td><td class="fielddoc"><p>V5V input used to derive the VConn supply from. </p>
<p>Can be port-specific. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7903ba44bd8d1e319f7590e7d592b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7903ba44bd8d1e319f7590e7d592b1a9">&#9670;&nbsp;</a></span>bc_port_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga7903ba44bd8d1e319f7590e7d592b1a9">bc_port_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Battery charging port types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7903ba44bd8d1e319f7590e7d592b1a9a8ca54cb6d1dcd07b65ef6386e28c6cc2"></a>BC_PORT_TYPE_A&#160;</td><td class="fielddoc"><p>Type-A port. </p>
<p>Only supported in power adapter and power bank designs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7903ba44bd8d1e319f7590e7d592b1a9abe48ce7fe64c80dac86f9e039c1e6c86"></a>BC_PORT_TYPE_C&#160;</td><td class="fielddoc"><p>Type-C port. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga013e4bb33c056c7899d9ba01f9e8ca5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013e4bb33c056c7899d9ba01f9e8ca5a">&#9670;&nbsp;</a></span>bc_port_role_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Battery charging port role. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga013e4bb33c056c7899d9ba01f9e8ca5aa15a773c5b99672d3608036e724e6c8e5"></a>BC_PORT_SINK&#160;</td><td class="fielddoc"><p>Power sink, device being charged. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga013e4bb33c056c7899d9ba01f9e8ca5aa76230ea610cf4862b7820acb42f1fa27"></a>BC_PORT_SOURCE&#160;</td><td class="fielddoc"><p>Power source. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf4e167e7384c20bdca3fc90dd5ba8163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e167e7384c20bdca3fc90dd5ba8163">&#9670;&nbsp;</a></span>bc_qc_class_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gaf4e167e7384c20bdca3fc90dd5ba8163">bc_qc_class_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Qualcomm Quick Charge charger class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf4e167e7384c20bdca3fc90dd5ba8163a1a7b4b977ba679196ab7753f370e100e"></a>BC_QC_CLASS_A&#160;</td><td class="fielddoc"><p>Class A HVDCP: Supports 5V, 9V and 12V supplies. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf4e167e7384c20bdca3fc90dd5ba8163af6d078f91809682d0c9426cd128148b8"></a>BC_QC_CLASS_B&#160;</td><td class="fielddoc"><p>Class B HVDCP: Supports 5V, 9B, 12V and 20V supplies. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga451c9706d02556521e32e66aa78ab48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga451c9706d02556521e32e66aa78ab48b">&#9670;&nbsp;</a></span>bc_qc_ver_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga451c9706d02556521e32e66aa78ab48b">bc_qc_ver_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Qualcomm charger version. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga451c9706d02556521e32e66aa78ab48baa5a16b974a27087ad4f1fc5be6e8e86c"></a>BC_QC_VER_2&#160;</td><td class="fielddoc"><p>QC 2.0 charger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga451c9706d02556521e32e66aa78ab48ba6b6e1ed11b98a806234eef58e30c0842"></a>BC_QC_VER_3&#160;</td><td class="fielddoc"><p>QC 3.0 charger. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadccd83f68100db184fb580677c9b6e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccd83f68100db184fb580677c9b6e47">&#9670;&nbsp;</a></span>bc_apple_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gadccd83f68100db184fb580677c9b6e47">bc_apple_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apple charger brick id. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadccd83f68100db184fb580677c9b6e47a50cacc9e0f69ff1e4924af77e8e3b362"></a>BC_APPLE_ID_1A&#160;</td><td class="fielddoc"><p>Apple 1.0 A charging brick. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadccd83f68100db184fb580677c9b6e47afdfb0bf6368f27396413fec457572af6"></a>BC_APPLE_ID_2_1A&#160;</td><td class="fielddoc"><p>Apple 2.1 A charging brick. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadccd83f68100db184fb580677c9b6e47a625c2d37287cb1d2b650af596b28ca1a"></a>BC_APPLE_ID_2_4A&#160;</td><td class="fielddoc"><p>Apple 2.4 A charging brick. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf6b59aae9342e308eac3d4c7447edabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b59aae9342e308eac3d4c7447edabe">&#9670;&nbsp;</a></span>bc_charge_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gaf6b59aae9342e308eac3d4c7447edabe">bc_charge_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of legacy battery charging schemes supported over a Type-C or Type-A port. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea79d9c09a8c8ac0905dc2ba7619b6895c"></a>BC_CHARGE_NONE&#160;</td><td class="fielddoc"><p>No active battery charging modes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea7aab279b2a9c2c7b9969609f6a6d4cee"></a>BC_CHARGE_DCP&#160;</td><td class="fielddoc"><p>Dedicated Charging Port as defined by BC 1.2 spec. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea480a0d32a9619385020020050eee332f"></a>BC_CHARGE_QC2&#160;</td><td class="fielddoc"><p>QC2.0 charger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea878acad41d7a690c8da0a463d75bf9f6"></a>BC_CHARGE_QC3&#160;</td><td class="fielddoc"><p>QC3.0 charger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea1d0f74f2f8e380a9ec183deca569e814"></a>BC_CHARGE_AFC&#160;</td><td class="fielddoc"><p>Adaptive Fast Charging mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea53025080e01dd863252c012edbd7a6c1"></a>BC_CHARGE_APPLE&#160;</td><td class="fielddoc"><p>Apple power brick. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b59aae9342e308eac3d4c7447edabea86f0cc62fa0b6eeeaa82f48dd13032f2"></a>BC_CHARGE_CDP&#160;</td><td class="fielddoc"><p>Charging Downstream Port as defined by BC 1.2 spec. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadcc0527a2ced048816b7b75b7b4357cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc0527a2ced048816b7b75b7b4357cc">&#9670;&nbsp;</a></span>bc_d_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gadcc0527a2ced048816b7b75b7b4357cc">bc_d_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of the various Dp/Dm states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadcc0527a2ced048816b7b75b7b4357cca22a7b682125a6ef2cbbf793053b56c1f"></a>BC_D_GND&#160;</td><td class="fielddoc"><p>DP/DM voltage &lt; 0.325. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadcc0527a2ced048816b7b75b7b4357cca1f00718bd86a919b95c0b5594a45b267"></a>BC_D_0_6V&#160;</td><td class="fielddoc"><p>0.325 &lt; DP/DPM voltage &lt; 2V </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadcc0527a2ced048816b7b75b7b4357cca57ebe44fd9369253681200690e0b322f"></a>BC_D_3_3V&#160;</td><td class="fielddoc"><p>DP/DM voltage &gt; 2V. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadcc0527a2ced048816b7b75b7b4357cca0f0ecec14a7363894bf0c4c8b1d5221f"></a>BC_D_ERR&#160;</td><td class="fielddoc"><p>Error state. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaba44f84aad9f024cdb897fbc11f15bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba44f84aad9f024cdb897fbc11f15bae">&#9670;&nbsp;</a></span>bc_apple_term</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gaba44f84aad9f024cdb897fbc11f15bae">bc_apple_term</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of Apple terminations codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba44f84aad9f024cdb897fbc11f15baea8e40aa37cd02b198bcddc2d8becb1295"></a>APPLE_TERM1&#160;</td><td class="fielddoc"><p>Termination 1 code: 1 - 2.22 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba44f84aad9f024cdb897fbc11f15baea8ae05e94a248c579b05720fbe31b60f4"></a>APPLE_TERM2&#160;</td><td class="fielddoc"><p>Termination 2 code: 2.22 - 2.89 V. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba44f84aad9f024cdb897fbc11f15baeac19b34cdbeb374a7c0031346d72f0fa6"></a>APPLE_TERM3&#160;</td><td class="fielddoc"><p>Termination 3 code: 2.89+ V. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafc4785e34159a46b6e6a14c09297352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc4785e34159a46b6e6a14c09297352d">&#9670;&nbsp;</a></span>bc_apple_brick_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gafc4785e34159a46b6e6a14c09297352d">bc_apple_brick_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible Apple Brick IDs based on the terminations on DP and DM pins. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da7439dfb5b322c6278b6c5f4af54991b8"></a>APPLE_BRICK_ID_0&#160;</td><td class="fielddoc"><p>APPLE_TERM1 on DM, APPLE_TERM1 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da675c612dc6d0cf5602343c36b00b6381"></a>APPLE_BRICK_ID_1&#160;</td><td class="fielddoc"><p>APPLE_TERM1 on DM, APPLE_TERM2 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da0e0fd1f198d7975814e4bdd060f1b7dc"></a>APPLE_BRICK_ID_2&#160;</td><td class="fielddoc"><p>APPLE_TERM1 on DM, APPLE_TERM3 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da1f4e606332e57286a954f6d24d762aa3"></a>APPLE_BRICK_ID_3&#160;</td><td class="fielddoc"><p>APPLE_TERM2 on DM, APPLE_TERM1 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352dafd65c69e85b30b3eb1387d330a612c0e"></a>APPLE_BRICK_ID_4&#160;</td><td class="fielddoc"><p>APPLE_TERM2 on DM, APPLE_TERM2 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da806e446a372770961facdf346f97c75e"></a>APPLE_BRICK_ID_5&#160;</td><td class="fielddoc"><p>APPLE_TERM2 on DM, APPLE_TERM3 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352da39cb9e3054be29dded6dfd46d1a5efbb"></a>APPLE_BRICK_ID_6&#160;</td><td class="fielddoc"><p>APPLE_TERM3 on DM, APPLE_TERM1 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352daccf8a03b00ade762250c7f3883821595"></a>APPLE_BRICK_ID_7&#160;</td><td class="fielddoc"><p>APPLE_TERM3 on DM, APPLE_TERM2 on DP. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafc4785e34159a46b6e6a14c09297352dac3a500a9342c57943535529d0639c790"></a>APPLE_BRICK_ID_8&#160;</td><td class="fielddoc"><p>APPLE_TERM3 on DM, APPLE_TERM3 on DP. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9aa71d2453ce7697ebd7b34f8c951392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa71d2453ce7697ebd7b34f8c951392">&#9670;&nbsp;</a></span>bc_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga9aa71d2453ce7697ebd7b34f8c951392">bc_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of states in the legacy battery charging state machine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a472586df5734d0172687220fcd71843d"></a>BC_FSM_OFF&#160;</td><td class="fielddoc"><p>BC state machine inactive. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a62f74466921b4954741663e20d90f5fb"></a>BC_FSM_SRC_LOOK_FOR_CONNECT&#160;</td><td class="fielddoc"><p>Look for connection as a DCP. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392ae34ad2b37b6e2c9e2f3b6a15f3ae35fd"></a>BC_FSM_SRC_INITIAL_CONNECT&#160;</td><td class="fielddoc"><p>Initial BC1.2 sink connection detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392aae7f227adfa36b4c0c738dc4822977d9"></a>BC_FSM_SRC_APPLE_CONNECTED&#160;</td><td class="fielddoc"><p>Connected to sink as an Apple power brick. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a8b400c7ef2de7b9886c8f96eed35e4c0"></a>BC_FSM_SRC_CDP_CONNECTED&#160;</td><td class="fielddoc"><p>Port configured as a Charging Downstream Port (CDP). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392af1122c9570fe68eaae15cec8be56dbdc"></a>BC_FSM_SRC_OTHERS_CONNECTED&#160;</td><td class="fielddoc"><p>DCP failed Apple sink detection. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392ab7d3017a7349e7449f8537565504d247"></a>BC_FSM_SRC_QC_OR_AFC&#160;</td><td class="fielddoc"><p>Port connected to a QC or AFC sink. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a0e960250b3d8e9f2de15c1a8b918743b"></a>BC_FSM_SRC_QC_CONNECTED&#160;</td><td class="fielddoc"><p>Connected to sink as a QC HVDCP. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a1e387e350b416a1796a7800234af2309"></a>BC_FSM_SRC_AFC_CONNECTED&#160;</td><td class="fielddoc"><p>Connected to sink as an AFC charger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a92f24791eb06f19cd24481ce958a9ff5"></a>BC_FSM_SINK_START&#160;</td><td class="fielddoc"><p>BC sink state machine start state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a0e435eb5c633759966758e6f9204f093"></a>BC_FSM_SINK_APPLE_CHARGER_DETECT&#160;</td><td class="fielddoc"><p>Sink looking for an Apple charger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a49c0413696fa4f82eb962d643fb349ea"></a>BC_FSM_SINK_APPLE_BRICK_ID_DETECT&#160;</td><td class="fielddoc"><p>Sink identified Apple charger, identifying brick ID. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392af0e254a59e18fdde0e0ed7b364193e2d"></a>BC_FSM_SINK_PRIMARY_CHARGER_DETECT&#160;</td><td class="fielddoc"><p>BC 1.2 primary charger detect state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392ad19d7ca74994c47dab910d3073209f90"></a>BC_FSM_SINK_TYPE_C_ONLY_SOURCE_CONNECTED&#160;</td><td class="fielddoc"><p>BC 1.2 src detection failed, connected as Type-C sink. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a944b72c24b4df6301ef49a9ea14ed18c"></a>BC_FSM_SINK_SECONDARY_CHARGER_DETECT&#160;</td><td class="fielddoc"><p>BC 1.2 secondary charger detect state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a328e53b637885e368499cec480acbc4f"></a>BC_FSM_SINK_DCP_CONNECTED&#160;</td><td class="fielddoc"><p>Sink connected to a BC 1.2 DCP. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a6f266dafe1491962a6a53e0976e11d47"></a>BC_FSM_SINK_SDP_CONNECTED&#160;</td><td class="fielddoc"><p>Sink connected to a Standard Downstream Port (SDP). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a884c244caef4df77caa734c639c2e263"></a>BC_FSM_SINK_CDP_CONNECTED&#160;</td><td class="fielddoc"><p>Sink connected to a BC 1.2 CDP. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a476eecd33c767b4542267b0b861c7f8d"></a>BC_FSM_SINK_AFC_CHARGER_DETECT&#160;</td><td class="fielddoc"><p>AFC charger detect state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392ae71161d003eeb09b5e762d412a7145d2"></a>BC_FSM_SINK_QC_CHARGER_DETECTED&#160;</td><td class="fielddoc"><p>QC 2.0 charger detect state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9aa71d2453ce7697ebd7b34f8c951392a4650f63b111670a353d03cb586f30fd4"></a>BC_FSM_MAX_STATES&#160;</td><td class="fielddoc"><p>Invalid state ID. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab9b85b4ed92d797ea6bcb9c869f2fd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b85b4ed92d797ea6bcb9c869f2fd47">&#9670;&nbsp;</a></span>bc_sink_timer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gab9b85b4ed92d797ea6bcb9c869f2fd47">bc_sink_timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible timers in sink mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab9b85b4ed92d797ea6bcb9c869f2fd47aa5a0fb9b2135614e16a0857d1a6c3d70"></a>BC_SINK_TIMER_NONE&#160;</td><td class="fielddoc"><p>No timers running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b85b4ed92d797ea6bcb9c869f2fd47a2c39ddc65f4f93385a457388d2e0d3be"></a>BC_SINK_DCD_DEBOUNCE_TIMER&#160;</td><td class="fielddoc"><p>DCD Debounce timer. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab9b85b4ed92d797ea6bcb9c869f2fd47a31dbf7f927e451ea08ec4fe170946086"></a>BC_SINK_TIMER_BC_DONE&#160;</td><td class="fielddoc"><p>T_GLITCH_BC_DONE timer. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadbd5dcca7a3c67f0e2c2f6a7e538ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">&#9670;&nbsp;</a></span>gpio_port_pin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of pins supported on CCGx devices. </p>
<p>This enumeration lists the port and pin assignment for the pins available on the CCGx USB-PD controllers. This is a superset of all pins supported across all of the devices in the family, and includes pins such as CC1/CC2 which have fixed functionality.</p>
<p>Please refer to the respective device datasheets to identify the pins that can be used as GPIOs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa1276ed3b776de8f7032368a49d1120ee"></a>GPIO_PORT_0_PIN_0&#160;</td><td class="fielddoc"><p>P0.0: Port 0, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa99dc124a515a416df13b1cc8a161c8cf"></a>GPIO_PORT_0_PIN_1&#160;</td><td class="fielddoc"><p>P0.1: Port 0, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5b05d98ca91289ca156de5116757be06"></a>GPIO_PORT_0_PIN_2&#160;</td><td class="fielddoc"><p>P0.2: Port 0, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa02fe21499b724387f8fb61e67b7a2101"></a>GPIO_PORT_0_PIN_3&#160;</td><td class="fielddoc"><p>P0.3: Port 0, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5344901dc2fc6dcb8936c6e5aa05339b"></a>GPIO_PORT_0_PIN_4&#160;</td><td class="fielddoc"><p>P0.4: Port 0, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2cae814b84c9bb7b37bc908b760167d2"></a>GPIO_PORT_0_PIN_5&#160;</td><td class="fielddoc"><p>P0.5: Port 0, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa443698ab60f0a3999e835c0f40f3f95e"></a>GPIO_PORT_0_PIN_6&#160;</td><td class="fielddoc"><p>P0.6: Port 0, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa01ae5402d011013cc2cff8ca9821a120"></a>GPIO_PORT_0_PIN_7&#160;</td><td class="fielddoc"><p>P0.7: Port 0, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa112c4da9a2d37ef1ea4bd54a64ccc15d"></a>GPIO_PORT_1_PIN_0&#160;</td><td class="fielddoc"><p>P1.0: Port 1, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faf6d5b594c5187e2ef4eb62ccce84da02"></a>GPIO_PORT_1_PIN_1&#160;</td><td class="fielddoc"><p>P1.1: Port 1, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa5cfb2323de1477384edf1c855907844d"></a>GPIO_PORT_1_PIN_2&#160;</td><td class="fielddoc"><p>P1.2: Port 1, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7facf757504ceb1ab9a2c01f456efbd8e15"></a>GPIO_PORT_1_PIN_3&#160;</td><td class="fielddoc"><p>P1.3: Port 1, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faa377bc01bd96d27aebbce8357344680e"></a>GPIO_PORT_1_PIN_4&#160;</td><td class="fielddoc"><p>P1.4: Port 1, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa652390cb0d1eda70730a3205f64c5678"></a>GPIO_PORT_1_PIN_5&#160;</td><td class="fielddoc"><p>P1.5: Port 1, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa12d52fd12d89edad1099d7764a9d66d9"></a>GPIO_PORT_1_PIN_6&#160;</td><td class="fielddoc"><p>P1.6: Port 1, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7ab965ff56d936e1e5533689143cf166"></a>GPIO_PORT_1_PIN_7&#160;</td><td class="fielddoc"><p>P1.7: Port 1, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faeecb4411147bbcda5f2c3d973bdcba06"></a>GPIO_PORT_2_PIN_0&#160;</td><td class="fielddoc"><p>P2.0: Port 2, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fac91bafd4e3e853e65e8b22a02750709d"></a>GPIO_PORT_2_PIN_1&#160;</td><td class="fielddoc"><p>P2.1: Port 2, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa410c85c6e7ff9483f2ec4f63415f3861"></a>GPIO_PORT_2_PIN_2&#160;</td><td class="fielddoc"><p>P2.2: Port 2, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fac56a6cfa151bcae92a9bb6c0ab66d6ed"></a>GPIO_PORT_2_PIN_3&#160;</td><td class="fielddoc"><p>P2.3: Port 2, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa52b8b5b6ec253e207bc9cf1021ee2cbe"></a>GPIO_PORT_2_PIN_4&#160;</td><td class="fielddoc"><p>P2.4: Port 2, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa926d647e544ae15c3ea842cfd6831f3f"></a>GPIO_PORT_2_PIN_5&#160;</td><td class="fielddoc"><p>P2.5: Port 2, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa963f16a09f06ff3ff03ec941fce34d44"></a>GPIO_PORT_2_PIN_6&#160;</td><td class="fielddoc"><p>P2.6: Port 2, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa48a35a1489851e628a982067293f1a0f"></a>GPIO_PORT_2_PIN_7&#160;</td><td class="fielddoc"><p>P2.7: Port 2, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad118c76412ac07fb9f2e335b5f8e8571"></a>GPIO_PORT_3_PIN_0&#160;</td><td class="fielddoc"><p>P3.0: Port 3, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa84731e836bd8856f2331ff5306a3ae0c"></a>GPIO_PORT_3_PIN_1&#160;</td><td class="fielddoc"><p>P3.1: Port 3, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa3da2aa5607bca768e83de577d7c7ade8"></a>GPIO_PORT_3_PIN_2&#160;</td><td class="fielddoc"><p>P3.2: Port 3, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2ba4752e65a3a306b4b44fbeff1c5844"></a>GPIO_PORT_3_PIN_3&#160;</td><td class="fielddoc"><p>P3.3: Port 3, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad109c0423bfa827da8a36e7a69cc1185"></a>GPIO_PORT_3_PIN_4&#160;</td><td class="fielddoc"><p>P3.4: Port 3, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae16a403a8a86e50df4de4781b6bee138"></a>GPIO_PORT_3_PIN_5&#160;</td><td class="fielddoc"><p>P3.5: Port 3, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7292d621bc2d071db6ebe49537927b92"></a>GPIO_PORT_3_PIN_6&#160;</td><td class="fielddoc"><p>P3.6: Port 3, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7faef16a22a4062b44c7f882571fa0c4fc6"></a>GPIO_PORT_3_PIN_7&#160;</td><td class="fielddoc"><p>P3.7: Port 3, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae33e167b53d34faebdcaea844d44edea"></a>GPIO_PORT_4_PIN_0&#160;</td><td class="fielddoc"><p>P4.0: Port 4, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa0e2e5b3656c82f46cd57bf0520370878"></a>GPIO_PORT_4_PIN_1&#160;</td><td class="fielddoc"><p>P4.1: Port 4, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fae9d26203db4d818f51e3cb1693f9de37"></a>GPIO_PORT_4_PIN_2&#160;</td><td class="fielddoc"><p>P4.2: Port 4, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa538f691971bc699769716fe73372c2ec"></a>GPIO_PORT_4_PIN_3&#160;</td><td class="fielddoc"><p>P4.3: Port 4, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa9383f3374899207da191c26265ff3177"></a>GPIO_PORT_4_PIN_4&#160;</td><td class="fielddoc"><p>P4.4: Port 4, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa2a4aead01ce9f697a44e2c338594ffee"></a>GPIO_PORT_4_PIN_5&#160;</td><td class="fielddoc"><p>P4.5: Port 4, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa4a0210aaf155201017a65a98cb53ce18"></a>GPIO_PORT_4_PIN_6&#160;</td><td class="fielddoc"><p>P4.6: Port 4, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa52508b75e1cd8c61023f647e2d8626f0"></a>GPIO_PORT_4_PIN_7&#160;</td><td class="fielddoc"><p>P4.7: Port 4, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa799cc99b89d5c889bdc420c33934f0bf"></a>GPIO_PORT_5_PIN_0&#160;</td><td class="fielddoc"><p>P5.0: Port 5, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7facb9cfc813e2345ed5a3a75898b1a253a"></a>GPIO_PORT_5_PIN_1&#160;</td><td class="fielddoc"><p>P5.1: Port 5, Pin 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa10a7d490f3d0df9a251df33d35da42d7"></a>GPIO_PORT_5_PIN_2&#160;</td><td class="fielddoc"><p>P5.2: Port 5, Pin 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fafe2de427331a0b949d9ca1264c36b373"></a>GPIO_PORT_5_PIN_3&#160;</td><td class="fielddoc"><p>P5.3: Port 5, Pin 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fad9e0f3214d407c7e316b8768f501de46"></a>GPIO_PORT_5_PIN_4&#160;</td><td class="fielddoc"><p>P5.4: Port 5, Pin 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa7565e2f0ea0b7d72abd2ad2d15be97d1"></a>GPIO_PORT_5_PIN_5&#160;</td><td class="fielddoc"><p>P5.5: Port 5, Pin 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fab7931504ad796058e1f628fc887ed845"></a>GPIO_PORT_5_PIN_6&#160;</td><td class="fielddoc"><p>P5.6: Port 5, Pin 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fabe6ad72ddef076e6051fee3efb991b34"></a>GPIO_PORT_5_PIN_7&#160;</td><td class="fielddoc"><p>P5.7: Port 5, Pin 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa00853e909cd9c54b6c7de51d248623c5"></a>GPIO_PORT_6_PIN_0&#160;</td><td class="fielddoc"><p>P6.0: Port 6, Pin 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadbd5dcca7a3c67f0e2c2f6a7e538ef7fa99628aa1586832f5f3dfcff506004841"></a>GPIO_PORT_6_PIN_1&#160;</td><td class="fielddoc"><p>P6.1: Port 6, Pin 1. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga91de19d5edf75a3e58f9d2c9371c30f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91de19d5edf75a3e58f9d2c9371c30f5">&#9670;&nbsp;</a></span>gpio_dm_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various GPIO drive modes supported by the CCGx devices. </p>
<p>This enumeration lists the various drive modes supported by CCGx IOs which are configured as GPIOs. Please refer to hsiom_mode_t for the IO mapping settings available for each CCGx IO.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577" title="Various IO matrix configuration modes. ">hsiom_mode_t</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5ae6eb06505d148078a8020ae0b5ae2b4b"></a>GPIO_DM_HIZ_ANALOG&#160;</td><td class="fielddoc"><p>Output buffer off (HiZ), input buffer off. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5aa15bca49a2a36bd694cb3fcacbe6c99b"></a>GPIO_DM_HIZ_DIGITAL&#160;</td><td class="fielddoc"><p>Output buffer off (HiZ), input buffer on. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5a8b68a63faf2c896b680103032a3d61cd"></a>GPIO_DM_RES_UP&#160;</td><td class="fielddoc"><p>Resistive pull-up. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5a946073dc394d366fd384195ade7ab0fe"></a>GPIO_DM_RES_DWN&#160;</td><td class="fielddoc"><p>Resistive pull-down. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5ac1a6be1d280217a0138b4193a8958fdd"></a>GPIO_DM_OD_LOW&#160;</td><td class="fielddoc"><p>Drive low and HZI for high. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5aee032bd6c9fe5a979b24788e10b25da9"></a>GPIO_DM_OD_HIGH&#160;</td><td class="fielddoc"><p>Drive high and HZI for low. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5a2d470cf24c28ea7b8c6250bb6487571e"></a>GPIO_DM_STRONG&#160;</td><td class="fielddoc"><p>Strong low and high drive. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91de19d5edf75a3e58f9d2c9371c30f5a8c28faee8980630c383a54da5190d7ec"></a>GPIO_DM_RES_UPDOWN&#160;</td><td class="fielddoc"><p>Resistive pull-up and pull-down. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga534bf6468ef6937caf6db065d83845ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga534bf6468ef6937caf6db065d83845ca">&#9670;&nbsp;</a></span>gpio_intr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various GPIO interrupt modes supported by the device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga534bf6468ef6937caf6db065d83845caa8315c5b4fb780e79d6b080c186817897"></a>GPIO_INTR_DISABLE&#160;</td><td class="fielddoc"><p>GPIO interrupt disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga534bf6468ef6937caf6db065d83845caa90cefe7b29e5a48b3ffaaaebcaedcc47"></a>GPIO_INTR_RISING&#160;</td><td class="fielddoc"><p>Interrupt on rising edge of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga534bf6468ef6937caf6db065d83845caadaf32c18079eb7bd646f98a06b49e210"></a>GPIO_INTR_FALLING&#160;</td><td class="fielddoc"><p>Interrupt on falling edge of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga534bf6468ef6937caf6db065d83845caa0f43ca6fc28a055f1f80024d1dfe846b"></a>GPIO_INTR_BOTH&#160;</td><td class="fielddoc"><p>Interrupt on both rising and falling edges. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga21929450529e4881bbfac8628bd82577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21929450529e4881bbfac8628bd82577">&#9670;&nbsp;</a></span>hsiom_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various IO matrix configuration modes. </p>
<p>Most of the IOs on CCGx devices &amp; DMC (Dock Management Controller), (except fixed function IOs like Vdd, GND, CCx), can be configured to select one from many available options. This enumerated type lists the various IO functions that can be selected for the flexible IOs. Not all functionality can be configured to any selected IO. The selectable functionality for each IO is fixed and cannot be altered. For example, in case of CCG3 or DMC, SWD_CLK cannot be configured to any other pin other than P2.1. But P2.1 can be configured to function as GPIO, SCB1_SPI_MOSI, SCB1_I2C_SDA or SCB1_UART_RTS.</p>
<p>Please refer to the respective device datasheets for more information about these IO options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga21929450529e4881bbfac8628bd82577aa35888587d5dc6faee7923c6fd086c59"></a>HSIOM_MODE_GPIO&#160;</td><td class="fielddoc"><p>Special functions disabled. </p>
<p>Used as GPIO. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga690ec97bf194692eae90b1276e129295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga690ec97bf194692eae90b1276e129295">&#9670;&nbsp;</a></span>uvdm_cmd_opcode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of opcodes supported in Cypress Flashing Alternate Mode U_VDMs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a8a978cd51564cdf4f5840e09956da53d"></a>UVDM_CMD_RESERVED&#160;</td><td class="fielddoc"><p>Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a2e40806b81f8998ec93847466aa7d3ed"></a>UVDM_CMD_GET_DEVICE_MODE_OPCODE&#160;</td><td class="fielddoc"><p>Get active mode of device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295af9cec52a844a160145e07078be8a6090"></a>UVDM_CMD_GET_DEVICE_VERSION_OPCODE&#160;</td><td class="fielddoc"><p>Get version information of all images. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a1b896a36d56888ef3692dd5d753175a5"></a>UVDM_CMD_GET_SILICON_ID_OPCODE&#160;</td><td class="fielddoc"><p>Get silicon ID of CCG. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a69b79feaacc613c3e1252b805fc5cdbf"></a>UVDM_CMD_DEVICE_RESET_OPCODE&#160;</td><td class="fielddoc"><p>Reset CCG. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a1fc040788a624b2ee0674df5ef9f6fe2"></a>UVDM_CMD_JUMP_TO_BOOT_OPCDOE&#160;</td><td class="fielddoc"><p>Jump to boot mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a77f95650a43528ecb8d43d7d69049a10"></a>UVDM_CMD_ENTER_FLASHING_MODE_OPCODE&#160;</td><td class="fielddoc"><p>Enable flash access mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295ab62b1777bdd92b50387b32d81592c9ba"></a>UVDM_CMD_SEND_DATA_OPCODE&#160;</td><td class="fielddoc"><p>Collect flash row data for write. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295ab4686321869f757c72d17a22e9260282"></a>UVDM_CMD_FLASH_WRITE_OPCODE&#160;</td><td class="fielddoc"><p>Program flash row. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a811717f4ed535607afc48d3a55464b0d"></a>UVDM_CMD_READ_DATA_OPCODE&#160;</td><td class="fielddoc"><p>Collect flash row data for read. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295af461f567a94e2077652ab156c73a2273"></a>UVDM_CMD_FLASH_READ_OPCODE&#160;</td><td class="fielddoc"><p>Read flash row. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295ad095ff23a283990d36be79e68906d10a"></a>UVDM_CMD_VALIDATE_FW_OPCODE&#160;</td><td class="fielddoc"><p>Validate FW image. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a6327ea1b770b24cc37e9242127688624"></a>UVDM_CMD_REASON_FOR_BOOT_MODE&#160;</td><td class="fielddoc"><p>Get reason for boot mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a66be1931fa0229311a456dca89f83915"></a>UVDM_CMD_GET_CHECKSUM&#160;</td><td class="fielddoc"><p>Get checksum of specified flash section. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a532ad432926e6b478a9e430f24458b18"></a>UVDM_CMD_GET_FW_START_ADDRESS_OPCODE&#160;</td><td class="fielddoc"><p>Get start address of FW images. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a4b669e4d5369781a48fcaa159f085183"></a>UVDM_CMD_SET_APP_PRIORITY_OPCODE&#160;</td><td class="fielddoc"><p>Set APP priority value. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a21f7e67dcfffa18c8ba7945d45692e89"></a>UVDM_CMD_RESERVED_16&#160;</td><td class="fielddoc"><p>Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a03631f2eaaeb901a5a560fc88458e61f"></a>UVDM_CMD_SEND_SIGNATURE_OPCODE&#160;</td><td class="fielddoc"><p>Program FW image ECDSA signature. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a50594cac90160f0ee90b8f3132589159"></a>UVDM_CMD_RESERVED_18&#160;</td><td class="fielddoc"><p>Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295ace69759b1fd3574d0b1c27f4fffc8843"></a>UVDM_CMD_GET_BOOT_TYPE&#160;</td><td class="fielddoc"><p>Get information related to boot loader type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295ade77278a8e7408af943fe3e290cfb067"></a>UVDM_CMD_GET_CUSTOMER_INFO&#160;</td><td class="fielddoc"><p>Get custom data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a680f07050546022b1f428b1760f5ac82"></a>UVDM_CMD_RESERVED_21&#160;</td><td class="fielddoc"><p>21: Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a0039d3d75d81cd098fd6e82aa0c1ac59"></a>UVDM_CMD_FWCT_SIG_WRITE&#160;</td><td class="fielddoc"><p>24: Obtain the signature for the FWCT </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295a91256d9b968897a5066040739b5ba84d"></a>UVDM_CMD_FWCT_ROW_WRITE&#160;</td><td class="fielddoc"><p>25: Update the FWCT row </p>
</td></tr>
<tr><td class="fieldname"><a id="gga690ec97bf194692eae90b1276e129295aa327cf7e75ade397a2a533360ae802be"></a>UVDM_CMD_CUSTOM&#160;</td><td class="fielddoc"><p>Custom UVDM implementation for users. </p>
<p>Needs the solution override option to be enabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5e70c33f2bd3c8f24494776269a35ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e70c33f2bd3c8f24494776269a35ad7">&#9670;&nbsp;</a></span>uvdm_response_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible states of UVDM Response. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5e70c33f2bd3c8f24494776269a35ad7af445ad09a8010bc59102ff33160d74c1"></a>UVDM_NOT_HANDLED&#160;</td><td class="fielddoc"><p>UVDM not recognised, can't be handled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5e70c33f2bd3c8f24494776269a35ad7aa07e1de15f31d60434113acd40cdfd4a"></a>UVDM_HANDLED_RESPONSE_READY&#160;</td><td class="fielddoc"><p>UVDM handled and response is ready to be sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5e70c33f2bd3c8f24494776269a35ad7add9a5aadb369d40563f8a0e02ad32c63"></a>UVDM_HANDLED_NO_RESPONSE&#160;</td><td class="fielddoc"><p>UVDM handled but no response required. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5e70c33f2bd3c8f24494776269a35ad7ae2eccb87e5b7927fdfb0bffe36588ca2"></a>UVDM_HANDLED_RESPONSE_NOT_READY&#160;</td><td class="fielddoc"><p>UVDM Handled but response will be sent later, potential non-blocking command. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadd88527b70b8f8aed9c2495edceacc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd88527b70b8f8aed9c2495edceacc6c">&#9670;&nbsp;</a></span>uvdm_qc_pps_cmd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gadd88527b70b8f8aed9c2495edceacc6c">uvdm_qc_pps_cmd_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of opcodes of QC 5.0/4.0 UVDM Commands. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd88527b70b8f8aed9c2495edceacc6cab1b876648ff2383efdc2aa1293f5d196"></a>UVDM_QC_GET_CASE_TEMP&#160;</td><td class="fielddoc"><p>QC 5.0/4.0 Get Case Temperature opcode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd88527b70b8f8aed9c2495edceacc6ca221911a061c9878b12e450dc4ea05a6c"></a>UVDM_QC_GET_CONNECTOR_TEMP&#160;</td><td class="fielddoc"><p>QC 5.0/4.0 Get Connector Temperature opcode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd88527b70b8f8aed9c2495edceacc6cad3a2ceaa7234e51562b7a169973b3dc7"></a>UVDM_QC_GET_CONNECTOR_VOLT&#160;</td><td class="fielddoc"><p>QC 5.0/4.0 Get Connector Voltage opcode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd88527b70b8f8aed9c2495edceacc6ca72429a3f951bfa3c6fb034c58365141c"></a>UVDM_QC_GET_CHARGER_TYPE&#160;</td><td class="fielddoc"><p>QC 5.0/4.0 Get Charger Type opcode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd88527b70b8f8aed9c2495edceacc6cab5f1ccdb0aee42ba59c050ca5aeec56e"></a>UVDM_QC_GET_CHARGER_VERSION&#160;</td><td class="fielddoc"><p>QC 5.0/4.0 Get Charger Version opcode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2f1610d2adf8661cff2fbb56f85be45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f1610d2adf8661cff2fbb56f85be45f">&#9670;&nbsp;</a></span>eFWCT_IDX_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga2f1610d2adf8661cff2fbb56f85be45f">eFWCT_IDX_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to index the array for FWCT row number. </p>

</div>
</div>
<a id="ga7c73b649a1c51bbb96cfb3f1aeb4e0e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c73b649a1c51bbb96cfb3f1aeb4e0e9">&#9670;&nbsp;</a></span>eIMAGE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga7c73b649a1c51bbb96cfb3f1aeb4e0e9">eIMAGE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for image types. </p>

</div>
</div>
<a id="ga8651b8b577a26ca726537b6e68128a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8651b8b577a26ca726537b6e68128a61">&#9670;&nbsp;</a></span>valid_fwct_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga8651b8b577a26ca726537b6e68128a61">valid_fwct_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to indicate fwct validity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8651b8b577a26ca726537b6e68128a61a2e3c1bcf8be020e9e04a66ed936078e5"></a>FWCT_VALID_NONE&#160;</td><td class="fielddoc"><p>No valid FWCT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8651b8b577a26ca726537b6e68128a61acde5268c85b9ea997fec79cc6825b0c9"></a>FWCT_IDX_0_VALID&#160;</td><td class="fielddoc"><p>FWCT 0 is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8651b8b577a26ca726537b6e68128a61af7fbc3bf0a2999507745a849b3a3540c"></a>FWCT_IDX_1_VALID&#160;</td><td class="fielddoc"><p>FWCT 1 is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8651b8b577a26ca726537b6e68128a61a97df7cdf8841bc652b0b7af856a75898"></a>MAX_VALID_FWCT&#160;</td><td class="fielddoc"><p>All FWCTs are valid. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8c1472d4978873442e3b2040b9279c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1472d4978873442e3b2040b9279c7b">&#9670;&nbsp;</a></span>inst_evt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga8c1472d4978873442e3b2040b9279c7b">inst_evt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of all instrumentation fault events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8c1472d4978873442e3b2040b9279c7ba9ee6c3e15702ef5bc0f5473cbd599f2b"></a>INST_EVT_WDT_RESET&#160;</td><td class="fielddoc"><p>0x00: Instrumentation fault event for watchdog reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8c1472d4978873442e3b2040b9279c7ba883dcd2a5cbbee9a781c26be1c5422e7"></a>INST_EVT_HARD_FAULT&#160;</td><td class="fielddoc"><p>0x01: Instrumentation fault event for hard fault. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf9e3ae39360ed4676f284cfcbd27f090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e3ae39360ed4676f284cfcbd27f090">&#9670;&nbsp;</a></span>sys_fw_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of CCG firmware modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf9e3ae39360ed4676f284cfcbd27f090a391a0ea21acffd327faf3aa4565e0879"></a>SYS_FW_MODE_BOOTLOADER&#160;</td><td class="fielddoc"><p>Bootloader mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9e3ae39360ed4676f284cfcbd27f090a05e2081c251f80b012212b2ef0d7a8d7"></a>SYS_FW_MODE_FWIMAGE_1&#160;</td><td class="fielddoc"><p>Firmware Image #1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9e3ae39360ed4676f284cfcbd27f090a736e0fe38ba8493821e4a7b5076bdd79"></a>SYS_FW_MODE_FWIMAGE_2&#160;</td><td class="fielddoc"><p>Firmware Image #2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9e3ae39360ed4676f284cfcbd27f090a608b1bf5157307c4a7735afe6cae3d20"></a>SYS_FW_MODE_INVALID&#160;</td><td class="fielddoc"><p>Invalid value. </p>
</td></tr>
</table>

</div>
</div>
<a id="gacebb36a46a6b7abb6d95ff1847116864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacebb36a46a6b7abb6d95ff1847116864">&#9670;&nbsp;</a></span>i2c_scb_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#gacebb36a46a6b7abb6d95ff1847116864">i2c_scb_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible I2C block states. </p>
<p>The I2C driver implements a state machine which ensures that read/write transfers are responded to correctly without any corruption. This data type lists the possible states in this slave mode state machine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864a15041879a3dc1884dc1a8936ae835378"></a>I2C_SCB_STATE_DISABLED&#160;</td><td class="fielddoc"><p>I2C interface is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864ac50d8b58e54cb0faa1bd5f7c34cabfeb"></a>I2C_SCB_STATE_INIT&#160;</td><td class="fielddoc"><p>Interface initialized and waiting to be enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864a596bf12eea8f8ab26ba27a4626b99a93"></a>I2C_SCB_STATE_IDLE&#160;</td><td class="fielddoc"><p>Interface ready and waiting for preamble from the master. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864a59f356243d6645440b91bdd864b29806"></a>I2C_SCB_STATE_PREAMBLE&#160;</td><td class="fielddoc"><p>Preamble phase is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864af45f9af5cfa42f4af56471457b722b7e"></a>I2C_SCB_STATE_READ&#160;</td><td class="fielddoc"><p>I2C read operation is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864a2a7603c06a234c402f23b6b8207fc4e0"></a>I2C_SCB_STATE_WRITE&#160;</td><td class="fielddoc"><p>I2C write operation is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864ab764a31bdc6446345931019d3b5dd618"></a>I2C_SCB_STATE_CLK_STRETCH&#160;</td><td class="fielddoc"><p>Drive is stretching I2C clock to delay operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864ad62d35142d956e849487d792991d0a5f"></a>I2C_SCB_STATE_ERROR&#160;</td><td class="fielddoc"><p>Error state: transaction error detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacebb36a46a6b7abb6d95ff1847116864a6627483a8d6bc8a9ead5f2a78581f4f7"></a>I2C_SCB_NUM_STATES&#160;</td><td class="fielddoc"><p>Last state ID: not used. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga929dc6e6ed7bb0e330bcbd1285acc0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929dc6e6ed7bb0e330bcbd1285acc0d1">&#9670;&nbsp;</a></span>i2c_scb_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible I2C block operating modes. </p>
<p>This type lists the possible I2C block operating modes. Multiple slave modes are defined in case there is any mode specific handling required for any of them.</p>
<p>Note: Master mode is currently not supported by the driver. Note: The HPI and ALP_RIDGE mode handling is equivalent. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga929dc6e6ed7bb0e330bcbd1285acc0d1a20256ed7ecac9e0284e50fd79272dc59"></a>I2C_SCB_MODE_MASTER&#160;</td><td class="fielddoc"><p>Master mode: Can be used for mux control. </p>
<p>Not supported as of now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga929dc6e6ed7bb0e330bcbd1285acc0d1abf718bae34faeb8416886b96aef6f4ac"></a>I2C_SCB_MODE_HPI&#160;</td><td class="fielddoc"><p>Slave mode: Used for HPI interface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga929dc6e6ed7bb0e330bcbd1285acc0d1a9903c0821e9aeea1e6121bd1d80413e0"></a>I2C_SCB_MODE_ALP_RIDGE&#160;</td><td class="fielddoc"><p>Slave mode: Used for Alpine Ridge interface. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga39039019bd1c23cdc1d45a1bf0ea8b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39039019bd1c23cdc1d45a1bf0ea8b74">&#9670;&nbsp;</a></span>i2c_scb_clock_freq_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of possible I2C bus bit rates. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga39039019bd1c23cdc1d45a1bf0ea8b74ac7f1880c89328e79010975bc5ad4a368"></a>I2C_SCB_CLOCK_FREQ_100_KHZ&#160;</td><td class="fielddoc"><p>100 KHz operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39039019bd1c23cdc1d45a1bf0ea8b74a4db4a21e3d10ab9a4aa3d030dfa7a15b"></a>I2C_SCB_CLOCK_FREQ_400_KHZ&#160;</td><td class="fielddoc"><p>400 KHz operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga39039019bd1c23cdc1d45a1bf0ea8b74a3e40b72ad3944d135f3d0125a741fb5c"></a>I2C_SCB_CLOCK_FREQ_1_MHZ&#160;</td><td class="fielddoc"><p>1 MHz operation. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga459a4d34fea4545cb049bcbc0aa2924c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga459a4d34fea4545cb049bcbc0aa2924c">&#9670;&nbsp;</a></span>i2c_cb_cmd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__ccgxAppCommon.html#ga459a4d34fea4545cb049bcbc0aa2924c">i2c_cb_cmd_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of I2C operation being notified through a callback function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga459a4d34fea4545cb049bcbc0aa2924cafe582baaa37c28d2b37e009c4d9b6e4c"></a>I2C_CB_CMD_READ&#160;</td><td class="fielddoc"><p>Read command from master. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga459a4d34fea4545cb049bcbc0aa2924cade77d0bd54e7e1f2e1e793f356c01942"></a>I2C_CB_CMD_WRITE&#160;</td><td class="fielddoc"><p>Write command from master. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga459a4d34fea4545cb049bcbc0aa2924ca9ac7449667cd3b27fdc767c1c513f6c0"></a>I2C_CB_CMD_XFER_END&#160;</td><td class="fielddoc"><p>End of read transfer: STOP condition signalled by master. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga459a4d34fea4545cb049bcbc0aa2924ca5a5a7ed3afc68d0a0f9a7281dbea598c"></a>I2C_CB_CMD_TIMEOUT&#160;</td><td class="fielddoc"><p>Timeout on I2C operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga459a4d34fea4545cb049bcbc0aa2924ca7b437836f5a0ae3eb59a7fa1710ad712"></a>I2C_CB_SLAVE_ADDR_MATCH&#160;</td><td class="fielddoc"><p>I2C slave address match detected. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga987e808055c53d2d3138625e94ce0c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987e808055c53d2d3138625e94ce0c8d">&#9670;&nbsp;</a></span>app_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application level init function. </p>
<p>This function performs any Application level initialization required for the CCG solution. This should be called before calling the dpmInit function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga41c615b2b4410be1d5f90f454b2a6b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c615b2b4410be1d5f90f454b2a6b5e">&#9670;&nbsp;</a></span>app_is_port_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_port_enabled </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the specified PD port is enabled in the system configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="gad066f25e9c4975fadc25bfbdeeb88bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad066f25e9c4975fadc25bfbdeeb88bb1">&#9670;&nbsp;</a></span>app_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t app_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for application level asynchronous tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success, 0 in case of task handling error. </dd></dl>

</div>
</div>
<a id="ga3dd2bdc30aa59479a77d28857789cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd2bdc30aa59479a77d28857789cff2">&#9670;&nbsp;</a></span>app_get_callback_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_stc_pdstack_app_cbk_t* app_get_callback_ptr </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return the App callback structure pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Application callback structure pointer </dd></dl>

</div>
</div>
<a id="gad1cd70e9e221ab79f671ce87143afe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cd70e9e221ab79f671ce87143afe79">&#9670;&nbsp;</a></span>app_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for event notifications from the PD stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context.. </td></tr>
    <tr><td class="paramname">evt</td><td>Type of event to be handled. </td></tr>
    <tr><td class="paramname">dat</td><td>Data associated with the event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaaadfeec58882d5ff9434208ef0f07af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaadfeec58882d5ff9434208ef0f07af6">&#9670;&nbsp;</a></span>app_get_resp_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_resp_t* app_get_resp_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the application provide PD command response buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port corresponding to the command and response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the response buffer. </dd></dl>

</div>
</div>
<a id="ga93d7c64e58560deaffc50953f364124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d7c64e58560deaffc50953f364124b">&#9670;&nbsp;</a></span>app_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#structapp__status__t">app_status_t</a>* app_get_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get handle to structure containing information about the system status for a PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port to be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the system information structure. </dd></dl>

</div>
</div>
<a id="gae9332fe6e441fbc8c3ee70b1e90a0f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9332fe6e441fbc8c3ee70b1e90a0f77">&#9670;&nbsp;</a></span>app_update_sys_battery_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_sys_battery_status </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bsdo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the system battery status. </p>
<p>Called from HPI write handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bsdo</td><td>Battery Status Data Object Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37ab189c440f4561aebd58aa78d6621d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ab189c440f4561aebd58aa78d6621d">&#9670;&nbsp;</a></span>app_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the APP handlers are ready to allow device deep sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>true if APP handler is idle, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5e5b5fbf3a976f0f88688f3bca95908c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5b5fbf3a976f0f88688f3bca95908c">&#9670;&nbsp;</a></span>app_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the APP handler state after CCG device wakes from deep-sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga772c8b861e18d101c97e0dfc901a9e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga772c8b861e18d101c97e0dfc901a9e0e">&#9670;&nbsp;</a></span>system_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_sleep </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to place CCG device in power saving mode if possible. </p>
<p>This function places the CCG device in power saving deep sleep mode if possible. The function checks for each interface (PD, HPI etc.) being idle and then enters sleep mode with the appropriate wake-up triggers. If the device enters sleep mode, the function will only return after the device has woken up. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device went into sleep, false otherwise. </dd></dl>

</div>
</div>
<a id="ga257a11c7349f3f402f3b5071e8ac9b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257a11c7349f3f402f3b5071e8ac9b04">&#9670;&nbsp;</a></span>vconn_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vconn_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables VCONN power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">channel</td><td>Selected CC line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if VConn was turned ON; false if NOT. </dd></dl>

</div>
</div>
<a id="ga635c202b5b7794044060fe53283c0ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga635c202b5b7794044060fe53283c0ca1">&#9670;&nbsp;</a></span>vconn_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vconn_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables VCONN power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">channel</td><td>Selected CC line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga62b195995f6b6224c6284f4224bdadf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b195995f6b6224c6284f4224bdadf0">&#9670;&nbsp;</a></span>vconn_is_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vconn_is_present </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if power is present on VConn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power is present on VConn, else returns false </dd></dl>

</div>
</div>
<a id="ga5ddce48424ce3539552456b460083d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ddce48424ce3539552456b460083d08">&#9670;&nbsp;</a></span>vbus_is_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vbus_is_present </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8&#160;</td>
          <td class="paramname"><em>per</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if power is present on VBus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt</td><td>Voltage in mV units. </td></tr>
    <tr><td class="paramname">per</td><td>Threshold margin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power is present on VBus, else returns false </dd></dl>

</div>
</div>
<a id="ga0c527850e02f68c9c1072b58921fe533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c527850e02f68c9c1072b58921fe533">&#9670;&nbsp;</a></span>vbus_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vbus_get_value </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return current VBUS voltage in mV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VBUS voltage in mV </dd></dl>

</div>
</div>
<a id="ga631d47609bcac183d47133c3a0bc55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631d47609bcac183d47133c3a0bc55e2">&#9670;&nbsp;</a></span>vbus_discharge_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_discharge_on </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function turns on discharge FET on selected port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga370b31502ed6b6794b00652450930ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370b31502ed6b6794b00652450930ce1">&#9670;&nbsp;</a></span>vbus_discharge_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_discharge_off </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function turns off discharge FET on selected port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga197c17a51bae827c86006723dd28b561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197c17a51bae827c86006723dd28b561">&#9670;&nbsp;</a></span>system_vconn_ocp_en()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_vconn_ocp_en </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable vconn ocp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cbk</td><td>OCP callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false if parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga3ceb8e80d5c01c5157484bf30f85925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ceb8e80d5c01c5157484bf30f85925d">&#9670;&nbsp;</a></span>system_vconn_ocp_dis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_vconn_ocp_dis </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable vconn ocp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga128a0e6e3970ac63087ee51a55999429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga128a0e6e3970ac63087ee51a55999429">&#9670;&nbsp;</a></span>app_ovp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_ovp_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>ovp_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and configure the Over-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Expected VBus voltage. </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
    <tr><td class="paramname">ovp_cb</td><td>Callback function to be triggered when there is an OV event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9b919168d11183f7e6d5816b773a327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b919168d11183f7e6d5816b773a327e">&#9670;&nbsp;</a></span>app_ovp_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_ovp_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Over-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1d2dc98c12ea2ccc48072cb1b911a077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2dc98c12ea2ccc48072cb1b911a077">&#9670;&nbsp;</a></span>system_vconn_scp_en()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_vconn_scp_en </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable vconn scp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cbk</td><td>SCP callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false if parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga6a402bfbaeee99955bb644bb5ee19838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a402bfbaeee99955bb644bb5ee19838">&#9670;&nbsp;</a></span>system_vconn_scp_dis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_vconn_scp_dis </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable vconn scp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3c78977d8cc1e0753a16ea9bd1269b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c78977d8cc1e0753a16ea9bd1269b41">&#9670;&nbsp;</a></span>app_uvp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_uvp_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>uvp_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and configure the Under-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Expected VBus voltage. </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
    <tr><td class="paramname">uvp_cb</td><td>Callback function to be triggered when there is an UV event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga8a8979eabd2d152c80b65239cf08c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8979eabd2d152c80b65239cf08c601">&#9670;&nbsp;</a></span>app_uvp_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_uvp_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Under-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae2a1416d128b2d3ddb2444c4ea645750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a1416d128b2d3ddb2444c4ea645750">&#9670;&nbsp;</a></span>app_update_bc_src_snk_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_bc_src_snk_support </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the BC 1.2 source support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">enable</td><td>Whether BC 1.2 source support should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa2efd4f1d1b83a9cdda00443a3fd6209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2efd4f1d1b83a9cdda00443a3fd6209">&#9670;&nbsp;</a></span>app_update_bc_src_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_bc_src_support </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the BC 1.2 source support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">enable</td><td>Whether BC 1.2 support should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga039b5432fa3f08d7671a83b853e634fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039b5432fa3f08d7671a83b853e634fe">&#9670;&nbsp;</a></span>app_update_sys_pwr_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_sys_pwr_state </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the system power state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current system power state: 0=S0, Non-zero=other states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14afafc3b67eb20f3ed48beb857fbbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14afafc3b67eb20f3ed48beb857fbbb3">&#9670;&nbsp;</a></span>app_disable_pd_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t app_disable_pd_port </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_dpm_typec_cmd_cbk_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for PD port disable. </p>
<p>This function is used to ensure that any application level state associated with a faulty connection are cleared when the user wants to disable a PD port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">cbk</td><td>Callback to be called after operation is complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS on success, appropriate error code otherwise. </dd></dl>

</div>
</div>
<a id="gad09a34f2ede57568665767f0abe152dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad09a34f2ede57568665767f0abe152dd">&#9670;&nbsp;</a></span>app_validate_configtable_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_validate_configtable_offsets </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the configuration table specified. </p>
<p>Each copy of CCGx firmware on the device flash contains an embedded configuration table that defines the runtime behaviour of the CCGx device. This function checks whether the configuration table located at the specified location is valid (has valid offsets). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the table is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="ga1b1f896ef1a80a0a4e4ce42ccb80f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">&#9670;&nbsp;</a></span>ccg_app_task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_app_task_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CCGx periodic application level tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9f2f76f0c59231e3c1d65082b42c48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2f76f0c59231e3c1d65082b42c48dc">&#9670;&nbsp;</a></span>app_bc_12_sm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_bc_12_sm_start </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the simplified BC 1.2 (DCP/CDP) state machine for CCG5 device on detection of a Type-C sink connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga72e89461be3b772f36c3e68e0aca3615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e89461be3b772f36c3e68e0aca3615">&#9670;&nbsp;</a></span>sln_pd_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sln_pd_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution handler for PD events reported from the stack. </p>
<p>The function provides all PD events to the solution. For a solution supporting HPI, the solution function should re-direct the calls to hpi_pd_event_handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">evt</td><td>Event that is being notified. </td></tr>
    <tr><td class="paramname">data</td><td>Data associated with the event. This is an opaque pointer that needs to be de-referenced based on event type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga77d83af407e9c4eb2d50686a0713eec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d83af407e9c4eb2d50686a0713eec4">&#9670;&nbsp;</a></span>mux_ctrl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mux_ctrl_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Type-C Data Mux for a specific PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>USB-PD port for which the MUX is to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the MUX is initialized successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5a513df4f3b093f6680470327a38456e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a513df4f3b093f6680470327a38456e">&#9670;&nbsp;</a></span>mux_ctrl_set_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mux_ctrl_set_cfg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga8b1a30fd54c54d07259ea52e0c3ea200">mux_select_t</a>&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Type-C MUX to the desired configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port on which MUX is to be configured. </td></tr>
    <tr><td class="paramname">cfg</td><td>Desired MUX configuration. </td></tr>
    <tr><td class="paramname">polarity</td><td>Polarity of the Type-C connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga067c4788c2e2c0b38fa1631d05f8adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067c4788c2e2c0b38fa1631d05f8adab">&#9670;&nbsp;</a></span>mux_ctrl_bb_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mux_ctrl_bb_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable BB device enumeration on the board. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
    <tr><td class="paramname">polarity</td><td>PD connection (plug) orientation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe5c906c34d42ac62e4aab9b7f19a278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5c906c34d42ac62e4aab9b7f19a278">&#9670;&nbsp;</a></span>fault_handler_init_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fault_handler_init_vars </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize fault-handling related variables from the configuration table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the configuration table is invalid, true otherwise. </dd></dl>

</div>
</div>
<a id="ga6df995227d611d600d71fc616589e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6df995227d611d600d71fc616589e086">&#9670;&nbsp;</a></span>fault_handler_register_cbks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_register_cbks </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register solution space function handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gab57725e00da96b711d9567afd66a2f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57725e00da96b711d9567afd66a2f93">&#9670;&nbsp;</a></span>fault_handler_clear_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_clear_counts </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the fault occurrence counts after a Type-C detach is detected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae13092468da8be42cf1497719f2392d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13092468da8be42cf1497719f2392d3">&#9670;&nbsp;</a></span>fault_handler_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform any fault handler related tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad49cfd10d337a7d188bf27f25193a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49cfd10d337a7d188bf27f25193a35b">&#9670;&nbsp;</a></span>fault_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fault_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle any application events associated with fault handling logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">evt</td><td>Event code. </td></tr>
    <tr><td class="paramname">dat</td><td>Data associated with the event code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event does not need to be passed up to the solution layer. </dd></dl>

</div>
</div>
<a id="ga1cf3cc2e31b87f603f5da78321083a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf3cc2e31b87f603f5da78321083a02">&#9670;&nbsp;</a></span>app_otp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_otp_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Over-Temperature Protection logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf1e6cabefd046b9b84a228775afddd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e6cabefd046b9b84a228775afddd54">&#9670;&nbsp;</a></span>app_otp_check_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_otp_check_temp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform OTP check. </p>
<p>This function is called from app task </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae5a0e8856cdbd01ca2f848245c6b8a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a0e8856cdbd01ca2f848245c6b8a60">&#9670;&nbsp;</a></span>app_otp_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_otp_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of Over-Temperature Protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns True if Over-Temperature condition is active, otherwise false. </dd></dl>

</div>
</div>
<a id="gaf604c26013002a29a736c0b618c405cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf604c26013002a29a736c0b618c405cf">&#9670;&nbsp;</a></span>vconn_change_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vconn_change_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vconn_on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to handle VConn supply state change due to OCP condition or V5V supply change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">vconn_on</td><td>Whether VConn has just turned ON or OFF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2e060850f2d33f08d9ae4654ee7629f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e060850f2d33f08d9ae4654ee7629f3">&#9670;&nbsp;</a></span>app_is_host_hpd_virtual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_host_hpd_virtual </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the solution is configured to support virtual HPD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if virtual HPD is enabled. </dd></dl>

</div>
</div>
<a id="ga1cbafde1e08b787d570f69c5e8378b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbafde1e08b787d570f69c5e8378b10">&#9670;&nbsp;</a></span>set_custom_host_cap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_custom_host_cap_control </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>host_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update custom host capabilities HPI register with the value provided by EC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port on which the register is being updated. </td></tr>
    <tr><td class="paramname">host_config</td><td>Value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the custom host capabilities is set otherwise false. </dd></dl>

</div>
</div>
<a id="ga4a21460df3b3ee4cc8f22b2b856e668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a21460df3b3ee4cc8f22b2b856e668b">&#9670;&nbsp;</a></span>app_power_share_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_power_share_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the power sharing across ports on a dual-port CCG device. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac68110542f5463158989749753e37632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac68110542f5463158989749753e37632">&#9670;&nbsp;</a></span>app_contract_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_contract_handler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called at the end of a PD contract to check whether any role swaps need to be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="ga619740c578362ebb487c68e54c86c83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619740c578362ebb487c68e54c86c83e">&#9670;&nbsp;</a></span>pd_get_ptr_cfg_sub_tbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pd_get_ptr_cfg_sub_tbl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to retrieve desired sub-table from the configuration table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
    <tr><td class="paramname">type</td><td>Type of sub-table to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to config sub table </dd></dl>

</div>
</div>
<a id="gabcee026b0d0cdeec924f9b46abcc479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcee026b0d0cdeec924f9b46abcc479c">&#9670;&nbsp;</a></span>timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize timer callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08054935adf625b7ed2d5e6076f8ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08054935adf625b7ed2d5e6076f8ba52">&#9670;&nbsp;</a></span>app_conf_for_faulty_dev_removal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_conf_for_faulty_dev_removal </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the CCG to wait for physical detach of faulty port partner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa561ba390c4db0bce122405dedffb75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa561ba390c4db0bce122405dedffb75d">&#9670;&nbsp;</a></span>app_port_fault_count_exceeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_port_fault_count_exceeded </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any fault count has exceeded limit for the specified PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if fault count has exceeded limit, false otherwise. </dd></dl>

</div>
</div>
<a id="ga9fbef10605b1f75b463c5bc07f3b04e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbef10605b1f75b463c5bc07f3b04e6">&#9670;&nbsp;</a></span>app_retrieve_fault_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t app_retrieve_fault_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To retrieve the fault sticky status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns sticky fault status. </dd></dl>

</div>
</div>
<a id="ga4ae3f90a4aac402a773faf295e871e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae3f90a4aac402a773faf295e871e29">&#9670;&nbsp;</a></span>register_soln_function_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_soln_function_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapp__sln__handler__t.html">app_sln_handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function registers solution level functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">handler</td><td>pointer to solution handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga48b852c3817507e93ac4f0cc8f5f58ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b852c3817507e93ac4f0cc8f5f58ba">&#9670;&nbsp;</a></span>app_vdm_layer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_vdm_layer_reset </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts alternate mode layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the alternate mode resetted, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3fe0ced862d3cbf35b36334f47490339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe0ced862d3cbf35b36334f47490339">&#9670;&nbsp;</a></span>app_is_typec_attached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_typec_attached </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status of Type-C attach on all Type-C ports. </p>
<dl class="section return"><dt>Returns</dt><dd>True if any port is attached. False if all ports are unattached. </dd></dl>

</div>
</div>
<a id="ga41a79606a8a811589791b10712774b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a79606a8a811589791b10712774b85">&#9670;&nbsp;</a></span>pd_vbat_gnd_scp_cbk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_vbat_gnd_scp_cbk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function from interrupt handler to handle VBAT-GND SCP fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8da3d9d084dd05dbaa510b065198b6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da3d9d084dd05dbaa510b065198b6b8">&#9670;&nbsp;</a></span>pd_bb_ilim_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_bb_ilim_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function from interrupt handler to handle buck-boost inductor current limit fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a90b6242e88c2affb0817cff513751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a90b6242e88c2affb0817cff513751e">&#9670;&nbsp;</a></span>pd_brown_out_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_brown_out_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for VDDD regulator brown out fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab9f3f3e4de83a213874c00f309b1751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9f3f3e4de83a213874c00f309b1751">&#9670;&nbsp;</a></span>pd_vreg_inrush_det_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_vreg_inrush_det_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for VDDD regulator inrush current fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafdfb8d6bfce9507aea95f3f5451a7789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfb8d6bfce9507aea95f3f5451a7789">&#9670;&nbsp;</a></span>bc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the Battery Charging block. </p>
<p>This should be called one time only at system startup for each port on which the BC state machine needs to run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gafae1304bc5281a4decfa9c205d720a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae1304bc5281a4decfa9c205d720a47">&#9670;&nbsp;</a></span>bc_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cy_stc_legacy_charging_cfg_t* bc_get_config </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the current Battery Charging configuration. </p>
<p>If the LEGACY_DYN_CFG_ENABLE macro is enabled, then this returns the latest configuration. If not, returns the configuration structure from the configuration table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to current configuration data. This should not be modified by the caller. </dd></dl>

</div>
</div>
<a id="ga83c842c6a36610c26e86156463f956e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83c842c6a36610c26e86156463f956e1">&#9670;&nbsp;</a></span>bc_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_start </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a>&#160;</td>
          <td class="paramname"><em>port_role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the Battery Charging block with desired configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">port_role</td><td>Battery Charging port power role. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="ga08bb91b4849ec00a7feed096d9e31dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bb91b4849ec00a7feed096d9e31dce">&#9670;&nbsp;</a></span>bc_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_stop </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the Battery Charging block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gaa609c3d5f131d1259a9416fd5a7a5979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa609c3d5f131d1259a9416fd5a7a5979">&#9670;&nbsp;</a></span>bc_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether the BC module is active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the BC module is running, false otherwise. </dd></dl>

</div>
</div>
<a id="gab4b0ddf5ed205702d4628341428a3bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b0ddf5ed205702d4628341428a3bf4">&#9670;&nbsp;</a></span>bc_fsm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_fsm </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the Battery Charging block state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gaeddb10ad3d52f33172877e7b46b7611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeddb10ad3d52f33172877e7b46b7611a">&#9670;&nbsp;</a></span>bc_port_is_cdp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_port_is_cdp </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the port is currently functioning as a CDP (Charging Downstream Port). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is CDP, false otherwise. </dd></dl>

</div>
</div>
<a id="gae90d6d317d6183bc5e277a66a3e9de18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae90d6d317d6183bc5e277a66a3e9de18">&#9670;&nbsp;</a></span>bc_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_sleep </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function puts the Battery Charging block to sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the sleep is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3638da0a0c79743d5db6127741635079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3638da0a0c79743d5db6127741635079">&#9670;&nbsp;</a></span>bc_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function wakes up the Battery Charging block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if wakeup successful, false otherwise </dd></dl>

</div>
</div>
<a id="ga1be37ea9b028a57c60684196e3fcf905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be37ea9b028a57c60684196e3fcf905">&#9670;&nbsp;</a></span>bc_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__group__ccgxAppCommon.html#structbc__status__t">bc_status_t</a>* bc_get_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the current status of the BC state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to BC status. The structure must not be modified by caller. </dd></dl>

</div>
</div>
<a id="gaa8eb59136a5bc414a24d202a88ab500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8eb59136a5bc414a24d202a88ab500b">&#9670;&nbsp;</a></span>bc_pd_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_pd_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles events from USB-PD Device Policy Manager. </p>
<p>This event handler is used call the bc_start and bc_stop functions to enable/disable the BC state machine at appropriate times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt</td><td>PD event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad52979fd63b3499dfd069ba41d2bf28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52979fd63b3499dfd069ba41d2bf28a">&#9670;&nbsp;</a></span>bc_set_bc_evt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_set_bc_evt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evt_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets an event status for the BC state machine to process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt_mask</td><td>Event Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga736c168139e927c108d7ef55e90fc7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736c168139e927c108d7ef55e90fc7a9">&#9670;&nbsp;</a></span>bc_clear_bc_evt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_clear_bc_evt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evt_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears one or more BC events after the state machine has dealt with them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt_mask</td><td>Event Mask to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3a9699353dc54d34ea5dce1c71b0466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9699353dc54d34ea5dce1c71b0466c">&#9670;&nbsp;</a></span>ccg_get_system_max_pdp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_system_max_pdp </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the port PDP value. </p>
<p>If PD3.0 is supported, then the value returned will the PDP value from the extended source cap If PD3.0 is not supported, then the preconfigured PDP value will be returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>System PDP </dd></dl>

</div>
</div>
<a id="gab5d2d443f2be2f1b549e8835870ddf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d2d443f2be2f1b549e8835870ddf95">&#9670;&nbsp;</a></span>qc_set_cf_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qc_set_cf_limit </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables Current Foldback on the port when in QC mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9aa42ffefc5ac3d753b11847cb398fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa42ffefc5ac3d753b11847cb398fab">&#9670;&nbsp;</a></span>bc_afc_form_vi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_afc_form_vi </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function forms the new AFC source capabilities based on the power passed. </p>
<p>The number of source caps for AFC will be same as that configured in the table. This function does not modify the voltage value of the source cap in the config table. The current will be updated based on the power value and the AFC voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gabcee615842c5c62ebf8d36e83a919afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcee615842c5c62ebf8d36e83a919afe">&#9670;&nbsp;</a></span>bc_12_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bc_12_get_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current BC 1.2 status for a PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BC 1.2 status. </dd></dl>

</div>
</div>
<a id="ga0755713453a2b8aed13e4e11ae94354c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0755713453a2b8aed13e4e11ae94354c">&#9670;&nbsp;</a></span>bc_is_qc_afc_charging_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_qc_afc_charging_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether the QC or AFC charging modes are active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if QC or AFC charging modes are active, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf9f0a988f1e8c31a092c4f2c45256ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f0a988f1e8c31a092c4f2c45256ad7">&#9670;&nbsp;</a></span>bc_is_bc_charging_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_bc_charging_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether legacy charging modes are active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if legacy charging modes are active, false otherwise. </dd></dl>

</div>
</div>
<a id="ga92ebf8bad9d327493c62bdf056fd2585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ebf8bad9d327493c62bdf056fd2585">&#9670;&nbsp;</a></span>bc_is_bc_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_bc_connected </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether legacy charging connect negotiated or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if legacy charging connect is negotiated, false otherwise. </dd></dl>

</div>
</div>
<a id="gae2b8bb762de654cf691bfa2d4910b373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b8bb762de654cf691bfa2d4910b373">&#9670;&nbsp;</a></span>gpio_set_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the GPIO to the required state. </p>
<p>This function updates the output state of a GPIO pin. The API does not do any error check and will just update the output state. It is the caller's responsibility to ensure that the HSIOM and drive mode settings for the pin have been selected as required.</p>
<p>Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be updated. </td></tr>
    <tr><td class="paramname">value</td><td>Value to drive on the pin: 0=LOW, 1=HIGH.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon.html#ga05d2ba473562725e5d2f2216f63dc504" title="Select the IO mode for a CCG device IO. ">hsiom_set_config</a> </dd>
<dd>
<a class="el" href="group__group__ccgxAppCommon.html#gac81d9271ce686992981a09ab31509c0f" title="Configure the GPIO with the desired drive mode. ">gpio_set_drv_mode</a> </dd></dl>

</div>
</div>
<a id="gab4a340d82409454a45acd6068e69419b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4a340d82409454a45acd6068e69419b">&#9670;&nbsp;</a></span>gpio_read_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpio_read_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GPIO current state. </p>
<p>This API retrieves the current state of a pin, assuming it has been configured as a GPIO. It is the caller's responsibility to ensure that the HSIOM and drive mode settings for the pin have been set correctly.</p>
<p>The API does not do any error check and will just read the GPIO state register. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current state of the pin.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon.html#ga05d2ba473562725e5d2f2216f63dc504" title="Select the IO mode for a CCG device IO. ">hsiom_set_config</a> </dd>
<dd>
<a class="el" href="group__group__ccgxAppCommon.html#gac81d9271ce686992981a09ab31509c0f" title="Configure the GPIO with the desired drive mode. ">gpio_set_drv_mode</a> </dd></dl>

</div>
</div>
<a id="gac81d9271ce686992981a09ab31509c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81d9271ce686992981a09ab31509c0f">&#9670;&nbsp;</a></span>gpio_set_drv_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_drv_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a>&#160;</td>
          <td class="paramname"><em>drv_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the GPIO with the desired drive mode. </p>
<p>This API updates the drive mode for the selected CCG device IO. The API does not do any error check and will just set the drive mode of GPIO. The caller should ensure that the HSIOM setting for the pin has been selected correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">drv_mode</td><td>Desired drive mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga061aa6d28ccf3abfd22e9add75199b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061aa6d28ccf3abfd22e9add75199b9c">&#9670;&nbsp;</a></span>gpio_int_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_int_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the GPIO with the desired interrupt setting. </p>
<p>This API configures the interrupt mode for the specified GPIO. It does not do any error check and will just configure the GPIO interrupt setting. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">int_mode</td><td>Desired interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6213d69fa12f6d561f97cb17358d9b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6213d69fa12f6d561f97cb17358d9b40">&#9670;&nbsp;</a></span>gpio_register_intr_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t gpio_register_intr_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">gpio_intr_cb_t</a>&#160;</td>
          <td class="paramname"><em>intr_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback to be called when a GPIO interrupt associated with a specific port is triggered. </p>
<p>The gpio_int_set_config should be used to configure the desired interrupts for each of the relevant pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>GPIO port on which interrupts are to be updated. </td></tr>
    <tr><td class="paramname">intr_cb</td><td>Pointer to callback function to be called on interrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS on success, appropriate error code otherwise. </dd></dl>

</div>
</div>
<a id="ga05d2ba473562725e5d2f2216f63dc504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d2ba473562725e5d2f2216f63dc504">&#9670;&nbsp;</a></span>hsiom_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsiom_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a>&#160;</td>
          <td class="paramname"><em>hsiom_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the IO mode for a CCG device IO. </p>
<p>This API configures the IO mode for a CCG device IO. It does not do any error check and will just set the HSIOM configuration for the GPIO. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">hsiom_mode</td><td>Desired IO mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577" title="Various IO matrix configuration modes. ">hsiom_mode_t</a> </dd></dl>

</div>
</div>
<a id="gae5a37e81fc0c0bf20c918954056bfa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a37e81fc0c0bf20c918954056bfa83">&#9670;&nbsp;</a></span>gpio_hsiom_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_hsiom_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a>&#160;</td>
          <td class="paramname"><em>hsiom_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a>&#160;</td>
          <td class="paramname"><em>drv_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single function for complete configuration of a CCG IO. </p>
<p>This is a single API which can be used to configure the IO mode, the drive mode and the current value of a CCG device IO. No error checks are performed, and the caller should ensure that the settings provided are valid for the selected IO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">hsiom_mode</td><td>Desired IO mode. </td></tr>
    <tr><td class="paramname">drv_mode</td><td>Desired drive mode. </td></tr>
    <tr><td class="paramname">value</td><td>Desired output state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac5e3a8c83eb6bae572d7e18cea59edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e3a8c83eb6bae572d7e18cea59edd3">&#9670;&nbsp;</a></span>gpio_set_lvttl_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_lvttl_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the input buffer voltage for a port to LVTTL. </p>
<p>This API sets the input buffer voltage for a complete CCG device port to LVTTL levels. This is required to be set for ports that include the IOs used for the I2C based HPI interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>IO port to be configured for LVTTL levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga7ea5408d9cf9f6cdeac7eaddaedf39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">&#9670;&nbsp;</a></span>gpio_get_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpio_get_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the interrupt status on a specific GPIO. </p>
<p>This function checks whether there are any active interrupts on the specified GPIO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interrupt is active, false otherwise. </dd></dl>

</div>
</div>
<a id="ga68bf50943ae651b4a773d6ada7d8da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68bf50943ae651b4a773d6ada7d8da48">&#9670;&nbsp;</a></span>gpio_clear_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_clear_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear interrupt status on the specified GPIO. </p>
<p>This function clears any active interrupts on the specified GPIO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga65daf9463b0aa6902604e565da854174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65daf9463b0aa6902604e565da854174">&#9670;&nbsp;</a></span>lpm_gpio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the LPM Functionality over GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Chip Enable Pin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gab35b615f84e123c6f244a3f00f83bfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35b615f84e123c6f244a3f00f83bfe9">&#9670;&nbsp;</a></span>lpm_gpio_get_lpm_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lpm_gpio_get_lpm_stat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To get the LPM Status. </p>
<dl class="section return"><dt>Returns</dt><dd>Status of LPM. </dd></dl>

</div>
</div>
<a id="ga74ed132647d48c038a2b8f5fb663c97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ed132647d48c038a2b8f5fb663c97d">&#9670;&nbsp;</a></span>lpm_gpio_clr_lpm_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_clr_lpm_stat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To clear the LPM Status. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6caaa2a2399383668c403e694d6d5758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6caaa2a2399383668c403e694d6d5758">&#9670;&nbsp;</a></span>lpm_gpio_set_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_set_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a>&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Set the Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>interrupt type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga19fbabfd67fd86ce7060a960b5c43d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19fbabfd67fd86ce7060a960b5c43d80">&#9670;&nbsp;</a></span>lpm_gpio_clr_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_clr_intr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Clear the Interrupt. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga464ab91815a8c55916d179cb924d6103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464ab91815a8c55916d179cb924d6103">&#9670;&nbsp;</a></span>lpm_gpio_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lpm_gpio_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Read the LPM_GPIO. </p>
<dl class="section return"><dt>Returns</dt><dd>gpio status </dd></dl>

</div>
</div>
<a id="ga0c9ba09522c7b06b4f4b78965af64cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c9ba09522c7b06b4f4b78965af64cfc">&#9670;&nbsp;</a></span>eval_src_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_src_cap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>srcCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the PD stack to allow the application logic to evaluate the Source Capabilities received from the port partner and generate the desired request. </p>
<p>The request object is expected to be passed back to the stack through the app_resp_handler() callback.</p>
<p>The default implementation of this function matches each of the received source PDOs against the active sink capabilities; and then selects the source PDO that can deliver the maximum power to the system as a sink.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the CCG6 device, the eval_src_cap function is executed from ROM and hence changes in this function will not affect the policy engine behavior. The <a class="el" href="group__group__ccgxAppCommon.html#ga92f950d9ddc50d8a7d3f69a23de108f1" title="This function is only applicable in the case of the CCG6 device, and can be used by the application l...">app_update_rdo()</a> function should be used to update the request object in this case.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">srcCap</td><td>Pointer to PD packet which contains source capabilities. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1aa9ecc53e672ff08c97ea9beb3905ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa9ecc53e672ff08c97ea9beb3905ed">&#9670;&nbsp;</a></span>eval_rdo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_rdo </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t&#160;</td>
          <td class="paramname"><em>rdo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the PD stack to allow the application to evaluate a power request data object received from the port partner and decide whether it should be satisfied. </p>
<p>The response to the request should be passed back to the stack through the app_resp_handler() callback.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the CCG6 device, the eval_rdo function is executed from ROM and hence changes in this function will not affect the policy engine behavior. The application is expected to update the source capabilities registered with the PD stack based on the current system status.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">rdo</td><td>The request data object received. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga92f950d9ddc50d8a7d3f69a23de108f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f950d9ddc50d8a7d3f69a23de108f1">&#9670;&nbsp;</a></span>app_update_rdo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_rdo </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>srcCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t *&#160;</td>
          <td class="paramname"><em>appResp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only applicable in the case of the CCG6 device, and can be used by the application logic to modify the RDO generated by the ROM-ed version of the eval_src_cap function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">srcCap</td><td>Pointer to PD packet which contains source capabilities. </td></tr>
    <tr><td class="paramname">appResp</td><td>Response containing the updated RDO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab3817297cc85653d6201cd1e48159ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3817297cc85653d6201cd1e48159ada">&#9670;&nbsp;</a></span>psrc_set_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_set_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the VBus source voltage to the desired value. </p>
<p>It also updates the voltage thresholds associated with protection schemes such as OVP and UVP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Voltage in mV units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1881bbbc0107059d70bc39920a6738f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1881bbbc0107059d70bc39920a6738f2">&#9670;&nbsp;</a></span>psrc_get_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t psrc_get_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the VBus source voltage that is currently configured. </p>
<p>This is different from the <a class="el" href="group__group__ccgxAppCommon.html#ga0c527850e02f68c9c1072b58921fe533" title="This function return current VBUS voltage in mV. ">vbus_get_value()</a> function which measures the actual VBus voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Voltage in mV units. </dd></dl>

</div>
</div>
<a id="gad93e96d009a6e6717ffef86a79f7d223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93e96d009a6e6717ffef86a79f7d223">&#9670;&nbsp;</a></span>psrc_set_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_set_current </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cur_10mA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the VBus source current limit. </p>
<p>The current limits are used to configure the current sensing circuits to trigger fault indication in case of overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cur_10mA</td><td>Current in 10mA units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae078c31aa1f7fce6bba129df400dc862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae078c31aa1f7fce6bba129df400dc862">&#9670;&nbsp;</a></span>psrc_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_pwr_ready_cbk_t&#160;</td>
          <td class="paramname"><em>pwr_ready_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the VBus power supply. </p>
<p>The voltage and current to be supplied would have been specified through the <a class="el" href="group__group__ccgxAppCommon.html#gab3817297cc85653d6201cd1e48159ada" title="This function sets the VBus source voltage to the desired value. ">psrc_set_voltage()</a> and <a class="el" href="group__group__ccgxAppCommon.html#gad93e96d009a6e6717ffef86a79f7d223" title="This function sets the VBus source current limit. ">psrc_set_current()</a> calls before the supply is enabled. The function returns as soon as the supply enable operation has been started. The pwr_ready_handler is expected to be called once VBus voltage has stabilized at the desired level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pwr_ready_handler</td><td>Application handler callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae522dada2eb76d90d46a6f428a31eff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae522dada2eb76d90d46a6f428a31eff1">&#9670;&nbsp;</a></span>psrc_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_pwr_ready_cbk_t&#160;</td>
          <td class="paramname"><em>pwr_ready_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the VBus power supply. </p>
<p>If a non-NULL pwr_ready_handler callback is specified, the function can return after starting the VBus disable operation. The callback will be called once the VBus voltage has been safely brought to vSafe0V. If the callback is NULL, the function is expected to return after shutting down the supply without initiating any VBus discharge sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pwr_ready_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad019aef09ac99508d3cca4d2315b7df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad019aef09ac99508d3cca4d2315b7df7">&#9670;&nbsp;</a></span>ccg_sensor_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the sensor check block. </p>
<p>This should be called one time only at system startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae913d9eb9a79f913e28c8d34de043686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae913d9eb9a79f913e28c8d34de043686">&#9670;&nbsp;</a></span>ccg_sensor_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccg_sensor_is_idle </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Facilitates to know if sensor check module is idle. </p>
<p>System sleep is allowed in idle state only. In idle state, ccg_ls_task() can run in lower frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if sensor check module is idle. True otherwise. </dd></dl>

</div>
</div>
<a id="gaea471cf36a082dfaecfa15dc4b1028c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea471cf36a082dfaecfa15dc4b1028c3">&#9670;&nbsp;</a></span>ccg_sensor_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_check </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Facilitates caller to update system operating condition to the operating condition indicated by VIN and temperature of the sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga6b142ab3e283161f9e168c898afce86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b142ab3e283161f9e168c898afce86a">&#9670;&nbsp;</a></span>ccg_sensor_debounce_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_debounce_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the debounce related checks. </p>
<p>This will be called continuously, but will be executed only if the flag is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga546096050c83925d0c4099621f3486c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546096050c83925d0c4099621f3486c0">&#9670;&nbsp;</a></span>ccg_sensor_temp_ec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t ccg_sensor_temp_ec </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current sensor temperature. </p>
<p>This will be called by the EC to know the temperature of the sensors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">buffer</td><td>to which the information will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or Failure depending on whether temperature based throttling is enabled in the firmware </dd></dl>

</div>
</div>
<a id="ga2cfae9d8db4a74aed03c538607b6b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfae9d8db4a74aed03c538607b6b1a9">&#9670;&nbsp;</a></span>ccg_get_battery_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ccg_get_battery_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts VIN(Battery) voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Voltage in millivolts. </dd></dl>

</div>
</div>
<a id="gad1372cb404e2fdc0104e55166417b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1372cb404e2fdc0104e55166417b5f9">&#9670;&nbsp;</a></span>ccg_get_sys_oc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_sys_oc </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gad456bb3be6173dae2997daf53c4aabc8">CCG_OC_BUFFER_DATE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>oc_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts undebounced OC specific information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">oc_buffer</td><td>Placeholder for undebounced OC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Undebounced system OC at this point of time. </dd></dl>

</div>
</div>
<a id="ga61443c0e3f64be9b85774528c6776eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61443c0e3f64be9b85774528c6776eee">&#9670;&nbsp;</a></span>ccg_set_sensor_sleep_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_set_sensor_sleep_mode </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the VIN OV/UV comparators for sleep mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3e5f3c378ced3b9a9b88a864380db5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e5f3c378ced3b9a9b88a864380db5a6">&#9670;&nbsp;</a></span>eval_dr_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_dr_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates Data role swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga28f7b458a4b35ab3a85dfec4aa969001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f7b458a4b35ab3a85dfec4aa969001">&#9670;&nbsp;</a></span>eval_pr_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_pr_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates Power role swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga35bebef1cf20542c23c68e15ab2394fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35bebef1cf20542c23c68e15ab2394fe">&#9670;&nbsp;</a></span>eval_vconn_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_vconn_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates VConn swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga606d6f10e4bf215d5ecbae3ac5422220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606d6f10e4bf215d5ecbae3ac5422220">&#9670;&nbsp;</a></span>ccg_volt_temp_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_volt_temp_map </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>therm_volt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the thermal voltage read from thermistor to temperature value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">therm_volt</td><td>The thermal voltage that must be mapped to temperature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The temperature value corresponding to the thermal voltage read </dd></dl>

</div>
</div>
<a id="gab10bbe4117fc4502f3ffe303a46a1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10bbe4117fc4502f3ffe303a46a1819">&#9670;&nbsp;</a></span>ccg_get_sensor_temperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_sensor_temperature </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sensor_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the temperature of the specified sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">sensor_id</td><td>The index of the sensor to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The temperature value corresponding to the thermal voltage read </dd></dl>

</div>
</div>
<a id="ga81e2b20a4fb4669bdb692d782124c94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e2b20a4fb4669bdb692d782124c94e">&#9670;&nbsp;</a></span>register_thermistor_mapping_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_thermistor_mapping_table </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>volt_temp_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the thermal voltage read from thermistor to temperature value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">volt_temp_table</td><td>Pointer to the table to be used for thermal voltage to temperature mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2b5edab6846405e6f18f4d584bf20d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5edab6846405e6f18f4d584bf20d42">&#9670;&nbsp;</a></span>uvdm_get_cur_nb_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a> uvdm_get_cur_nb_cmd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current non blocking command opcode. </p>
<p>This function returns the opcode of current Non Blocking UVDM Command which can be used to form the response VDM.</p>
<dl class="section return"><dt>Returns</dt><dd>uvdm_cmd_opcode_t UVDM Command Opcode </dd></dl>

</div>
</div>
<a id="ga88917f34345b4c2ffbd7f05e004cbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88917f34345b4c2ffbd7f05e004cbbcb">&#9670;&nbsp;</a></span>uvdm_reset_nb_cmd_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_reset_nb_cmd_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets internal state and trackers related to Non Blocking flash write operation at the end of write operation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa6f4e6875801da6056c0c87f2785cae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6f4e6875801da6056c0c87f2785cae8">&#9670;&nbsp;</a></span>uvdm_enter_cy_alt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_enter_cy_alt_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Mode Entry Handler This function is called when CCG enters CY Flashing Alternate mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaee0e712a6dac921e9a12c1519f162132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0e712a6dac921e9a12c1519f162132">&#9670;&nbsp;</a></span>uvdm_exit_cy_alt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_exit_cy_alt_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Mode Exit Handler This function is called when CCG exits CY Flashing Alternate mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga48049492908c61b5a2bcb7869611cf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48049492908c61b5a2bcb7869611cf89">&#9670;&nbsp;</a></span>uvdm_get_flashing_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvdm_get_flashing_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CY Flashing Mode Status This function returns the current state of CY Flashing Alternate Mode. </p>
<dl class="section return"><dt>Returns</dt><dd>true if CY Flashing Mode active, false otherwise. </dd></dl>

</div>
</div>
<a id="gae932229b8c737c4f5f9605d19c64c439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae932229b8c737c4f5f9605d19c64c439">&#9670;&nbsp;</a></span>uvdm_handle_device_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t uvdm_handle_device_reset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reset_sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle Device Reset Command This function handles device Reset command. </p>
<p>Device Reset handling is application specific and hence this routine shall be implemented at Solution level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reset_sig</td><td>Type of Reset: Device Reset, Jump to bootloader or Jump to Alt image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_pdstack_status_t </dd></dl>

</div>
</div>
<a id="ga45a21400ab342fd3552ed6791a834f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a21400ab342fd3552ed6791a834f88">&#9670;&nbsp;</a></span>uvdm_handle_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> uvdm_handle_cmd </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t **&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">flash_cbk_t&#160;</td>
          <td class="paramname"><em>flash_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Alternate Mode UVDM Command Handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to pdstack </td></tr>
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response </td></tr>
    <tr><td class="paramname">flash_cb</td><td>Callback function for Non Blocking Flash Write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="gace292f2968c8a0fbe52bd5fb817219d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace292f2968c8a0fbe52bd5fb817219d9">&#9670;&nbsp;</a></span>uvdm_qc_pps_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> uvdm_qc_pps_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t **&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles all QC 5.0/4.0 Protocol UVDM commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="ga9937839e0df56ab2ae92677a3c4fc89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9937839e0df56ab2ae92677a3c4fc89c">&#9670;&nbsp;</a></span>sln_flashing_uvdm_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> sln_flashing_uvdm_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t *&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_status_t *&#160;</td>
          <td class="paramname"><em>response_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flashing Alternate Mode UVDM Command solution space extension handler. </p>
<p>This function is invoked by the flashing UVDM handler if the SLN_FLASHING_UVDM_HANDLER_ENABLE is enabled and the standard handler is not able to resolve.</p>
<p>NOTE: Since the function is for extending avaiable solution in the standard handler, the data structures are re-used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet (allocation done in uvdm.c) </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response </td></tr>
    <tr><td class="paramname">response_code</td><td>Response status code to be returned in the UVDM response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="gaba9d243d72311578fc26927b0d8b3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba9d243d72311578fc26927b0d8b3d18">&#9670;&nbsp;</a></span>pwm_get_duty_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pwm_get_duty_cycle </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vbus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function computes PWM duty cycle needed to generate requested VBUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbus</td><td>The voltage to set to in mV units </td></tr>
    <tr><td class="paramname">min_volt</td><td>Minimum VBUS as per design in mv </td></tr>
    <tr><td class="paramname">max_volt</td><td>Maximum VBUS as per design in mv </td></tr>
    <tr><td class="paramname">pwm_period</td><td>Period of the PWM signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM duty cycle in terms of PWM on time. </dd></dl>

</div>
</div>
<a id="ga0176c9ee7a447e6d05e118ec148581c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0176c9ee7a447e6d05e118ec148581c3">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_turn_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_turn_on </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the PWM signal that turns VBus ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1dbe2b31bf4f30e721228591b8420357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbe2b31bf4f30e721228591b8420357">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_turn_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_turn_off </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function disables the PWM signal thus turning VBus OFF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2bd5743b05e845340eea6f5c7054c0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd5743b05e845340eea6f5c7054c0e0">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_set_volt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_set_volt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the Type-C VBUS voltage to requested level using PWM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>The voltage to set to in mV units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gabcd12abd4dc2a695f0aca4fcc9e9b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd12abd4dc2a695f0aca4fcc9e9b9be">&#9670;&nbsp;</a></span>vbus_ctrl_fb_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the Type-C VBUS voltage feedback logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaf7e37244c8eb9e2b5a85195fb5aa04c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e37244c8eb9e2b5a85195fb5aa04c1">&#9670;&nbsp;</a></span>vbus_ctrl_fb_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function disables the Type-C VBUS voltage feedback logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5534b8c6f4249d42f6719791ed55ff38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5534b8c6f4249d42f6719791ed55ff38">&#9670;&nbsp;</a></span>vbus_ctrl_fb_set_volt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_set_volt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the Type-C VBUS voltage to requested level using FB (feedback). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>The voltage to set to in mV units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga7c5f522c241cad2d51bac5a524312fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5f522c241cad2d51bac5a524312fe7">&#9670;&nbsp;</a></span>vbus_ctrl_set_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vbus_ctrl_set_is_idle </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns whether the vbus voltage transition is over or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vbus transition is over, otherwise False. </dd></dl>

</div>
</div>
<a id="ga7d395b4a3c133de574b7362d20540c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d395b4a3c133de574b7362d20540c8b">&#9670;&nbsp;</a></span>vbus_ctrl_get_trim_idac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vbus_ctrl_get_trim_idac </td>
          <td>(</td>
          <td class="paramtype">cy_stc_usbpd_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns trimmed IDAC value for the required voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mv</td><td>Required source voltage in mV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idac Signed IDAC value for the requested voltage</dd></dl>
<p><b>Applicable devices:</b> CCG3PA, CCG3PA2, PAG1S, CCG7D, CCG7S. </p>

</div>
</div>
<a id="ga3d7b269e24c8f4fec661273d02586fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d7b269e24c8f4fec661273d02586fa3">&#9670;&nbsp;</a></span>vdm_data_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_data_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the VDM data from the configuration table. </p>
<p>This function retrieves the VDM data (for CCG as UFP) that is stored in the configuration table and stores it in the run-time data structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae954f67f0c7fc0fa4d0b77e86d39efa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae954f67f0c7fc0fa4d0b77e86d39efa9">&#9670;&nbsp;</a></span>vdm_update_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_update_data </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id_vdo_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>id_vdo_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>svid_vdo_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>svid_vdo_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mode_resp_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mode_resp_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the VDM data for CCG to be changed. </p>
<p>This function allows the user to change the VDM responses that CCG sends for D_ID, D_SVID and D_MODE requests. The default responses are taken from the configuration table. This function allows the user to change the response data. The caller is responsible to ensure that the responses are not changed while CCG is already in contract as a UFP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">id_vdo_cnt</td><td>Number of VDOs in the D_ID response. </td></tr>
    <tr><td class="paramname">id_vdo_p</td><td>Pointer to the actual D_ID response in memory. </td></tr>
    <tr><td class="paramname">svid_vdo_cnt</td><td>Number of VDOs in the D_SVID response. Should be less than 8. </td></tr>
    <tr><td class="paramname">svid_vdo_p</td><td>Pointer to the actual D_SVID response in memory. </td></tr>
    <tr><td class="paramname">mode_resp_len</td><td>Total length of mode response. This includes the D_MODE responses for each supported SVID, along with the corresponding header fields. </td></tr>
    <tr><td class="paramname">mode_resp_p</td><td>Pointer to all of the mode responses in memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4b760125b3e49c10b90e064750acb68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b760125b3e49c10b90e064750acb68e">&#9670;&nbsp;</a></span>eval_vdm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_vdm </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>vdm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_vdm_resp_cbk_t&#160;</td>
          <td class="paramname"><em>vdm_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is responsible for analyzing and processing received VDM. </p>
<p>This function also makes a decision about necessity of response to the received VDM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">vdm</td><td>Pointer to pd packet which contains received VDM. </td></tr>
    <tr><td class="paramname">vdm_resp_handler</td><td>VDM handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4d682bedad7997cf296ac7b472ccb4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d682bedad7997cf296ac7b472ccb4e5">&#9670;&nbsp;</a></span>eval_enter_usb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_enter_usb </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>eudo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to evaluate an Enter_USB request and report whether it should be accepted or rejected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">eudo</td><td>Pointer to the Enter_USB packet. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Response callback through which the response is passed to the PD stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga07f91bf53ad0b7c9ce8bc3727ef8512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07f91bf53ad0b7c9ce8bc3727ef8512d">&#9670;&nbsp;</a></span>vdm_assign_port_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_assign_port_num </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign unique port number in a CCG3PA multiport system. </p>
<p>This port number overrides the port number configured in configuration table. DFP VDO in discover identity response shall respond with this port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5a7f98716771b456abbe7bd132d8255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7f98716771b456abbe7bd132d8255f">&#9670;&nbsp;</a></span>boot_validate_configtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_validate_configtable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>table_p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the configuration table specified. </p>
<p>Each copy of CCGx firmware on the device flash contains an embedded configuration table that defines the runtime behaviour of the CCGx device. This function checks whether the configuration table located at the specified location is valid (has valid signature and checksum).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_p</td><td>Pointer to the configuration table to be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS if the table is valid, CCG_STAT_FAILURE otherwise. </dd></dl>

</div>
</div>
<a id="ga1edb32e1e45d388147185b053875f8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edb32e1e45d388147185b053875f8fe">&#9670;&nbsp;</a></span>boot_validate_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_validate_fw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td>
          <td class="paramname"><em>fw_metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the firmware image associated with the given metadata. </p>
<p>This function validates the firmware binary associated with the metadata specified in the fw_metadata parameter. The validity check includes checks for signature, location, size and checksum. This function internally performs validation of the embedded configuration table using the boot_validate_configtable function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw_metadata</td><td>Pointer to metadata table of the FW which has to be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS if the firmware is valid, CCG_STAT_FAILURE otherwise. </dd></dl>

</div>
</div>
<a id="ga861588454fc735f940e5cdaaaa65cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861588454fc735f940e5cdaaaa65cce9">&#9670;&nbsp;</a></span>boot_handle_validate_fw_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_handle_validate_fw_cmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a>&#160;</td>
          <td class="paramname"><em>fw_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the VALIDATE_FW command from HPI or UVDM. </p>
<p>This API handles the VALIDATE_FW command received through the HPI or UVDM interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw_mode</td><td>Firmware binary id: 1 for FW1 and 2 for FW2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating the validity of the firmware. </dd></dl>

</div>
</div>
<a id="ga86165e9d25f534b61706bce73087523a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86165e9d25f534b61706bce73087523a">&#9670;&nbsp;</a></span>boot_get_wait_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t boot_get_wait_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boot-wait delay configured for the application. </p>
<p>This function identifies the boot-wait delay required by checking the firmware metadata.</p>
<dl class="section return"><dt>Returns</dt><dd>Boot-wait delay in milliseconds. </dd></dl>

</div>
</div>
<a id="gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">&#9670;&nbsp;</a></span>boot_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boot_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the firmware binary to be loaded. </p>
<p>This function is only used in the CCGx boot-loader, and implements the main start-up logic of the boot-loader. The function validates the two firmware binaries in device flash, and identifies the binary to be loaded. If neither binary is valid, the function returns false notifying the caller to continue in boot-loader mode.</p>
<dl class="section return"><dt>Returns</dt><dd>true if firmware load is allowed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga12781921cca4e29d0c7516cc7431da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12781921cca4e29d0c7516cc7431da31">&#9670;&nbsp;</a></span>boot_check_for_valid_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_check_for_valid_fw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the presence of alternate firmware waiting to be validated. </p>
<p>This function checks whether the CCGx device flash contains an alternate firmware binary which is waiting to be validated. This can happen if a firmware update happened during the last power up of the device, and the binary is yet to be validated and made active. The active firmware will make use of the pseudo metadata in flash to identify the alternate firmware, validate it and activate it by updating the actual firmware metadata.</p>
<p>Please refer to the CCGx boot sequence description in the firmware guide for a more detailed description of the boot procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga8c99ecc08d4d9906ab7cea73c403241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c99ecc08d4d9906ab7cea73c403241d">&#9670;&nbsp;</a></span>iecs_check_for_valid_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iecs_check_for_valid_fw </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>first_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a alternate firmware according to IECS SFWv command. </p>
<p>This function validate alternate firmware binary. EC update flash rows step by step without the first row and after that send SFWv command to validate FW signature. if a firmware signature is correct function writes a first row of a image to flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_row</td><td>Poineter to the first row of FW image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga734e1c7b35b3b51709c1997cf4b27adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga734e1c7b35b3b51709c1997cf4b27adc">&#9670;&nbsp;</a></span>get_boot_mode_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t">fw_img_status_t</a> get_boot_mode_reason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitmap containing the reason for boot mode. </p>
<p>This function returns the bitmap value that is to be stored in the BOOT_MODE_REASON HPI register, which identifies the validity of the two firmware binaries. The validation of the firmware is expected to have been completed earlier through the boot_start function. This function only retrieves the status stored during the validation procedure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t" title="Boot mode reason structure. ">fw_img_status_t</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Boot mode reason bitmap. </dd></dl>

</div>
</div>
<a id="ga06f1bc2f59ba8e0476dd349d1d2970eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f1bc2f59ba8e0476dd349d1d2970eb">&#9670;&nbsp;</a></span>boot_jump_to_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_jump_to_fw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer control to the firmware binary identified by boot_start. </p>
<p>This function is only used by the CCGx boot-loader. This transfers control to the firmware binary selected as the boot target by the boot_start function. This is expected to be called after the boot-wait window has elapsed.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae7d02f78bb5df076263df291bb175ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d02f78bb5df076263df291bb175ea0">&#9670;&nbsp;</a></span>boot_get_boot_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t boot_get_boot_seq </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>fwid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the boot sequence number value for the specified firmware image. </p>
<p>A boot sequence number field stored in the firmware metadata is used by the CCGx boot-loader to identify the firmware binary to be loaded. This function retrieves the sequence number associated with the specified firmware binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fwid</td><td>Firmware id whose sequence number is to be retrieved. 1 for FW1 and 2 for FW2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boot sequence number value if the firmware is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga9ea7548753e977c3e1509c663150b39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea7548753e977c3e1509c663150b39c">&#9670;&nbsp;</a></span>boot_update_fw_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_update_fw_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to validate firmware images and update image status. </p>
<p>This function is used to validate the firmware images in the CCG device flash and update their status in the image status / boot-mode reason field.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga92a19c1628a70d606e705085976c8c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a19c1628a70d606e705085976c8c3a">&#9670;&nbsp;</a></span>boot_jump_to_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_jump_to_app </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>appId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to jump from bootloader to application. </p>
<p>This function is used to validate the firmware images in the CCG device flash and update their status in the image status / boot-mode reason field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appId</td><td>application Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga333040c32b526560e0189685c2477943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga333040c32b526560e0189685c2477943">&#9670;&nbsp;</a></span>instrumentation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize data structures associated with application instrumentation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad367c15b42304176602a24ab5cc659a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad367c15b42304176602a24ab5cc659a8">&#9670;&nbsp;</a></span>instrumentation_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start any timers or tasks associated with application instrumentation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gafe5f4d31cceda3638f9d2c3831c34cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5f4d31cceda3638f9d2c3831c34cdc">&#9670;&nbsp;</a></span>instrumentation_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_task </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform tasks associated with application instrumentation. </p>
<p>The specific functionality implemented is user defined and can vary. </p><dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab8347fe4114de4120402ee8a63fce69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8347fe4114de4120402ee8a63fce69b">&#9670;&nbsp;</a></span>instrumentation_register_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_register_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gaa07a7ee21510d24dac6326ec163d8e3c">instrumentation_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register solution level callback function to be executed when instrumentation fault occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad8e95b70077dc7b63704262bff2cbf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e95b70077dc7b63704262bff2cbf0d">&#9670;&nbsp;</a></span>watchdog_timer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watchdog_timer_cb </td>
          <td>(</td>
          <td class="paramtype">cy_timer_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer callback to reset device if main loop has not been run as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer Id </td></tr>
    <tr><td class="paramname">callbackContext</td><td>Callback pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac15c4225e91f14e2f6a65b7364072218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac15c4225e91f14e2f6a65b7364072218">&#9670;&nbsp;</a></span>sys_set_device_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_set_device_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a>&#160;</td>
          <td class="paramname"><em>fw_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current firmware mode. </p>
<p>This function is used by the start-up logic to store the current firmware mode for the CCGx device.</p>
<p>This should not be used outside of the default start-up logic for the CCGx bootloader and firmware applications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw_mode</td><td>The active firmware mode to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gafcf3055e3da9c959dc80ddc470b6b55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf3055e3da9c959dc80ddc470b6b55f">&#9670;&nbsp;</a></span>sys_get_device_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a> sys_get_device_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current firmware mode. </p>
<p>This function retrieves the current firmware mode of the CCG device.</p>
<dl class="section return"><dt>Returns</dt><dd>The current firmware mode. </dd></dl>

</div>
</div>
<a id="gac6397ed1dc06c18b5cb4a9319d541fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6397ed1dc06c18b5cb4a9319d541fea">&#9670;&nbsp;</a></span>sys_get_boot_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sys_get_boot_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get bootloader version. </p>
<p>The bootloader version is stored at absolute address SYS_CCG_BOOT_VERSION_ADDRESS in device FLASH. This function returns a pointer to this version information.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the bootloader version information. </dd></dl>

</div>
</div>
<a id="gabdba5beea711269ed3f46634e94bc3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdba5beea711269ed3f46634e94bc3a7">&#9670;&nbsp;</a></span>sys_get_img1_fw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sys_get_img1_fw_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version for firmware image-1. </p>
<p>This function returns a pointer to the version information for firmware image-1 (FW1). The version is located at a fixed offset of CY_PD_FW_VERSION_OFFSET bytes from the start of the firmware binary.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the firmware image-1 version information. </dd></dl>

</div>
</div>
<a id="ga947940b9e622ee4149fbfaf274490e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947940b9e622ee4149fbfaf274490e89">&#9670;&nbsp;</a></span>sys_get_img2_fw_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* sys_get_img2_fw_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get version for firmware image-2. </p>
<p>This function returns a pointer to the version information for firmware image-2 (FW2). The version is located at a fixed offset of CY_PD_FW_VERSION_OFFSET bytes from the start of the firmware binary.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the firmware image-2 version information. </dd></dl>

</div>
</div>
<a id="gadb25d6f6fbd3f83cd52490a7f512036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb25d6f6fbd3f83cd52490a7f512036f">&#9670;&nbsp;</a></span>sys_get_fw_img1_start_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_fw_img1_start_addr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash start address of firmware image-1. </p>
<p>This function returns the flash address from where firmware image-1 (FW1) has been stored.</p>
<dl class="section return"><dt>Returns</dt><dd>Start address of firmware image-1. </dd></dl>

</div>
</div>
<a id="gab4e435a4db3c7f52b66028130122d1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4e435a4db3c7f52b66028130122d1f0">&#9670;&nbsp;</a></span>sys_get_fw_img2_start_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_fw_img2_start_addr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flash start address of firmware image-2. </p>
<p>This function returns the flash address from where firmware image-2 (FW2) has been stored.</p>
<dl class="section return"><dt>Returns</dt><dd>Start address of firmware image-2. </dd></dl>

</div>
</div>
<a id="ga05fc9cd3057ac95b0e49757f71e574ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fc9cd3057ac95b0e49757f71e574ae">&#9670;&nbsp;</a></span>sys_get_recent_fw_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sys_get_recent_fw_image </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the more recently update firmware image. </p>
<p>The CCG Bootloader uses this function to determine the more recently updated firmware image (from among FW1 and FW2) by comparing the sequence numbers of images which are stored in the firmware metadata table. The bootloader loads the most recently updated binary by default (even if its version is older than that of the other firmware binary).</p>
<dl class="section return"><dt>Returns</dt><dd>Firmware id: 1 for Image-1 and 2 for Image-2. </dd></dl>

</div>
</div>
<a id="gaf3269855f28bae98095f7438d6fdba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3269855f28bae98095f7438d6fdba14">&#9670;&nbsp;</a></span>sys_get_silicon_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_get_silicon_id </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>silicon_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Silicon ID of device. </p>
<p>This function retrieves the Silicon ID of the CCG device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silicon_id</td><td>Pointer to buffer to hold the Silicon ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga57a74c2da279eb11649cd6833b7a238f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a74c2da279eb11649cd6833b7a238f">&#9670;&nbsp;</a></span>get_silicon_revision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_silicon_revision </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns Silicon revision. </p>
<dl class="section return"><dt>Returns</dt><dd>Silicon revision B[7:4] - Major rev B[3:0] - Minor rev </dd></dl>

</div>
</div>
<a id="ga97534834ce00cff0659df470096e9ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97534834ce00cff0659df470096e9ee1">&#9670;&nbsp;</a></span>sys_get_custom_info_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_custom_info_addr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get start address of Customer info section. </p>
<p>This function returns the start address of Customer info section.</p>
<dl class="section return"><dt>Returns</dt><dd>Address of Customer info section. </dd></dl>

</div>
</div>
<a id="gaae9d856b58a5f1f45b2be1cad8aea0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae9d856b58a5f1f45b2be1cad8aea0ab">&#9670;&nbsp;</a></span>sys_get_bcdDevice_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sys_get_bcdDevice_version </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ver_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get bcdDevice version of device. </p>
<p>This function returns bcdDevice version for the device which can be used as part of D_ID response, secure boot checks etc. Format of bcdDevice version is documented in the fucntion body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ver_addr</td><td>Offset of version in Flash memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>16 bits bcdDevice version. </dd></dl>

</div>
</div>
<a id="ga0744c70187ce4c00822179005c6c0b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0744c70187ce4c00822179005c6c0b2b">&#9670;&nbsp;</a></span>i2c_scb_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a>&#160;</td>
          <td class="paramname"><em>clock_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a>&#160;</td>
          <td class="paramname"><em>cb_fun_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>scratch_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>scratch_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure one of the I2C blocks as required. </p>
<p>This API is used to enable and configure one of the I2C blocks for driver operation. Only I2C slave operation is currently supported by the driver as of now.</p>
<p>The I2C driver is agnostic of the actual data transfer protocol. It reads all data written by the master into a receive buffer provided by the protocol layer. A callback function is used to notify the protocol layer when the write is complete. The receive buffer provided should be big enough to hold the maximum amount of data that the master may provide in a write operation. If the write contains more data than the buffer can hold, the I2C driver will NAK the transaction.</p>
<p>Read requests from the I2C master are automatically delayed by clock stretching. A callback function is used to notify the protocol layer that the master is waiting for data. The i2c_scb_write function can be used by the protocol layer to write data into the transmit FIFO in response to the read request.</p>
<p>All I2C driver events are generated from interrupt context, and are expected to be handled with care. The protocol layer should defer any long operations to a non-interrupt context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB index being configured for I2C operation. </td></tr>
    <tr><td class="paramname">mode</td><td>Desired mode of operation. </td></tr>
    <tr><td class="paramname">clock_freq</td><td>Desired I2C clock frequency. </td></tr>
    <tr><td class="paramname">slave_addr</td><td>Device address to be used in case of slave operation. </td></tr>
    <tr><td class="paramname">slave_mask</td><td>Mask to be applied on for slave address matching. </td></tr>
    <tr><td class="paramname">cb_fun_ptr</td><td>Callback function to be called for event notification. </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>Receive buffer used to hold written by master. </td></tr>
    <tr><td class="paramname">scratch_buffer_size</td><td>Size of the receive buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>This API is used to enable and configure one of the I2C blocks for driver operation. Only I2C slave operation is currently supported by the driver as of now.</p>
<p>The I2C driver is agnostic of the actual data transfer protocol. It reads all data written by the master into a receive buffer provided by the protocol layer. A callback function is used to notify the protocol layer when the write is complete. The receive buffer provided should be big enough to hold the maximum amount of data that the master may provide in a write operation. If the write contains more data than the buffer can hold, the I2C driver will NAK the transaction.</p>
<p>Read requests from the I2C master are automatically delayed by clock stretching. A callback function is used to notify the protocol layer that the master is waiting for data. The i2c_scb_write function can be used by the protocol layer to write data into the transmit FIFO in response to the read request.</p>
<p>All I2C driver events are generated from interrupt context, and are expected to be handled with care. The protocol layer should defer any long operations to a non-interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>Pointer to pdstack context. </td></tr>
    <tr><td class="paramname">scb_index</td><td>SCB index being configured for I2C operation. </td></tr>
    <tr><td class="paramname">mode</td><td>Desired mode of operation. </td></tr>
    <tr><td class="paramname">clock_freq</td><td>Desired I2C clock frequency. </td></tr>
    <tr><td class="paramname">slave_addr</td><td>Device address to be used in case of slave operation. </td></tr>
    <tr><td class="paramname">slave_mask</td><td>Mask to be applied on for slave address matching. </td></tr>
    <tr><td class="paramname">cb_fun_ptr</td><td>Callback function to be called for event notification. </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>Receive buffer used to hold written by master. </td></tr>
    <tr><td class="paramname">scratch_buffer_size</td><td>Size of the receive buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga64f4c815aac116cc730b5166787962a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f4c815aac116cc730b5166787962a1">&#9670;&nbsp;</a></span>i2c_scb_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_deinit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize a previously initialized SCB block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB index to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga378575c70ffa0b89f129860177848143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga378575c70ffa0b89f129860177848143">&#9670;&nbsp;</a></span>i2c_scb_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>source_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into the transmit FIFO associated with the I2C block. </p>
<p>This function is used by the protocol layer to write data into the I2C transmit FIFO in response to a master read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to do the I2C transfer through. </td></tr>
    <tr><td class="paramname">source_ptr</td><td>Pointer to buffer containing the data to be written. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data buffer. Maximum amount of data that may be written. </td></tr>
    <tr><td class="paramname">count</td><td>Return parameter through which the actual write size is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae2cbeecd552d2640e432e2c57111f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cbeecd552d2640e432e2c57111f35c">&#9670;&nbsp;</a></span>i2c_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the I2C block specified. </p>
<p>This function resets the I2C block in response to an error or explicit request from protocol layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Reset the I2C block specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>Index of the I2C block to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga472c6396fd36ea9ddda27cc6ef9e6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga472c6396fd36ea9ddda27cc6ef9e6986">&#9670;&nbsp;</a></span>i2c_slave_ack_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_ack_ctrl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable the I2C slave acknowledgement. </p>
<p>This function enables/disables the slave address ACK from the I2C block. The protocol layer can disable the address ACK to hold off data transfers when it is not ready to respond to the master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to configure. </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable or disable the auto slave address acknowledgement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2c52132c4b3089409dac99443ed4a231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c52132c4b3089409dac99443ed4a231">&#9670;&nbsp;</a></span>i2c_scb_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_scb_is_idle </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the I2C block is idle. </p>
<p>This function checks whether the specified I2C block is idle. This check should be performed before the device enters deep sleep. Deep sleep entry should be avoided if this function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C block is idle, false otherwise. </dd></dl>

</div>
</div>
<a id="ga706524d3e4a8d5a195d7cb940e9149e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706524d3e4a8d5a195d7cb940e9149e4">&#9670;&nbsp;</a></span>i2c_scb_enable_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_enable_wakeup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable deep-sleep wakeup due to address match on the specified SCB block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be configured as deep-sleep wakeup trigger.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga0d55f6c9d1f49de78bd51450f176d24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d55f6c9d1f49de78bd51450f176d24d">&#9670;&nbsp;</a></span>i2c_timer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_timer_cb </td>
          <td>(</td>
          <td class="paramtype">cy_timer_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer callback that indicates I2C transaction that has timed out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>Callback pointer. </td></tr>
    <tr><td class="paramname">id</td><td>The timer id used to time I2C transactions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Timer callback that indicates I2C transaction that has timed out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer ID that is used to specify the SCB block. </td></tr>
    <tr><td class="paramname">callbackContext</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga85a9c9e60bdf6a05fcb7fdba90406a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a9c9e60bdf6a05fcb7fdba90406a1c">&#9670;&nbsp;</a></span>gl_img1_fw_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a>* gl_img1_fw_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to metadata associated with the Image-1 FW binary. </p>

</div>
</div>
<a id="ga6e6dccbc6cb6e0410853a38bdcccb6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6dccbc6cb6e0410853a38bdcccb6af">&#9670;&nbsp;</a></span>gl_img2_fw_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a>* gl_img2_fw_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to metadata associated with the Image-2 FW binary. </p>
<p>Pointer to metadata associated with the Image-2 FW binary. </p>

</div>
</div>
<a id="ga977a6217be08fd77b2dd8ba0bc82e9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977a6217be08fd77b2dd8ba0bc82e9c5">&#9670;&nbsp;</a></span>gl_img1_fw_pseudo_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a>* gl_img1_fw_pseudo_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to pseudo metadata associated with the Image-1 FW binary. </p>

</div>
</div>
<a id="ga58312a28a5af18f3fe3f5e5673d13855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58312a28a5af18f3fe3f5e5673d13855">&#9670;&nbsp;</a></span>gl_img2_fw_pseudo_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#structsys__fw__metadata__t">sys_fw_metadata_t</a>* gl_img2_fw_pseudo_metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to pseudo metadata associated with the Image-2 FW binary. </p>

</div>
</div>
<a id="gaec2fd46b2891d6b8cb7aad1d2dac6fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2fd46b2891d6b8cb7aad1d2dac6fd3">&#9670;&nbsp;</a></span>gl_img_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon.html#unionfw__img__status__t">fw_img_status_t</a> gl_img_status</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current firmware image status. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CCGx App Common</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
