<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CCGx App Common</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CCGx App Common</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__ccgxAppCommon__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__ccgxAppCommon.html">App Common Middleware</a><a class="el" href="group__group__ccgxAppCommon.html">App Common Middleware</a> &raquo;  &#124; <a class="el" href="group__group__ccgxAppCommon__macros.html">Macros</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This section describes the ccgxAppCommon functions. </p>
<p>Detailed information about each API is available in each function description. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga156253580c66f60c5dcfea33881373b0"><td class="memItemLeft" align="right" valign="top"><a id="ga156253580c66f60c5dcfea33881373b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga156253580c66f60c5dcfea33881373b0">CY_DR_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:ga156253580c66f60c5dcfea33881373b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">DR SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:ga156253580c66f60c5dcfea33881373b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9ba864328b042578dee63a2439c1aee"><td class="memItemLeft" align="right" valign="top"><a id="gad9ba864328b042578dee63a2439c1aee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad9ba864328b042578dee63a2439c1aee">CY_PR_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x0C</td></tr>
<tr class="memdesc:gad9ba864328b042578dee63a2439c1aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">PR SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:gad9ba864328b042578dee63a2439c1aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="memItemLeft" align="right" valign="top"><a id="gadcf06cdba1e0d1273aae9a4c083d1f73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gadcf06cdba1e0d1273aae9a4c083d1f73">CY_PR_SWAP_RESPONSE_POS</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">PR SWAP Bit Position From Config Table. <br /></td></tr>
<tr class="separator:gadcf06cdba1e0d1273aae9a4c083d1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c755bc1df32193ff9356904ddb1085"><td class="memItemLeft" align="right" valign="top"><a id="gab2c755bc1df32193ff9356904ddb1085"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab2c755bc1df32193ff9356904ddb1085">CY_VCONN_SWAP_RESPONSE_MASK</a>&#160;&#160;&#160;0x30</td></tr>
<tr class="memdesc:gab2c755bc1df32193ff9356904ddb1085"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCONN SWAP MASK From Config Table. <br /></td></tr>
<tr class="separator:gab2c755bc1df32193ff9356904ddb1085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778baf9b3c116c444b11fbc8c185471b"><td class="memItemLeft" align="right" valign="top"><a id="ga778baf9b3c116c444b11fbc8c185471b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga778baf9b3c116c444b11fbc8c185471b">CY_VCONN_SWAP_RESPONSE_POS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga778baf9b3c116c444b11fbc8c185471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">VCONN SWAP Bit Position From Config Table. <br /></td></tr>
<tr class="separator:ga778baf9b3c116c444b11fbc8c185471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga987e808055c53d2d3138625e94ce0c8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga987e808055c53d2d3138625e94ce0c8d">app_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga987e808055c53d2d3138625e94ce0c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application level init function.  <a href="#ga987e808055c53d2d3138625e94ce0c8d">More...</a><br /></td></tr>
<tr class="separator:ga987e808055c53d2d3138625e94ce0c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga41c615b2b4410be1d5f90f454b2a6b5e">app_is_port_enabled</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the specified PD port is enabled in the system configuration.  <a href="#ga41c615b2b4410be1d5f90f454b2a6b5e">More...</a><br /></td></tr>
<tr class="separator:ga41c615b2b4410be1d5f90f454b2a6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad066f25e9c4975fadc25bfbdeeb88bb1">app_task</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for application level asynchronous tasks.  <a href="#gad066f25e9c4975fadc25bfbdeeb88bb1">More...</a><br /></td></tr>
<tr class="separator:gad066f25e9c4975fadc25bfbdeeb88bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd2bdc30aa59479a77d28857789cff2"><td class="memItemLeft" align="right" valign="top">cy_stc_pdstack_app_cbk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3dd2bdc30aa59479a77d28857789cff2">app_get_callback_ptr</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3dd2bdc30aa59479a77d28857789cff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return the App callback structure pointer.  <a href="#ga3dd2bdc30aa59479a77d28857789cff2">More...</a><br /></td></tr>
<tr class="separator:ga3dd2bdc30aa59479a77d28857789cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cd70e9e221ab79f671ce87143afe79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad1cd70e9e221ab79f671ce87143afe79">app_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *dat)</td></tr>
<tr class="memdesc:gad1cd70e9e221ab79f671ce87143afe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for event notifications from the PD stack.  <a href="#gad1cd70e9e221ab79f671ce87143afe79">More...</a><br /></td></tr>
<tr class="separator:gad1cd70e9e221ab79f671ce87143afe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaadfeec58882d5ff9434208ef0f07af6"><td class="memItemLeft" align="right" valign="top">app_resp_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaaadfeec58882d5ff9434208ef0f07af6">app_get_resp_buf</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaaadfeec58882d5ff9434208ef0f07af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the application provide PD command response buffer.  <a href="#gaaadfeec58882d5ff9434208ef0f07af6">More...</a><br /></td></tr>
<tr class="separator:gaaadfeec58882d5ff9434208ef0f07af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d7c64e58560deaffc50953f364124b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#structapp__status__t">app_status_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga93d7c64e58560deaffc50953f364124b">app_get_status</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga93d7c64e58560deaffc50953f364124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get handle to structure containing information about the system status for a PD port.  <a href="#ga93d7c64e58560deaffc50953f364124b">More...</a><br /></td></tr>
<tr class="separator:ga93d7c64e58560deaffc50953f364124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae9332fe6e441fbc8c3ee70b1e90a0f77">app_update_sys_battery_status</a> (uint32_t bsdo)</td></tr>
<tr class="memdesc:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the system battery status.  <a href="#gae9332fe6e441fbc8c3ee70b1e90a0f77">More...</a><br /></td></tr>
<tr class="separator:gae9332fe6e441fbc8c3ee70b1e90a0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ab189c440f4561aebd58aa78d6621d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga37ab189c440f4561aebd58aa78d6621d">app_sleep</a> (void)</td></tr>
<tr class="memdesc:ga37ab189c440f4561aebd58aa78d6621d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the APP handlers are ready to allow device deep sleep.  <a href="#ga37ab189c440f4561aebd58aa78d6621d">More...</a><br /></td></tr>
<tr class="separator:ga37ab189c440f4561aebd58aa78d6621d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga5e5b5fbf3a976f0f88688f3bca95908c">app_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the APP handler state after CCG device wakes from deep-sleep.  <a href="#ga5e5b5fbf3a976f0f88688f3bca95908c">More...</a><br /></td></tr>
<tr class="separator:ga5e5b5fbf3a976f0f88688f3bca95908c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb8e346586b2e372a4d4303063c386e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9eb8e346586b2e372a4d4303063c386e">system_sleep</a> ()</td></tr>
<tr class="memdesc:ga9eb8e346586b2e372a4d4303063c386e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to place CCG device in power saving mode if possible.  <a href="#ga9eb8e346586b2e372a4d4303063c386e">More...</a><br /></td></tr>
<tr class="separator:ga9eb8e346586b2e372a4d4303063c386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga257a11c7349f3f402f3b5071e8ac9b04">vconn_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t channel)</td></tr>
<tr class="memdesc:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables VCONN power.  <a href="#ga257a11c7349f3f402f3b5071e8ac9b04">More...</a><br /></td></tr>
<tr class="separator:ga257a11c7349f3f402f3b5071e8ac9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635c202b5b7794044060fe53283c0ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga635c202b5b7794044060fe53283c0ca1">vconn_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t channel)</td></tr>
<tr class="memdesc:ga635c202b5b7794044060fe53283c0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables VCONN power.  <a href="#ga635c202b5b7794044060fe53283c0ca1">More...</a><br /></td></tr>
<tr class="separator:ga635c202b5b7794044060fe53283c0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b195995f6b6224c6284f4224bdadf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga62b195995f6b6224c6284f4224bdadf0">vconn_is_present</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga62b195995f6b6224c6284f4224bdadf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if power is present on VConn.  <a href="#ga62b195995f6b6224c6284f4224bdadf0">More...</a><br /></td></tr>
<tr class="separator:ga62b195995f6b6224c6284f4224bdadf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424d434bc2b8a173c14b56842737a3ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga424d434bc2b8a173c14b56842737a3ef">vbus_is_present</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt, int8_t per)</td></tr>
<tr class="memdesc:ga424d434bc2b8a173c14b56842737a3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if power is present on VBus.  <a href="#ga424d434bc2b8a173c14b56842737a3ef">More...</a><br /></td></tr>
<tr class="separator:ga424d434bc2b8a173c14b56842737a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c527850e02f68c9c1072b58921fe533"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0c527850e02f68c9c1072b58921fe533">vbus_get_value</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga0c527850e02f68c9c1072b58921fe533"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return current VBUS voltage in mV.  <a href="#ga0c527850e02f68c9c1072b58921fe533">More...</a><br /></td></tr>
<tr class="separator:ga0c527850e02f68c9c1072b58921fe533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631d47609bcac183d47133c3a0bc55e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga631d47609bcac183d47133c3a0bc55e2">vbus_discharge_on</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga631d47609bcac183d47133c3a0bc55e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns on discharge FET on selected port.  <a href="#ga631d47609bcac183d47133c3a0bc55e2">More...</a><br /></td></tr>
<tr class="separator:ga631d47609bcac183d47133c3a0bc55e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370b31502ed6b6794b00652450930ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga370b31502ed6b6794b00652450930ce1">vbus_discharge_off</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga370b31502ed6b6794b00652450930ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function turns off discharge FET on selected port.  <a href="#ga370b31502ed6b6794b00652450930ce1">More...</a><br /></td></tr>
<tr class="separator:ga370b31502ed6b6794b00652450930ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga197c17a51bae827c86006723dd28b561"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga197c17a51bae827c86006723dd28b561">system_vconn_ocp_en</a> (cy_stc_pdstack_context_t *context, cy_cb_vbus_fault_t cbk)</td></tr>
<tr class="memdesc:ga197c17a51bae827c86006723dd28b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable vconn ocp.  <a href="#ga197c17a51bae827c86006723dd28b561">More...</a><br /></td></tr>
<tr class="separator:ga197c17a51bae827c86006723dd28b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3ceb8e80d5c01c5157484bf30f85925d">system_vconn_ocp_dis</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable vconn ocp.  <a href="#ga3ceb8e80d5c01c5157484bf30f85925d">More...</a><br /></td></tr>
<tr class="separator:ga3ceb8e80d5c01c5157484bf30f85925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128a0e6e3970ac63087ee51a55999429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga128a0e6e3970ac63087ee51a55999429">app_ovp_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt_mV, bool pfet, cy_cb_vbus_fault_t ovp_cb)</td></tr>
<tr class="memdesc:ga128a0e6e3970ac63087ee51a55999429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and configure the Over-Voltage protection circuitry.  <a href="#ga128a0e6e3970ac63087ee51a55999429">More...</a><br /></td></tr>
<tr class="separator:ga128a0e6e3970ac63087ee51a55999429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b919168d11183f7e6d5816b773a327e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9b919168d11183f7e6d5816b773a327e">app_ovp_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, bool pfet)</td></tr>
<tr class="memdesc:ga9b919168d11183f7e6d5816b773a327e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Over-Voltage protection circuitry.  <a href="#ga9b919168d11183f7e6d5816b773a327e">More...</a><br /></td></tr>
<tr class="separator:ga9b919168d11183f7e6d5816b773a327e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1d2dc98c12ea2ccc48072cb1b911a077">system_vconn_scp_en</a> (cy_stc_pdstack_context_t *context, cy_cb_vbus_fault_t cbk)</td></tr>
<tr class="memdesc:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enable vconn scp.  <a href="#ga1d2dc98c12ea2ccc48072cb1b911a077">More...</a><br /></td></tr>
<tr class="separator:ga1d2dc98c12ea2ccc48072cb1b911a077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a402bfbaeee99955bb644bb5ee19838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga6a402bfbaeee99955bb644bb5ee19838">system_vconn_scp_dis</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga6a402bfbaeee99955bb644bb5ee19838"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disable vconn scp.  <a href="#ga6a402bfbaeee99955bb644bb5ee19838">More...</a><br /></td></tr>
<tr class="separator:ga6a402bfbaeee99955bb644bb5ee19838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3c78977d8cc1e0753a16ea9bd1269b41">app_uvp_enable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint16_t volt_mV, bool pfet, cy_cb_vbus_fault_t uvp_cb)</td></tr>
<tr class="memdesc:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable and configure the Under-Voltage protection circuitry.  <a href="#ga3c78977d8cc1e0753a16ea9bd1269b41">More...</a><br /></td></tr>
<tr class="separator:ga3c78977d8cc1e0753a16ea9bd1269b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8979eabd2d152c80b65239cf08c601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga8a8979eabd2d152c80b65239cf08c601">app_uvp_disable</a> (cy_stc_pdstack_context_t *ptrPdStackContext, bool pfet)</td></tr>
<tr class="memdesc:ga8a8979eabd2d152c80b65239cf08c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Under-Voltage protection circuitry.  <a href="#ga8a8979eabd2d152c80b65239cf08c601">More...</a><br /></td></tr>
<tr class="separator:ga8a8979eabd2d152c80b65239cf08c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a1416d128b2d3ddb2444c4ea645750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae2a1416d128b2d3ddb2444c4ea645750">app_update_bc_src_snk_support</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t enable)</td></tr>
<tr class="memdesc:gae2a1416d128b2d3ddb2444c4ea645750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the BC 1.2 source support.  <a href="#gae2a1416d128b2d3ddb2444c4ea645750">More...</a><br /></td></tr>
<tr class="separator:gae2a1416d128b2d3ddb2444c4ea645750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaa2efd4f1d1b83a9cdda00443a3fd6209">app_update_bc_src_support</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t enable)</td></tr>
<tr class="memdesc:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the BC 1.2 source support.  <a href="#gaa2efd4f1d1b83a9cdda00443a3fd6209">More...</a><br /></td></tr>
<tr class="separator:gaa2efd4f1d1b83a9cdda00443a3fd6209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039b5432fa3f08d7671a83b853e634fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga039b5432fa3f08d7671a83b853e634fe">app_update_sys_pwr_state</a> (uint8_t state)</td></tr>
<tr class="memdesc:ga039b5432fa3f08d7671a83b853e634fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update the system power state.  <a href="#ga039b5432fa3f08d7671a83b853e634fe">More...</a><br /></td></tr>
<tr class="separator:ga039b5432fa3f08d7671a83b853e634fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga14afafc3b67eb20f3ed48beb857fbbb3">app_disable_pd_port</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_pdstack_dpm_typec_cmd_cbk_t cbk)</td></tr>
<tr class="memdesc:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for PD port disable.  <a href="#ga14afafc3b67eb20f3ed48beb857fbbb3">More...</a><br /></td></tr>
<tr class="separator:ga14afafc3b67eb20f3ed48beb857fbbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09a34f2ede57568665767f0abe152dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad09a34f2ede57568665767f0abe152dd">app_validate_configtable_offsets</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gad09a34f2ede57568665767f0abe152dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the configuration table specified.  <a href="#gad09a34f2ede57568665767f0abe152dd">More...</a><br /></td></tr>
<tr class="separator:gad09a34f2ede57568665767f0abe152dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">ccg_app_task_init</a> (void)</td></tr>
<tr class="memdesc:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CCGx periodic application level tasks.  <a href="#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">More...</a><br /></td></tr>
<tr class="separator:ga1b1f896ef1a80a0a4e4ce42ccb80f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9f2f76f0c59231e3c1d65082b42c48dc">app_bc_12_sm_start</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the simplified BC 1.2 (DCP/CDP) state machine for CCG5 device on detection of a Type-C sink connection.  <a href="#ga9f2f76f0c59231e3c1d65082b42c48dc">More...</a><br /></td></tr>
<tr class="separator:ga9f2f76f0c59231e3c1d65082b42c48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e89461be3b772f36c3e68e0aca3615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga72e89461be3b772f36c3e68e0aca3615">sln_pd_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *data)</td></tr>
<tr class="memdesc:ga72e89461be3b772f36c3e68e0aca3615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solution handler for PD events reported from the stack.  <a href="#ga72e89461be3b772f36c3e68e0aca3615">More...</a><br /></td></tr>
<tr class="separator:ga72e89461be3b772f36c3e68e0aca3615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5091a22398d46f8d870ec769bec40853"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga5091a22398d46f8d870ec769bec40853">mux_ctrl_init</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga5091a22398d46f8d870ec769bec40853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Type-C Data Mux for a specific PD port.  <a href="#ga5091a22398d46f8d870ec769bec40853">More...</a><br /></td></tr>
<tr class="separator:ga5091a22398d46f8d870ec769bec40853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga067c4788c2e2c0b38fa1631d05f8adab">mux_ctrl_bb_enable</a> (uint8_t port, uint8_t polarity)</td></tr>
<tr class="memdesc:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable BB device enumeration on the board.  <a href="#ga067c4788c2e2c0b38fa1631d05f8adab">More...</a><br /></td></tr>
<tr class="separator:ga067c4788c2e2c0b38fa1631d05f8adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gafe5c906c34d42ac62e4aab9b7f19a278">fault_handler_init_vars</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize fault-handling related variables from the configuration table.  <a href="#gafe5c906c34d42ac62e4aab9b7f19a278">More...</a><br /></td></tr>
<tr class="separator:gafe5c906c34d42ac62e4aab9b7f19a278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df995227d611d600d71fc616589e086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga6df995227d611d600d71fc616589e086">fault_handler_register_cbks</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:ga6df995227d611d600d71fc616589e086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register solution space function handlers.  <a href="#ga6df995227d611d600d71fc616589e086">More...</a><br /></td></tr>
<tr class="separator:ga6df995227d611d600d71fc616589e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57725e00da96b711d9567afd66a2f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab57725e00da96b711d9567afd66a2f93">fault_handler_clear_counts</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gab57725e00da96b711d9567afd66a2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the fault occurrence counts after a Type-C detach is detected.  <a href="#gab57725e00da96b711d9567afd66a2f93">More...</a><br /></td></tr>
<tr class="separator:gab57725e00da96b711d9567afd66a2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13092468da8be42cf1497719f2392d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae13092468da8be42cf1497719f2392d3">fault_handler_task</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gae13092468da8be42cf1497719f2392d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any fault handler related tasks.  <a href="#gae13092468da8be42cf1497719f2392d3">More...</a><br /></td></tr>
<tr class="separator:gae13092468da8be42cf1497719f2392d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49cfd10d337a7d188bf27f25193a35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad49cfd10d337a7d188bf27f25193a35b">fault_event_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, cy_en_pdstack_app_evt_t evt, const void *dat)</td></tr>
<tr class="memdesc:gad49cfd10d337a7d188bf27f25193a35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle any application events associated with fault handling logic.  <a href="#gad49cfd10d337a7d188bf27f25193a35b">More...</a><br /></td></tr>
<tr class="separator:gad49cfd10d337a7d188bf27f25193a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf3cc2e31b87f603f5da78321083a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1cf3cc2e31b87f603f5da78321083a02">app_otp_enable</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga1cf3cc2e31b87f603f5da78321083a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Over-Temperature Protection logic.  <a href="#ga1cf3cc2e31b87f603f5da78321083a02">More...</a><br /></td></tr>
<tr class="separator:ga1cf3cc2e31b87f603f5da78321083a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e6cabefd046b9b84a228775afddd54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf1e6cabefd046b9b84a228775afddd54">app_otp_check_temp</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaf1e6cabefd046b9b84a228775afddd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform OTP check.  <a href="#gaf1e6cabefd046b9b84a228775afddd54">More...</a><br /></td></tr>
<tr class="separator:gaf1e6cabefd046b9b84a228775afddd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae5a0e8856cdbd01ca2f848245c6b8a60">app_otp_status</a> (uint8_t port)</td></tr>
<tr class="memdesc:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of Over-Temperature Protection.  <a href="#gae5a0e8856cdbd01ca2f848245c6b8a60">More...</a><br /></td></tr>
<tr class="separator:gae5a0e8856cdbd01ca2f848245c6b8a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf604c26013002a29a736c0b618c405cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf604c26013002a29a736c0b618c405cf">vconn_change_handler</a> (cy_stc_pdstack_context_t *context, bool vconn_on)</td></tr>
<tr class="memdesc:gaf604c26013002a29a736c0b618c405cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to handle VConn supply state change due to OCP condition or V5V supply change.  <a href="#gaf604c26013002a29a736c0b618c405cf">More...</a><br /></td></tr>
<tr class="separator:gaf604c26013002a29a736c0b618c405cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga2e060850f2d33f08d9ae4654ee7629f3">app_is_host_hpd_virtual</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the solution is configured to support virtual HPD.  <a href="#ga2e060850f2d33f08d9ae4654ee7629f3">More...</a><br /></td></tr>
<tr class="separator:ga2e060850f2d33f08d9ae4654ee7629f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbafde1e08b787d570f69c5e8378b10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1cbafde1e08b787d570f69c5e8378b10">set_custom_host_cap_control</a> (uint8_t port, uint8_t host_config)</td></tr>
<tr class="memdesc:ga1cbafde1e08b787d570f69c5e8378b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to update custom host capabilities HPI register with the value provided by EC.  <a href="#ga1cbafde1e08b787d570f69c5e8378b10">More...</a><br /></td></tr>
<tr class="separator:ga1cbafde1e08b787d570f69c5e8378b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga4a21460df3b3ee4cc8f22b2b856e668b">app_power_share_init</a> (void)</td></tr>
<tr class="memdesc:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the power sharing across ports on a dual-port CCG device.  <a href="#ga4a21460df3b3ee4cc8f22b2b856e668b">More...</a><br /></td></tr>
<tr class="separator:ga4a21460df3b3ee4cc8f22b2b856e668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68110542f5463158989749753e37632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gac68110542f5463158989749753e37632">app_contract_handler</a> (uint8_t port)</td></tr>
<tr class="memdesc:gac68110542f5463158989749753e37632"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called at the end of a PD contract to check whether any role swaps need to be triggered.  <a href="#gac68110542f5463158989749753e37632">More...</a><br /></td></tr>
<tr class="separator:gac68110542f5463158989749753e37632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga619740c578362ebb487c68e54c86c83e"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga619740c578362ebb487c68e54c86c83e">pd_get_ptr_cfg_sub_tbl</a> (uint8_t port, uint8_t type)</td></tr>
<tr class="memdesc:ga619740c578362ebb487c68e54c86c83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve desired sub-table from the configuration table.  <a href="#ga619740c578362ebb487c68e54c86c83e">More...</a><br /></td></tr>
<tr class="separator:ga619740c578362ebb487c68e54c86c83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcee026b0d0cdeec924f9b46abcc479c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gabcee026b0d0cdeec924f9b46abcc479c">timer_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext)</td></tr>
<tr class="memdesc:gabcee026b0d0cdeec924f9b46abcc479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize timer callbacks.  <a href="#gabcee026b0d0cdeec924f9b46abcc479c">More...</a><br /></td></tr>
<tr class="separator:gabcee026b0d0cdeec924f9b46abcc479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08054935adf625b7ed2d5e6076f8ba52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga08054935adf625b7ed2d5e6076f8ba52">app_conf_for_faulty_dev_removal</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga08054935adf625b7ed2d5e6076f8ba52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the CCG to wait for physical detach of faulty port partner.  <a href="#ga08054935adf625b7ed2d5e6076f8ba52">More...</a><br /></td></tr>
<tr class="separator:ga08054935adf625b7ed2d5e6076f8ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa561ba390c4db0bce122405dedffb75d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaa561ba390c4db0bce122405dedffb75d">app_port_fault_count_exceeded</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gaa561ba390c4db0bce122405dedffb75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any fault count has exceeded limit for the specified PD port.  <a href="#gaa561ba390c4db0bce122405dedffb75d">More...</a><br /></td></tr>
<tr class="separator:gaa561ba390c4db0bce122405dedffb75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9fbef10605b1f75b463c5bc07f3b04e6">app_retrieve_fault_status</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">To retrieve the fault sticky status.  <a href="#ga9fbef10605b1f75b463c5bc07f3b04e6">More...</a><br /></td></tr>
<tr class="separator:ga9fbef10605b1f75b463c5bc07f3b04e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae3f90a4aac402a773faf295e871e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga4ae3f90a4aac402a773faf295e871e29">register_soln_function_handler</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, <a class="el" href="structapp__sln__handler__t.html">app_sln_handler_t</a> *handler)</td></tr>
<tr class="memdesc:ga4ae3f90a4aac402a773faf295e871e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function registers solution level functions.  <a href="#ga4ae3f90a4aac402a773faf295e871e29">More...</a><br /></td></tr>
<tr class="separator:ga4ae3f90a4aac402a773faf295e871e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga48b852c3817507e93ac4f0cc8f5f58ba">app_vdm_layer_reset</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restarts alternate mode layer.  <a href="#ga48b852c3817507e93ac4f0cc8f5f58ba">More...</a><br /></td></tr>
<tr class="separator:ga48b852c3817507e93ac4f0cc8f5f58ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe0ced862d3cbf35b36334f47490339"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3fe0ced862d3cbf35b36334f47490339">app_is_typec_attached</a> (void)</td></tr>
<tr class="memdesc:ga3fe0ced862d3cbf35b36334f47490339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of Type-C attach on all Type-C ports.  <a href="#ga3fe0ced862d3cbf35b36334f47490339">More...</a><br /></td></tr>
<tr class="separator:ga3fe0ced862d3cbf35b36334f47490339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a79606a8a811589791b10712774b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga41a79606a8a811589791b10712774b85">pd_vbat_gnd_scp_cbk</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga41a79606a8a811589791b10712774b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function from interrupt handler to handle VBAT-GND SCP fault.  <a href="#ga41a79606a8a811589791b10712774b85">More...</a><br /></td></tr>
<tr class="separator:ga41a79606a8a811589791b10712774b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga8da3d9d084dd05dbaa510b065198b6b8">pd_bb_ilim_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function from interrupt handler to handle buck-boost inductor current limit fault.  <a href="#ga8da3d9d084dd05dbaa510b065198b6b8">More...</a><br /></td></tr>
<tr class="separator:ga8da3d9d084dd05dbaa510b065198b6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a90b6242e88c2affb0817cff513751e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga8a90b6242e88c2affb0817cff513751e">pd_brown_out_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:ga8a90b6242e88c2affb0817cff513751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for VDDD regulator brown out fault.  <a href="#ga8a90b6242e88c2affb0817cff513751e">More...</a><br /></td></tr>
<tr class="separator:ga8a90b6242e88c2affb0817cff513751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9f3f3e4de83a213874c00f309b1751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaab9f3f3e4de83a213874c00f309b1751">pd_vreg_inrush_det_fault_handler</a> (void *callbackContext, bool state)</td></tr>
<tr class="memdesc:gaab9f3f3e4de83a213874c00f309b1751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for VDDD regulator inrush current fault.  <a href="#gaab9f3f3e4de83a213874c00f309b1751">More...</a><br /></td></tr>
<tr class="separator:gaab9f3f3e4de83a213874c00f309b1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7dda31bfc7bf591351222ad2d8eb5c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab7dda31bfc7bf591351222ad2d8eb5c7">send_src_info</a> (struct cy_stc_pdstack_context *ptrPdStackContext)</td></tr>
<tr class="memdesc:gab7dda31bfc7bf591351222ad2d8eb5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback Function to decide whether to send source info.  <a href="#gab7dda31bfc7bf591351222ad2d8eb5c7">More...</a><br /></td></tr>
<tr class="separator:gab7dda31bfc7bf591351222ad2d8eb5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gafdfb8d6bfce9507aea95f3f5451a7789">bc_init</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the Battery Charging block.  <a href="#gafdfb8d6bfce9507aea95f3f5451a7789">More...</a><br /></td></tr>
<tr class="separator:gafdfb8d6bfce9507aea95f3f5451a7789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae1304bc5281a4decfa9c205d720a47"><td class="memItemLeft" align="right" valign="top">const cy_stc_legacy_charging_cfg_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gafae1304bc5281a4decfa9c205d720a47">bc_get_config</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gafae1304bc5281a4decfa9c205d720a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the current Battery Charging configuration.  <a href="#gafae1304bc5281a4decfa9c205d720a47">More...</a><br /></td></tr>
<tr class="separator:gafae1304bc5281a4decfa9c205d720a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c842c6a36610c26e86156463f956e1"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga83c842c6a36610c26e86156463f956e1">bc_start</a> (cy_stc_pdstack_context_t *context, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a> port_role)</td></tr>
<tr class="memdesc:ga83c842c6a36610c26e86156463f956e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts the Battery Charging block with desired configuration.  <a href="#ga83c842c6a36610c26e86156463f956e1">More...</a><br /></td></tr>
<tr class="separator:ga83c842c6a36610c26e86156463f956e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bb91b4849ec00a7feed096d9e31dce"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga08bb91b4849ec00a7feed096d9e31dce">bc_stop</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga08bb91b4849ec00a7feed096d9e31dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the Battery Charging block.  <a href="#ga08bb91b4849ec00a7feed096d9e31dce">More...</a><br /></td></tr>
<tr class="separator:ga08bb91b4849ec00a7feed096d9e31dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaa609c3d5f131d1259a9416fd5a7a5979">bc_is_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether the BC module is active or not.  <a href="#gaa609c3d5f131d1259a9416fd5a7a5979">More...</a><br /></td></tr>
<tr class="separator:gaa609c3d5f131d1259a9416fd5a7a5979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b0ddf5ed205702d4628341428a3bf4"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab4b0ddf5ed205702d4628341428a3bf4">bc_fsm</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gab4b0ddf5ed205702d4628341428a3bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles the Battery Charging block state machine.  <a href="#gab4b0ddf5ed205702d4628341428a3bf4">More...</a><br /></td></tr>
<tr class="separator:gab4b0ddf5ed205702d4628341428a3bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeddb10ad3d52f33172877e7b46b7611a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaeddb10ad3d52f33172877e7b46b7611a">bc_port_is_cdp</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaeddb10ad3d52f33172877e7b46b7611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the port is currently functioning as a CDP (Charging Downstream Port).  <a href="#gaeddb10ad3d52f33172877e7b46b7611a">More...</a><br /></td></tr>
<tr class="separator:gaeddb10ad3d52f33172877e7b46b7611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae90d6d317d6183bc5e277a66a3e9de18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae90d6d317d6183bc5e277a66a3e9de18">bc_sleep</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gae90d6d317d6183bc5e277a66a3e9de18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function puts the Battery Charging block to sleep.  <a href="#gae90d6d317d6183bc5e277a66a3e9de18">More...</a><br /></td></tr>
<tr class="separator:gae90d6d317d6183bc5e277a66a3e9de18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3638da0a0c79743d5db6127741635079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3638da0a0c79743d5db6127741635079">bc_wakeup</a> (void)</td></tr>
<tr class="memdesc:ga3638da0a0c79743d5db6127741635079"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function wakes up the Battery Charging block.  <a href="#ga3638da0a0c79743d5db6127741635079">More...</a><br /></td></tr>
<tr class="separator:ga3638da0a0c79743d5db6127741635079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be37ea9b028a57c60684196e3fcf905"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__group__ccgxAppCommon__data__structures.html#structbc__status__t">bc_status_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1be37ea9b028a57c60684196e3fcf905">bc_get_status</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1be37ea9b028a57c60684196e3fcf905"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the current status of the BC state machine.  <a href="#ga1be37ea9b028a57c60684196e3fcf905">More...</a><br /></td></tr>
<tr class="separator:ga1be37ea9b028a57c60684196e3fcf905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8eb59136a5bc414a24d202a88ab500b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaa8eb59136a5bc414a24d202a88ab500b">bc_pd_event_handler</a> (cy_stc_pdstack_context_t *context, cy_en_pdstack_app_evt_t evt)</td></tr>
<tr class="memdesc:gaa8eb59136a5bc414a24d202a88ab500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles events from USB-PD Device Policy Manager.  <a href="#gaa8eb59136a5bc414a24d202a88ab500b">More...</a><br /></td></tr>
<tr class="separator:gaa8eb59136a5bc414a24d202a88ab500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52979fd63b3499dfd069ba41d2bf28a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad52979fd63b3499dfd069ba41d2bf28a">bc_set_bc_evt</a> (cy_stc_pdstack_context_t *context, uint32_t evt_mask)</td></tr>
<tr class="memdesc:gad52979fd63b3499dfd069ba41d2bf28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets an event status for the BC state machine to process.  <a href="#gad52979fd63b3499dfd069ba41d2bf28a">More...</a><br /></td></tr>
<tr class="separator:gad52979fd63b3499dfd069ba41d2bf28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736c168139e927c108d7ef55e90fc7a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga736c168139e927c108d7ef55e90fc7a9">bc_clear_bc_evt</a> (cy_stc_pdstack_context_t *context, uint32_t evt_mask)</td></tr>
<tr class="memdesc:ga736c168139e927c108d7ef55e90fc7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears one or more BC events after the state machine has dealt with them.  <a href="#ga736c168139e927c108d7ef55e90fc7a9">More...</a><br /></td></tr>
<tr class="separator:ga736c168139e927c108d7ef55e90fc7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3a9699353dc54d34ea5dce1c71b0466c">ccg_get_system_max_pdp</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the port PDP value.  <a href="#ga3a9699353dc54d34ea5dce1c71b0466c">More...</a><br /></td></tr>
<tr class="separator:ga3a9699353dc54d34ea5dce1c71b0466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d2d443f2be2f1b549e8835870ddf95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab5d2d443f2be2f1b549e8835870ddf95">qc_set_cf_limit</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gab5d2d443f2be2f1b549e8835870ddf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables Current Foldback on the port when in QC mode.  <a href="#gab5d2d443f2be2f1b549e8835870ddf95">More...</a><br /></td></tr>
<tr class="separator:gab5d2d443f2be2f1b549e8835870ddf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9aa42ffefc5ac3d753b11847cb398fab">bc_afc_form_vi</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function forms the new AFC source capabilities based on the power passed.  <a href="#ga9aa42ffefc5ac3d753b11847cb398fab">More...</a><br /></td></tr>
<tr class="separator:ga9aa42ffefc5ac3d753b11847cb398fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcee615842c5c62ebf8d36e83a919afe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gabcee615842c5c62ebf8d36e83a919afe">bc_12_get_status</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gabcee615842c5c62ebf8d36e83a919afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current BC 1.2 status for a PD port.  <a href="#gabcee615842c5c62ebf8d36e83a919afe">More...</a><br /></td></tr>
<tr class="separator:gabcee615842c5c62ebf8d36e83a919afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0755713453a2b8aed13e4e11ae94354c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0755713453a2b8aed13e4e11ae94354c">bc_is_qc_afc_charging_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga0755713453a2b8aed13e4e11ae94354c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether the QC or AFC charging modes are active or not.  <a href="#ga0755713453a2b8aed13e4e11ae94354c">More...</a><br /></td></tr>
<tr class="separator:ga0755713453a2b8aed13e4e11ae94354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf9f0a988f1e8c31a092c4f2c45256ad7">bc_is_bc_charging_active</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether legacy charging modes are active or not.  <a href="#gaf9f0a988f1e8c31a092c4f2c45256ad7">More...</a><br /></td></tr>
<tr class="separator:gaf9f0a988f1e8c31a092c4f2c45256ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ebf8bad9d327493c62bdf056fd2585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga92ebf8bad9d327493c62bdf056fd2585">bc_is_bc_connected</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga92ebf8bad9d327493c62bdf056fd2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether legacy charging connect negotiated or not.  <a href="#ga92ebf8bad9d327493c62bdf056fd2585">More...</a><br /></td></tr>
<tr class="separator:ga92ebf8bad9d327493c62bdf056fd2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b8bb762de654cf691bfa2d4910b373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae2b8bb762de654cf691bfa2d4910b373">gpio_set_value</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, bool value)</td></tr>
<tr class="memdesc:gae2b8bb762de654cf691bfa2d4910b373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the GPIO to the required state.  <a href="#gae2b8bb762de654cf691bfa2d4910b373">More...</a><br /></td></tr>
<tr class="separator:gae2b8bb762de654cf691bfa2d4910b373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4a340d82409454a45acd6068e69419b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab4a340d82409454a45acd6068e69419b">gpio_read_value</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:gab4a340d82409454a45acd6068e69419b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GPIO current state.  <a href="#gab4a340d82409454a45acd6068e69419b">More...</a><br /></td></tr>
<tr class="separator:gab4a340d82409454a45acd6068e69419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81d9271ce686992981a09ab31509c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gac81d9271ce686992981a09ab31509c0f">gpio_set_drv_mode</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a> drv_mode)</td></tr>
<tr class="memdesc:gac81d9271ce686992981a09ab31509c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the GPIO with the desired drive mode.  <a href="#gac81d9271ce686992981a09ab31509c0f">More...</a><br /></td></tr>
<tr class="separator:gac81d9271ce686992981a09ab31509c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga061aa6d28ccf3abfd22e9add75199b9c">gpio_int_set_config</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, uint8_t int_mode)</td></tr>
<tr class="memdesc:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the GPIO with the desired interrupt setting.  <a href="#ga061aa6d28ccf3abfd22e9add75199b9c">More...</a><br /></td></tr>
<tr class="separator:ga061aa6d28ccf3abfd22e9add75199b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6213d69fa12f6d561f97cb17358d9b40"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga6213d69fa12f6d561f97cb17358d9b40">gpio_register_intr_cb</a> (uint8_t port, <a class="el" href="group__group__ccgxAppCommon.html#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">gpio_intr_cb_t</a> intr_cb)</td></tr>
<tr class="memdesc:ga6213d69fa12f6d561f97cb17358d9b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback to be called when a GPIO interrupt associated with a specific port is triggered.  <a href="#ga6213d69fa12f6d561f97cb17358d9b40">More...</a><br /></td></tr>
<tr class="separator:ga6213d69fa12f6d561f97cb17358d9b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2ba473562725e5d2f2216f63dc504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga05d2ba473562725e5d2f2216f63dc504">hsiom_set_config</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a> hsiom_mode)</td></tr>
<tr class="memdesc:ga05d2ba473562725e5d2f2216f63dc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the IO mode for a CCG device IO.  <a href="#ga05d2ba473562725e5d2f2216f63dc504">More...</a><br /></td></tr>
<tr class="separator:ga05d2ba473562725e5d2f2216f63dc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a37e81fc0c0bf20c918954056bfa83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae5a37e81fc0c0bf20c918954056bfa83">gpio_hsiom_set_config</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a> hsiom_mode, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a> drv_mode, bool value)</td></tr>
<tr class="memdesc:gae5a37e81fc0c0bf20c918954056bfa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single function for complete configuration of a CCG IO.  <a href="#gae5a37e81fc0c0bf20c918954056bfa83">More...</a><br /></td></tr>
<tr class="separator:gae5a37e81fc0c0bf20c918954056bfa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gac5e3a8c83eb6bae572d7e18cea59edd3">gpio_set_lvttl_mode</a> (uint8_t port)</td></tr>
<tr class="memdesc:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input buffer voltage for a port to LVTTL.  <a href="#gac5e3a8c83eb6bae572d7e18cea59edd3">More...</a><br /></td></tr>
<tr class="separator:gac5e3a8c83eb6bae572d7e18cea59edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">gpio_get_intr</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the interrupt status on a specific GPIO.  <a href="#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">More...</a><br /></td></tr>
<tr class="separator:ga7ea5408d9cf9f6cdeac7eaddaedf39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68bf50943ae651b4a773d6ada7d8da48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga68bf50943ae651b4a773d6ada7d8da48">gpio_clear_intr</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga68bf50943ae651b4a773d6ada7d8da48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt status on the specified GPIO.  <a href="#ga68bf50943ae651b4a773d6ada7d8da48">More...</a><br /></td></tr>
<tr class="separator:ga68bf50943ae651b4a773d6ada7d8da48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65daf9463b0aa6902604e565da854174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga65daf9463b0aa6902604e565da854174">lpm_gpio_init</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a> port_pin)</td></tr>
<tr class="memdesc:ga65daf9463b0aa6902604e565da854174"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the LPM Functionality over GPIO.  <a href="#ga65daf9463b0aa6902604e565da854174">More...</a><br /></td></tr>
<tr class="separator:ga65daf9463b0aa6902604e565da854174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35b615f84e123c6f244a3f00f83bfe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab35b615f84e123c6f244a3f00f83bfe9">lpm_gpio_get_lpm_stat</a> (void)</td></tr>
<tr class="memdesc:gab35b615f84e123c6f244a3f00f83bfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get the LPM Status.  <a href="#gab35b615f84e123c6f244a3f00f83bfe9">More...</a><br /></td></tr>
<tr class="separator:gab35b615f84e123c6f244a3f00f83bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ed132647d48c038a2b8f5fb663c97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga74ed132647d48c038a2b8f5fb663c97d">lpm_gpio_clr_lpm_stat</a> (void)</td></tr>
<tr class="memdesc:ga74ed132647d48c038a2b8f5fb663c97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">To clear the LPM Status.  <a href="#ga74ed132647d48c038a2b8f5fb663c97d">More...</a><br /></td></tr>
<tr class="separator:ga74ed132647d48c038a2b8f5fb663c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6caaa2a2399383668c403e694d6d5758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga6caaa2a2399383668c403e694d6d5758">lpm_gpio_set_intr</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a> intr)</td></tr>
<tr class="memdesc:ga6caaa2a2399383668c403e694d6d5758"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Set the Interrupt.  <a href="#ga6caaa2a2399383668c403e694d6d5758">More...</a><br /></td></tr>
<tr class="separator:ga6caaa2a2399383668c403e694d6d5758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga19fbabfd67fd86ce7060a960b5c43d80">lpm_gpio_clr_intr</a> (void)</td></tr>
<tr class="memdesc:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Clear the Interrupt.  <a href="#ga19fbabfd67fd86ce7060a960b5c43d80">More...</a><br /></td></tr>
<tr class="separator:ga19fbabfd67fd86ce7060a960b5c43d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464ab91815a8c55916d179cb924d6103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga464ab91815a8c55916d179cb924d6103">lpm_gpio_read</a> (void)</td></tr>
<tr class="memdesc:ga464ab91815a8c55916d179cb924d6103"><td class="mdescLeft">&#160;</td><td class="mdescRight">To Read the LPM_GPIO.  <a href="#ga464ab91815a8c55916d179cb924d6103">More...</a><br /></td></tr>
<tr class="separator:ga464ab91815a8c55916d179cb924d6103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0c9ba09522c7b06b4f4b78965af64cfc">eval_src_cap</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *srcCap, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the PD stack to allow the application logic to evaluate the Source Capabilities received from the port partner and generate the desired request.  <a href="#ga0c9ba09522c7b06b4f4b78965af64cfc">More...</a><br /></td></tr>
<tr class="separator:ga0c9ba09522c7b06b4f4b78965af64cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1aa9ecc53e672ff08c97ea9beb3905ed">eval_rdo</a> (cy_stc_pdstack_context_t *context, cy_pd_pd_do_t rdo, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the PD stack to allow the application to evaluate a power request data object received from the port partner and decide whether it should be satisfied.  <a href="#ga1aa9ecc53e672ff08c97ea9beb3905ed">More...</a><br /></td></tr>
<tr class="separator:ga1aa9ecc53e672ff08c97ea9beb3905ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga92f950d9ddc50d8a7d3f69a23de108f1">app_update_rdo</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *srcCap, cy_pdstack_app_resp_cbk_t *appResp)</td></tr>
<tr class="memdesc:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only applicable in the case of the CCG6 device, and can be used by the application logic to modify the RDO generated by the ROM-ed version of the eval_src_cap function.  <a href="#ga92f950d9ddc50d8a7d3f69a23de108f1">More...</a><br /></td></tr>
<tr class="separator:ga92f950d9ddc50d8a7d3f69a23de108f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3817297cc85653d6201cd1e48159ada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab3817297cc85653d6201cd1e48159ada">psrc_set_voltage</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:gab3817297cc85653d6201cd1e48159ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the VBus source voltage to the desired value.  <a href="#gab3817297cc85653d6201cd1e48159ada">More...</a><br /></td></tr>
<tr class="separator:gab3817297cc85653d6201cd1e48159ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1881bbbc0107059d70bc39920a6738f2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1881bbbc0107059d70bc39920a6738f2">psrc_get_voltage</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1881bbbc0107059d70bc39920a6738f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the VBus source voltage that is currently configured.  <a href="#ga1881bbbc0107059d70bc39920a6738f2">More...</a><br /></td></tr>
<tr class="separator:ga1881bbbc0107059d70bc39920a6738f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93e96d009a6e6717ffef86a79f7d223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad93e96d009a6e6717ffef86a79f7d223">psrc_set_current</a> (cy_stc_pdstack_context_t *context, uint16_t cur_10mA)</td></tr>
<tr class="memdesc:gad93e96d009a6e6717ffef86a79f7d223"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the VBus source current limit.  <a href="#gad93e96d009a6e6717ffef86a79f7d223">More...</a><br /></td></tr>
<tr class="separator:gad93e96d009a6e6717ffef86a79f7d223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae078c31aa1f7fce6bba129df400dc862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae078c31aa1f7fce6bba129df400dc862">psrc_enable</a> (cy_stc_pdstack_context_t *context, cy_pdstack_pwr_ready_cbk_t pwr_ready_handler)</td></tr>
<tr class="memdesc:gae078c31aa1f7fce6bba129df400dc862"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the VBus power supply.  <a href="#gae078c31aa1f7fce6bba129df400dc862">More...</a><br /></td></tr>
<tr class="separator:gae078c31aa1f7fce6bba129df400dc862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae522dada2eb76d90d46a6f428a31eff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae522dada2eb76d90d46a6f428a31eff1">psrc_disable</a> (cy_stc_pdstack_context_t *context, cy_pdstack_pwr_ready_cbk_t pwr_ready_handler)</td></tr>
<tr class="memdesc:gae522dada2eb76d90d46a6f428a31eff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the VBus power supply.  <a href="#gae522dada2eb76d90d46a6f428a31eff1">More...</a><br /></td></tr>
<tr class="separator:gae522dada2eb76d90d46a6f428a31eff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad019aef09ac99508d3cca4d2315b7df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad019aef09ac99508d3cca4d2315b7df7">ccg_sensor_init</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gad019aef09ac99508d3cca4d2315b7df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the sensor check block.  <a href="#gad019aef09ac99508d3cca4d2315b7df7">More...</a><br /></td></tr>
<tr class="separator:gad019aef09ac99508d3cca4d2315b7df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae913d9eb9a79f913e28c8d34de043686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae913d9eb9a79f913e28c8d34de043686">ccg_sensor_is_idle</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gae913d9eb9a79f913e28c8d34de043686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates to know if sensor check module is idle.  <a href="#gae913d9eb9a79f913e28c8d34de043686">More...</a><br /></td></tr>
<tr class="separator:gae913d9eb9a79f913e28c8d34de043686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaea471cf36a082dfaecfa15dc4b1028c3">ccg_sensor_check</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates caller to update system operating condition to the operating condition indicated by VIN and temperature of the sensors.  <a href="#gaea471cf36a082dfaecfa15dc4b1028c3">More...</a><br /></td></tr>
<tr class="separator:gaea471cf36a082dfaecfa15dc4b1028c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b142ab3e283161f9e168c898afce86a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga6b142ab3e283161f9e168c898afce86a">ccg_sensor_debounce_task</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga6b142ab3e283161f9e168c898afce86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs the debounce related checks.  <a href="#ga6b142ab3e283161f9e168c898afce86a">More...</a><br /></td></tr>
<tr class="separator:ga6b142ab3e283161f9e168c898afce86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546096050c83925d0c4099621f3486c0"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga546096050c83925d0c4099621f3486c0">ccg_sensor_temp_ec</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint8_t *buffer)</td></tr>
<tr class="memdesc:ga546096050c83925d0c4099621f3486c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current sensor temperature.  <a href="#ga546096050c83925d0c4099621f3486c0">More...</a><br /></td></tr>
<tr class="separator:ga546096050c83925d0c4099621f3486c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga2cfae9d8db4a74aed03c538607b6b1a9">ccg_get_battery_voltage</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts VIN(Battery) voltage.  <a href="#ga2cfae9d8db4a74aed03c538607b6b1a9">More...</a><br /></td></tr>
<tr class="separator:ga2cfae9d8db4a74aed03c538607b6b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1372cb404e2fdc0104e55166417b5f9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad1372cb404e2fdc0104e55166417b5f9">ccg_get_sys_oc</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, <a class="el" href="group__group__ccgxAppCommon__macros.html#gad456bb3be6173dae2997daf53c4aabc8">CCG_OC_BUFFER_DATE_TYPE</a> *oc_buffer)</td></tr>
<tr class="memdesc:gad1372cb404e2fdc0104e55166417b5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts undebounced OC specific information.  <a href="#gad1372cb404e2fdc0104e55166417b5f9">More...</a><br /></td></tr>
<tr class="separator:gad1372cb404e2fdc0104e55166417b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61443c0e3f64be9b85774528c6776eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga61443c0e3f64be9b85774528c6776eee">ccg_set_sensor_sleep_mode</a> (cy_stc_pdstack_context_t *ptrPdStackcontext)</td></tr>
<tr class="memdesc:ga61443c0e3f64be9b85774528c6776eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the VIN OV/UV comparators for sleep mode.  <a href="#ga61443c0e3f64be9b85774528c6776eee">More...</a><br /></td></tr>
<tr class="separator:ga61443c0e3f64be9b85774528c6776eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3e5f3c378ced3b9a9b88a864380db5a6">eval_dr_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates Data role swap request.  <a href="#ga3e5f3c378ced3b9a9b88a864380db5a6">More...</a><br /></td></tr>
<tr class="separator:ga3e5f3c378ced3b9a9b88a864380db5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga28f7b458a4b35ab3a85dfec4aa969001">eval_pr_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates Power role swap request.  <a href="#ga28f7b458a4b35ab3a85dfec4aa969001">More...</a><br /></td></tr>
<tr class="separator:ga28f7b458a4b35ab3a85dfec4aa969001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bebef1cf20542c23c68e15ab2394fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga35bebef1cf20542c23c68e15ab2394fe">eval_vconn_swap</a> (cy_stc_pdstack_context_t *context, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga35bebef1cf20542c23c68e15ab2394fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates VConn swap request.  <a href="#ga35bebef1cf20542c23c68e15ab2394fe">More...</a><br /></td></tr>
<tr class="separator:ga35bebef1cf20542c23c68e15ab2394fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga606d6f10e4bf215d5ecbae3ac5422220">ccg_volt_temp_map</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint16_t therm_volt)</td></tr>
<tr class="memdesc:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the thermal voltage read from thermistor to temperature value.  <a href="#ga606d6f10e4bf215d5ecbae3ac5422220">More...</a><br /></td></tr>
<tr class="separator:ga606d6f10e4bf215d5ecbae3ac5422220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10bbe4117fc4502f3ffe303a46a1819"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab10bbe4117fc4502f3ffe303a46a1819">ccg_get_sensor_temperature</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, uint8_t sensor_id)</td></tr>
<tr class="memdesc:gab10bbe4117fc4502f3ffe303a46a1819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the temperature of the specified sensor.  <a href="#gab10bbe4117fc4502f3ffe303a46a1819">More...</a><br /></td></tr>
<tr class="separator:gab10bbe4117fc4502f3ffe303a46a1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e2b20a4fb4669bdb692d782124c94e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga81e2b20a4fb4669bdb692d782124c94e">register_thermistor_mapping_table</a> (cy_stc_pdstack_context_t *ptrPdStackcontext, const uint16_t *volt_temp_table)</td></tr>
<tr class="memdesc:ga81e2b20a4fb4669bdb692d782124c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function maps the thermal voltage read from thermistor to temperature value.  <a href="#ga81e2b20a4fb4669bdb692d782124c94e">More...</a><br /></td></tr>
<tr class="separator:ga81e2b20a4fb4669bdb692d782124c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5edab6846405e6f18f4d584bf20d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga2b5edab6846405e6f18f4d584bf20d42">uvdm_get_cur_nb_cmd</a> (void)</td></tr>
<tr class="memdesc:ga2b5edab6846405e6f18f4d584bf20d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current non blocking command opcode.  <a href="#ga2b5edab6846405e6f18f4d584bf20d42">More...</a><br /></td></tr>
<tr class="separator:ga2b5edab6846405e6f18f4d584bf20d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga88917f34345b4c2ffbd7f05e004cbbcb">uvdm_reset_nb_cmd_state</a> (void)</td></tr>
<tr class="memdesc:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets internal state and trackers related to Non Blocking flash write operation at the end of write operation.  <a href="#ga88917f34345b4c2ffbd7f05e004cbbcb">More...</a><br /></td></tr>
<tr class="separator:ga88917f34345b4c2ffbd7f05e004cbbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f4e6875801da6056c0c87f2785cae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaa6f4e6875801da6056c0c87f2785cae8">uvdm_enter_cy_alt_mode</a> (void)</td></tr>
<tr class="memdesc:gaa6f4e6875801da6056c0c87f2785cae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Mode Entry Handler This function is called when CCG enters CY Flashing Alternate mode.  <a href="#gaa6f4e6875801da6056c0c87f2785cae8">More...</a><br /></td></tr>
<tr class="separator:gaa6f4e6875801da6056c0c87f2785cae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0e712a6dac921e9a12c1519f162132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaee0e712a6dac921e9a12c1519f162132">uvdm_exit_cy_alt_mode</a> (void)</td></tr>
<tr class="memdesc:gaee0e712a6dac921e9a12c1519f162132"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Mode Exit Handler This function is called when CCG exits CY Flashing Alternate mode.  <a href="#gaee0e712a6dac921e9a12c1519f162132">More...</a><br /></td></tr>
<tr class="separator:gaee0e712a6dac921e9a12c1519f162132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48049492908c61b5a2bcb7869611cf89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga48049492908c61b5a2bcb7869611cf89">uvdm_get_flashing_mode</a> (void)</td></tr>
<tr class="memdesc:ga48049492908c61b5a2bcb7869611cf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CY Flashing Mode Status This function returns the current state of CY Flashing Alternate Mode.  <a href="#ga48049492908c61b5a2bcb7869611cf89">More...</a><br /></td></tr>
<tr class="separator:ga48049492908c61b5a2bcb7869611cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae932229b8c737c4f5f9605d19c64c439"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae932229b8c737c4f5f9605d19c64c439">uvdm_handle_device_reset</a> (uint32_t reset_sig)</td></tr>
<tr class="memdesc:gae932229b8c737c4f5f9605d19c64c439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle Device Reset Command This function handles device Reset command.  <a href="#gae932229b8c737c4f5f9605d19c64c439">More...</a><br /></td></tr>
<tr class="separator:gae932229b8c737c4f5f9605d19c64c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a21400ab342fd3552ed6791a834f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga45a21400ab342fd3552ed6791a834f88">uvdm_handle_cmd</a> (cy_stc_pdstack_context_t *context, uint32_t *rx_pkt, cy_pd_pd_do_t **vdm_rspn_pkt, uint8_t *vdo_count, <a class="el" href="group__group__ccgxAppCommon.html#ga3dd798364911c9f1c1e8c93db6976f8e">flash_cbk_t</a> flash_cb)</td></tr>
<tr class="memdesc:ga45a21400ab342fd3552ed6791a834f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">CY Flashing Alternate Mode UVDM Command Handler.  <a href="#ga45a21400ab342fd3552ed6791a834f88">More...</a><br /></td></tr>
<tr class="separator:ga45a21400ab342fd3552ed6791a834f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace292f2968c8a0fbe52bd5fb817219d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gace292f2968c8a0fbe52bd5fb817219d9">uvdm_qc_pps_handler</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint32_t *rx_pkt, cy_pd_pd_do_t **vdm_rspn_pkt, uint8_t *vdo_count)</td></tr>
<tr class="memdesc:gace292f2968c8a0fbe52bd5fb817219d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles all QC 5.0/4.0 Protocol UVDM commands.  <a href="#gace292f2968c8a0fbe52bd5fb817219d9">More...</a><br /></td></tr>
<tr class="separator:gace292f2968c8a0fbe52bd5fb817219d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9937839e0df56ab2ae92677a3c4fc89c">sln_flashing_uvdm_handler</a> (uint32_t *rx_pkt, cy_pd_pd_do_t *vdm_rspn_pkt, uint8_t *vdo_count, cy_en_pdstack_status_t *response_code)</td></tr>
<tr class="memdesc:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flashing Alternate Mode UVDM Command solution space extension handler.  <a href="#ga9937839e0df56ab2ae92677a3c4fc89c">More...</a><br /></td></tr>
<tr class="separator:ga9937839e0df56ab2ae92677a3c4fc89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9d243d72311578fc26927b0d8b3d18"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaba9d243d72311578fc26927b0d8b3d18">pwm_get_duty_cycle</a> (uint16_t vbus, uint16_t min_volt, uint16_t max_volt, uint16_t pwm_period)</td></tr>
<tr class="memdesc:gaba9d243d72311578fc26927b0d8b3d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function computes PWM duty cycle needed to generate requested VBUS.  <a href="#gaba9d243d72311578fc26927b0d8b3d18">More...</a><br /></td></tr>
<tr class="separator:gaba9d243d72311578fc26927b0d8b3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0176c9ee7a447e6d05e118ec148581c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0176c9ee7a447e6d05e118ec148581c3">vbus_ctrl_pwm_turn_on</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga0176c9ee7a447e6d05e118ec148581c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the PWM signal that turns VBus ON.  <a href="#ga0176c9ee7a447e6d05e118ec148581c3">More...</a><br /></td></tr>
<tr class="separator:ga0176c9ee7a447e6d05e118ec148581c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dbe2b31bf4f30e721228591b8420357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1dbe2b31bf4f30e721228591b8420357">vbus_ctrl_pwm_turn_off</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga1dbe2b31bf4f30e721228591b8420357"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function disables the PWM signal thus turning VBus OFF.  <a href="#ga1dbe2b31bf4f30e721228591b8420357">More...</a><br /></td></tr>
<tr class="separator:ga1dbe2b31bf4f30e721228591b8420357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga2bd5743b05e845340eea6f5c7054c0e0">vbus_ctrl_pwm_set_volt</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the Type-C VBUS voltage to requested level using PWM.  <a href="#ga2bd5743b05e845340eea6f5c7054c0e0">More...</a><br /></td></tr>
<tr class="separator:ga2bd5743b05e845340eea6f5c7054c0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gabcd12abd4dc2a695f0aca4fcc9e9b9be">vbus_ctrl_fb_enable</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function enables the Type-C VBUS voltage feedback logic.  <a href="#gabcd12abd4dc2a695f0aca4fcc9e9b9be">More...</a><br /></td></tr>
<tr class="separator:gabcd12abd4dc2a695f0aca4fcc9e9b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf7e37244c8eb9e2b5a85195fb5aa04c1">vbus_ctrl_fb_disable</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function disables the Type-C VBUS voltage feedback logic.  <a href="#gaf7e37244c8eb9e2b5a85195fb5aa04c1">More...</a><br /></td></tr>
<tr class="separator:gaf7e37244c8eb9e2b5a85195fb5aa04c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5534b8c6f4249d42f6719791ed55ff38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga5534b8c6f4249d42f6719791ed55ff38">vbus_ctrl_fb_set_volt</a> (cy_stc_pdstack_context_t *context, uint16_t volt_mV)</td></tr>
<tr class="memdesc:ga5534b8c6f4249d42f6719791ed55ff38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the Type-C VBUS voltage to requested level using FB (feedback).  <a href="#ga5534b8c6f4249d42f6719791ed55ff38">More...</a><br /></td></tr>
<tr class="separator:ga5534b8c6f4249d42f6719791ed55ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5f522c241cad2d51bac5a524312fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga7c5f522c241cad2d51bac5a524312fe7">vbus_ctrl_set_is_idle</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga7c5f522c241cad2d51bac5a524312fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns whether the vbus voltage transition is over or not.  <a href="#ga7c5f522c241cad2d51bac5a524312fe7">More...</a><br /></td></tr>
<tr class="separator:ga7c5f522c241cad2d51bac5a524312fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d395b4a3c133de574b7362d20540c8b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga7d395b4a3c133de574b7362d20540c8b">vbus_ctrl_get_trim_idac</a> (cy_stc_usbpd_context_t *context, uint16_t volt_mv)</td></tr>
<tr class="memdesc:ga7d395b4a3c133de574b7362d20540c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns trimmed IDAC value for the required voltage.  <a href="#ga7d395b4a3c133de574b7362d20540c8b">More...</a><br /></td></tr>
<tr class="separator:ga7d395b4a3c133de574b7362d20540c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7b269e24c8f4fec661273d02586fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga3d7b269e24c8f4fec661273d02586fa3">vdm_data_init</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga3d7b269e24c8f4fec661273d02586fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the VDM data from the configuration table.  <a href="#ga3d7b269e24c8f4fec661273d02586fa3">More...</a><br /></td></tr>
<tr class="separator:ga3d7b269e24c8f4fec661273d02586fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae954f67f0c7fc0fa4d0b77e86d39efa9">vdm_update_data</a> (cy_stc_pdstack_context_t *context, uint8_t id_vdo_cnt, uint8_t *id_vdo_p, uint8_t svid_vdo_cnt, uint8_t *svid_vdo_p, uint16_t mode_resp_len, uint8_t *mode_resp_p)</td></tr>
<tr class="memdesc:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows the VDM data for CCG to be changed.  <a href="#gae954f67f0c7fc0fa4d0b77e86d39efa9">More...</a><br /></td></tr>
<tr class="separator:gae954f67f0c7fc0fa4d0b77e86d39efa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b760125b3e49c10b90e064750acb68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga4b760125b3e49c10b90e064750acb68e">eval_vdm</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *vdm, cy_pdstack_vdm_resp_cbk_t vdm_resp_handler)</td></tr>
<tr class="memdesc:ga4b760125b3e49c10b90e064750acb68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible for analyzing and processing received VDM.  <a href="#ga4b760125b3e49c10b90e064750acb68e">More...</a><br /></td></tr>
<tr class="separator:ga4b760125b3e49c10b90e064750acb68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga4d682bedad7997cf296ac7b472ccb4e5">eval_enter_usb</a> (cy_stc_pdstack_context_t *context, const cy_stc_pdstack_pd_packet_t *eudo, cy_pdstack_app_resp_cbk_t app_resp_handler)</td></tr>
<tr class="memdesc:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to evaluate an Enter_USB request and report whether it should be accepted or rejected.  <a href="#ga4d682bedad7997cf296ac7b472ccb4e5">More...</a><br /></td></tr>
<tr class="separator:ga4d682bedad7997cf296ac7b472ccb4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga07f91bf53ad0b7c9ce8bc3727ef8512d">vdm_assign_port_num</a> (cy_stc_pdstack_context_t *context)</td></tr>
<tr class="memdesc:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign unique port number in a CCG3PA multiport system.  <a href="#ga07f91bf53ad0b7c9ce8bc3727ef8512d">More...</a><br /></td></tr>
<tr class="separator:ga07f91bf53ad0b7c9ce8bc3727ef8512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7f98716771b456abbe7bd132d8255f"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga5a7f98716771b456abbe7bd132d8255f">boot_validate_configtable</a> (uint8_t *table_p)</td></tr>
<tr class="memdesc:ga5a7f98716771b456abbe7bd132d8255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the configuration table specified.  <a href="#ga5a7f98716771b456abbe7bd132d8255f">More...</a><br /></td></tr>
<tr class="separator:ga5a7f98716771b456abbe7bd132d8255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edb32e1e45d388147185b053875f8fe"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1edb32e1e45d388147185b053875f8fe">boot_validate_fw</a> (<a class="el" href="group__group__ccgxAppCommon__data__structures.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *fw_metadata)</td></tr>
<tr class="memdesc:ga1edb32e1e45d388147185b053875f8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the firmware image associated with the given metadata.  <a href="#ga1edb32e1e45d388147185b053875f8fe">More...</a><br /></td></tr>
<tr class="separator:ga1edb32e1e45d388147185b053875f8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861588454fc735f940e5cdaaaa65cce9"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga861588454fc735f940e5cdaaaa65cce9">boot_handle_validate_fw_cmd</a> (<a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a> fw_mode)</td></tr>
<tr class="memdesc:ga861588454fc735f940e5cdaaaa65cce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the VALIDATE_FW command from HPI or UVDM.  <a href="#ga861588454fc735f940e5cdaaaa65cce9">More...</a><br /></td></tr>
<tr class="separator:ga861588454fc735f940e5cdaaaa65cce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86165e9d25f534b61706bce73087523a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga86165e9d25f534b61706bce73087523a">boot_get_wait_time</a> (void)</td></tr>
<tr class="memdesc:ga86165e9d25f534b61706bce73087523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the boot-wait delay configured for the application.  <a href="#ga86165e9d25f534b61706bce73087523a">More...</a><br /></td></tr>
<tr class="separator:ga86165e9d25f534b61706bce73087523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">boot_start</a> (void)</td></tr>
<tr class="memdesc:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the firmware binary to be loaded.  <a href="#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">More...</a><br /></td></tr>
<tr class="separator:gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12781921cca4e29d0c7516cc7431da31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga12781921cca4e29d0c7516cc7431da31">boot_check_for_valid_fw</a> (void)</td></tr>
<tr class="memdesc:ga12781921cca4e29d0c7516cc7431da31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the presence of alternate firmware waiting to be validated.  <a href="#ga12781921cca4e29d0c7516cc7431da31">More...</a><br /></td></tr>
<tr class="separator:ga12781921cca4e29d0c7516cc7431da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga8c99ecc08d4d9906ab7cea73c403241d">iecs_check_for_valid_fw</a> (uint8_t *first_row)</td></tr>
<tr class="memdesc:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a alternate firmware according to IECS SFWv command.  <a href="#ga8c99ecc08d4d9906ab7cea73c403241d">More...</a><br /></td></tr>
<tr class="separator:ga8c99ecc08d4d9906ab7cea73c403241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#unionfw__img__status__t">fw_img_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga734e1c7b35b3b51709c1997cf4b27adc">get_boot_mode_reason</a> (void)</td></tr>
<tr class="memdesc:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmap containing the reason for boot mode.  <a href="#ga734e1c7b35b3b51709c1997cf4b27adc">More...</a><br /></td></tr>
<tr class="separator:ga734e1c7b35b3b51709c1997cf4b27adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga06f1bc2f59ba8e0476dd349d1d2970eb">boot_jump_to_fw</a> (void)</td></tr>
<tr class="memdesc:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer control to the firmware binary identified by boot_start.  <a href="#ga06f1bc2f59ba8e0476dd349d1d2970eb">More...</a><br /></td></tr>
<tr class="separator:ga06f1bc2f59ba8e0476dd349d1d2970eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d02f78bb5df076263df291bb175ea0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae7d02f78bb5df076263df291bb175ea0">boot_get_boot_seq</a> (uint8_t fwid)</td></tr>
<tr class="memdesc:gae7d02f78bb5df076263df291bb175ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boot sequence number value for the specified firmware image.  <a href="#gae7d02f78bb5df076263df291bb175ea0">More...</a><br /></td></tr>
<tr class="separator:gae7d02f78bb5df076263df291bb175ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea7548753e977c3e1509c663150b39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga9ea7548753e977c3e1509c663150b39c">boot_update_fw_status</a> (void)</td></tr>
<tr class="memdesc:ga9ea7548753e977c3e1509c663150b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to validate firmware images and update image status.  <a href="#ga9ea7548753e977c3e1509c663150b39c">More...</a><br /></td></tr>
<tr class="separator:ga9ea7548753e977c3e1509c663150b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a19c1628a70d606e705085976c8c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga92a19c1628a70d606e705085976c8c3a">boot_jump_to_app</a> (uint32_t appId)</td></tr>
<tr class="memdesc:ga92a19c1628a70d606e705085976c8c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to jump from bootloader to application.  <a href="#ga92a19c1628a70d606e705085976c8c3a">More...</a><br /></td></tr>
<tr class="separator:ga92a19c1628a70d606e705085976c8c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37dda9a1fc8dfcbf1fc1df46a26e21b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga37dda9a1fc8dfcbf1fc1df46a26e21b1">flash_enter_mode</a> (bool is_enable, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga30137929a443c18c3d02c0a5158fc77e">flash_interface_t</a> mode, bool data_in_place)</td></tr>
<tr class="memdesc:ga37dda9a1fc8dfcbf1fc1df46a26e21b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle ENTER_FLASHING_MODE Command.  <a href="#ga37dda9a1fc8dfcbf1fc1df46a26e21b1">More...</a><br /></td></tr>
<tr class="separator:ga37dda9a1fc8dfcbf1fc1df46a26e21b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e00a477f64eff99c2c57b743a4beed3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga1e00a477f64eff99c2c57b743a4beed3">flash_access_get_status</a> (uint8_t modes)</td></tr>
<tr class="memdesc:ga1e00a477f64eff99c2c57b743a4beed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether flashing mode has been entered.  <a href="#ga1e00a477f64eff99c2c57b743a4beed3">More...</a><br /></td></tr>
<tr class="separator:ga1e00a477f64eff99c2c57b743a4beed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0981b2faa41026199bd7202ac4fce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0e0981b2faa41026199bd7202ac4fce4">flash_set_access_limits</a> (uint16_t start_row, uint16_t last_row, uint16_t md_row, uint16_t bl_last_row)</td></tr>
<tr class="memdesc:ga0e0981b2faa41026199bd7202ac4fce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set limits to the flash rows that can be accessed.  <a href="#ga0e0981b2faa41026199bd7202ac4fce4">More...</a><br /></td></tr>
<tr class="separator:ga0e0981b2faa41026199bd7202ac4fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8aa6a0c5dbdb43aabbba13b5f996eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae8aa6a0c5dbdb43aabbba13b5f996eb4">flash_get_access_limits</a> (uint16_t *access_limit_0, uint16_t *access_limit_1, uint16_t *access_limit_2, uint16_t *access_limit_3)</td></tr>
<tr class="memdesc:gae8aa6a0c5dbdb43aabbba13b5f996eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract current flash access limits.  <a href="#gae8aa6a0c5dbdb43aabbba13b5f996eb4">More...</a><br /></td></tr>
<tr class="separator:gae8aa6a0c5dbdb43aabbba13b5f996eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d6633acf126e6734b1121a88243f5c"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf2d6633acf126e6734b1121a88243f5c">flash_row_clear</a> (uint16_t row_num)</td></tr>
<tr class="memdesc:gaf2d6633acf126e6734b1121a88243f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the contents of the specified flash row.  <a href="#gaf2d6633acf126e6734b1121a88243f5c">More...</a><br /></td></tr>
<tr class="separator:gaf2d6633acf126e6734b1121a88243f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33465f26b6373367558a6828d3c062a"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab33465f26b6373367558a6828d3c062a">flash_row_write</a> (uint16_t row_num, uint8_t *data, <a class="el" href="group__group__ccgxAppCommon.html#ga3dd798364911c9f1c1e8c93db6976f8e">flash_cbk_t</a> cbk)</td></tr>
<tr class="memdesc:gab33465f26b6373367558a6828d3c062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given data to the specified flash row.  <a href="#gab33465f26b6373367558a6828d3c062a">More...</a><br /></td></tr>
<tr class="separator:gab33465f26b6373367558a6828d3c062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc72fbbb74b965c13ade195271c5e08"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga4bc72fbbb74b965c13ade195271c5e08">sflash_row_write</a> (uint16_t row_num, uint8_t *data)</td></tr>
<tr class="memdesc:ga4bc72fbbb74b965c13ade195271c5e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the given data to the specified User SFLASH row.  <a href="#ga4bc72fbbb74b965c13ade195271c5e08">More...</a><br /></td></tr>
<tr class="separator:ga4bc72fbbb74b965c13ade195271c5e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a462aee5dc2858a9594632fafaaf3f"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gaf3a462aee5dc2858a9594632fafaaf3f">sflash_row_read</a> (uint16_t row_num, uint8_t *data)</td></tr>
<tr class="memdesc:gaf3a462aee5dc2858a9594632fafaaf3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the specified User SFLASH row.  <a href="#gaf3a462aee5dc2858a9594632fafaaf3f">More...</a><br /></td></tr>
<tr class="separator:gaf3a462aee5dc2858a9594632fafaaf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1397878176494d34c481aa5799ae6df"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab1397878176494d34c481aa5799ae6df">flash_row_read</a> (uint16_t row_num, uint8_t *data)</td></tr>
<tr class="memdesc:gab1397878176494d34c481aa5799ae6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the specified flash row.  <a href="#gab1397878176494d34c481aa5799ae6df">More...</a><br /></td></tr>
<tr class="separator:gab1397878176494d34c481aa5799ae6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec52899db03a736518d26b78058a64f"><td class="memItemLeft" align="right" valign="top">cy_en_pdstack_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga8ec52899db03a736518d26b78058a64f">flash_set_app_priority</a> (<a class="el" href="group__group__ccgxAppCommon__enums.html#ga6633ac9f2f92f32e11085c5aca014b46">flash_app_priority_t</a> app_priority)</td></tr>
<tr class="memdesc:ga8ec52899db03a736518d26b78058a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the app boot priority flag.  <a href="#ga8ec52899db03a736518d26b78058a64f">More...</a><br /></td></tr>
<tr class="separator:ga8ec52899db03a736518d26b78058a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333040c32b526560e0189685c2477943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga333040c32b526560e0189685c2477943">instrumentation_init</a> (void)</td></tr>
<tr class="memdesc:ga333040c32b526560e0189685c2477943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize data structures associated with application instrumentation.  <a href="#ga333040c32b526560e0189685c2477943">More...</a><br /></td></tr>
<tr class="separator:ga333040c32b526560e0189685c2477943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad367c15b42304176602a24ab5cc659a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad367c15b42304176602a24ab5cc659a8">instrumentation_start</a> (void)</td></tr>
<tr class="memdesc:gad367c15b42304176602a24ab5cc659a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start any timers or tasks associated with application instrumentation.  <a href="#gad367c15b42304176602a24ab5cc659a8">More...</a><br /></td></tr>
<tr class="separator:gad367c15b42304176602a24ab5cc659a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gafe5f4d31cceda3638f9d2c3831c34cdc">instrumentation_task</a> (void)</td></tr>
<tr class="memdesc:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform tasks associated with application instrumentation.  <a href="#gafe5f4d31cceda3638f9d2c3831c34cdc">More...</a><br /></td></tr>
<tr class="separator:gafe5f4d31cceda3638f9d2c3831c34cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8347fe4114de4120402ee8a63fce69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gab8347fe4114de4120402ee8a63fce69b">instrumentation_register_cb</a> (<a class="el" href="group__group__ccgxAppCommon.html#gaa07a7ee21510d24dac6326ec163d8e3c">instrumentation_cb_t</a> cb)</td></tr>
<tr class="memdesc:gab8347fe4114de4120402ee8a63fce69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register solution level callback function to be executed when instrumentation fault occurs.  <a href="#gab8347fe4114de4120402ee8a63fce69b">More...</a><br /></td></tr>
<tr class="separator:gab8347fe4114de4120402ee8a63fce69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e95b70077dc7b63704262bff2cbf0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gad8e95b70077dc7b63704262bff2cbf0d">watchdog_timer_cb</a> (cy_timer_id_t id, void *callbackContext)</td></tr>
<tr class="memdesc:gad8e95b70077dc7b63704262bff2cbf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback to reset device if main loop has not been run as expected.  <a href="#gad8e95b70077dc7b63704262bff2cbf0d">More...</a><br /></td></tr>
<tr class="separator:gad8e95b70077dc7b63704262bff2cbf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0744c70187ce4c00822179005c6c0b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0744c70187ce4c00822179005c6c0b2b">i2c_scb_init</a> (cy_stc_pdstack_context_t *ptrPdStackContext, uint8_t scb_index, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a> mode, <a class="el" href="group__group__ccgxAppCommon__enums.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a> clock_freq, uint8_t slave_addr, uint8_t slave_mask, <a class="el" href="group__group__ccgxAppCommon__data__structures.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a> cb_fun_ptr, uint8_t *scratch_buffer, uint16_t scratch_buffer_size)</td></tr>
<tr class="memdesc:ga0744c70187ce4c00822179005c6c0b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure one of the I2C blocks as required.  <a href="#ga0744c70187ce4c00822179005c6c0b2b">More...</a><br /></td></tr>
<tr class="separator:ga0744c70187ce4c00822179005c6c0b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f4c815aac116cc730b5166787962a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga64f4c815aac116cc730b5166787962a1">i2c_scb_deinit</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga64f4c815aac116cc730b5166787962a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize a previously initialized SCB block.  <a href="#ga64f4c815aac116cc730b5166787962a1">More...</a><br /></td></tr>
<tr class="separator:ga64f4c815aac116cc730b5166787962a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378575c70ffa0b89f129860177848143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga378575c70ffa0b89f129860177848143">i2c_scb_write</a> (uint8_t scb_index, uint8_t *source_ptr, uint8_t size, uint8_t *count)</td></tr>
<tr class="memdesc:ga378575c70ffa0b89f129860177848143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the transmit FIFO associated with the I2C block.  <a href="#ga378575c70ffa0b89f129860177848143">More...</a><br /></td></tr>
<tr class="separator:ga378575c70ffa0b89f129860177848143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cbeecd552d2640e432e2c57111f35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#gae2cbeecd552d2640e432e2c57111f35c">i2c_reset</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:gae2cbeecd552d2640e432e2c57111f35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the I2C block specified.  <a href="#gae2cbeecd552d2640e432e2c57111f35c">More...</a><br /></td></tr>
<tr class="separator:gae2cbeecd552d2640e432e2c57111f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga472c6396fd36ea9ddda27cc6ef9e6986">i2c_slave_ack_ctrl</a> (uint8_t scb_index, bool enable)</td></tr>
<tr class="memdesc:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable the I2C slave acknowledgement.  <a href="#ga472c6396fd36ea9ddda27cc6ef9e6986">More...</a><br /></td></tr>
<tr class="separator:ga472c6396fd36ea9ddda27cc6ef9e6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c52132c4b3089409dac99443ed4a231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga2c52132c4b3089409dac99443ed4a231">i2c_scb_is_idle</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga2c52132c4b3089409dac99443ed4a231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the I2C block is idle.  <a href="#ga2c52132c4b3089409dac99443ed4a231">More...</a><br /></td></tr>
<tr class="separator:ga2c52132c4b3089409dac99443ed4a231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga706524d3e4a8d5a195d7cb940e9149e4">i2c_scb_enable_wakeup</a> (uint8_t scb_index)</td></tr>
<tr class="memdesc:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable deep-sleep wakeup due to address match on the specified SCB block.  <a href="#ga706524d3e4a8d5a195d7cb940e9149e4">More...</a><br /></td></tr>
<tr class="separator:ga706524d3e4a8d5a195d7cb940e9149e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__ccgxAppCommon__functions.html#ga0d55f6c9d1f49de78bd51450f176d24d">i2c_timer_cb</a> (cy_timer_id_t id, void *callbackContext)</td></tr>
<tr class="memdesc:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer callback that indicates I2C transaction that has timed out.  <a href="#ga0d55f6c9d1f49de78bd51450f176d24d">More...</a><br /></td></tr>
<tr class="separator:ga0d55f6c9d1f49de78bd51450f176d24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga987e808055c53d2d3138625e94ce0c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987e808055c53d2d3138625e94ce0c8d">&#9670;&nbsp;</a></span>app_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application level init function. </p>
<p>This function performs any Application level initialization required for the CCG solution. This should be called before calling the dpmInit function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga41c615b2b4410be1d5f90f454b2a6b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c615b2b4410be1d5f90f454b2a6b5e">&#9670;&nbsp;</a></span>app_is_port_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_port_enabled </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the specified PD port is enabled in the system configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the port is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="gad066f25e9c4975fadc25bfbdeeb88bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad066f25e9c4975fadc25bfbdeeb88bb1">&#9670;&nbsp;</a></span>app_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t app_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for application level asynchronous tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success, 0 in case of task handling error. </dd></dl>

</div>
</div>
<a id="ga3dd2bdc30aa59479a77d28857789cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd2bdc30aa59479a77d28857789cff2">&#9670;&nbsp;</a></span>app_get_callback_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_stc_pdstack_app_cbk_t* app_get_callback_ptr </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return the App callback structure pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Application callback structure pointer </dd></dl>

</div>
</div>
<a id="gad1cd70e9e221ab79f671ce87143afe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cd70e9e221ab79f671ce87143afe79">&#9670;&nbsp;</a></span>app_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handler for event notifications from the PD stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context.. </td></tr>
    <tr><td class="paramname">evt</td><td>Type of event to be handled. </td></tr>
    <tr><td class="paramname">dat</td><td>Data associated with the event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaaadfeec58882d5ff9434208ef0f07af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaadfeec58882d5ff9434208ef0f07af6">&#9670;&nbsp;</a></span>app_get_resp_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_resp_t* app_get_resp_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the application provide PD command response buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port corresponding to the command and response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the response buffer. </dd></dl>

</div>
</div>
<a id="ga93d7c64e58560deaffc50953f364124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d7c64e58560deaffc50953f364124b">&#9670;&nbsp;</a></span>app_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#structapp__status__t">app_status_t</a>* app_get_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get handle to structure containing information about the system status for a PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port to be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the system information structure. </dd></dl>

</div>
</div>
<a id="gae9332fe6e441fbc8c3ee70b1e90a0f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9332fe6e441fbc8c3ee70b1e90a0f77">&#9670;&nbsp;</a></span>app_update_sys_battery_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_sys_battery_status </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bsdo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the system battery status. </p>
<p>Called from HPI write handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bsdo</td><td>Battery Status Data Object Value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37ab189c440f4561aebd58aa78d6621d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ab189c440f4561aebd58aa78d6621d">&#9670;&nbsp;</a></span>app_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the APP handlers are ready to allow device deep sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>true if APP handler is idle, false otherwise. </dd></dl>

</div>
</div>
<a id="ga5e5b5fbf3a976f0f88688f3bca95908c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5b5fbf3a976f0f88688f3bca95908c">&#9670;&nbsp;</a></span>app_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the APP handler state after CCG device wakes from deep-sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9eb8e346586b2e372a4d4303063c386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb8e346586b2e372a4d4303063c386e">&#9670;&nbsp;</a></span>system_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to place CCG device in power saving mode if possible. </p>
<p>This function places the CCG device in power saving deep sleep mode if possible. The function checks for each interface (PD, HPI etc.) being idle and then enters sleep mode with the appropriate wake-up triggers. If the device enters sleep mode, the function will only return after the device has woken up. </p><dl class="section return"><dt>Returns</dt><dd>true if the device went into sleep, false otherwise. </dd></dl>

</div>
</div>
<a id="ga257a11c7349f3f402f3b5071e8ac9b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257a11c7349f3f402f3b5071e8ac9b04">&#9670;&nbsp;</a></span>vconn_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vconn_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables VCONN power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">channel</td><td>Selected CC line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if VConn was turned ON; false if NOT. </dd></dl>

</div>
</div>
<a id="ga635c202b5b7794044060fe53283c0ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga635c202b5b7794044060fe53283c0ca1">&#9670;&nbsp;</a></span>vconn_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vconn_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables VCONN power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">channel</td><td>Selected CC line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga62b195995f6b6224c6284f4224bdadf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b195995f6b6224c6284f4224bdadf0">&#9670;&nbsp;</a></span>vconn_is_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vconn_is_present </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if power is present on VConn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power is present on VConn, else returns false </dd></dl>

</div>
</div>
<a id="ga424d434bc2b8a173c14b56842737a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424d434bc2b8a173c14b56842737a3ef">&#9670;&nbsp;</a></span>vbus_is_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vbus_is_present </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>per</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if power is present on VBus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt</td><td>Voltage in mV units. </td></tr>
    <tr><td class="paramname">per</td><td>Threshold margin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power is present on VBus, else returns false </dd></dl>

</div>
</div>
<a id="ga0c527850e02f68c9c1072b58921fe533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c527850e02f68c9c1072b58921fe533">&#9670;&nbsp;</a></span>vbus_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vbus_get_value </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function return current VBUS voltage in mV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VBUS voltage in mV </dd></dl>

</div>
</div>
<a id="ga631d47609bcac183d47133c3a0bc55e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga631d47609bcac183d47133c3a0bc55e2">&#9670;&nbsp;</a></span>vbus_discharge_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_discharge_on </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function turns on discharge FET on selected port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga370b31502ed6b6794b00652450930ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370b31502ed6b6794b00652450930ce1">&#9670;&nbsp;</a></span>vbus_discharge_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_discharge_off </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function turns off discharge FET on selected port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga197c17a51bae827c86006723dd28b561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga197c17a51bae827c86006723dd28b561">&#9670;&nbsp;</a></span>system_vconn_ocp_en()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_vconn_ocp_en </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable vconn ocp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cbk</td><td>OCP callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false if parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga3ceb8e80d5c01c5157484bf30f85925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ceb8e80d5c01c5157484bf30f85925d">&#9670;&nbsp;</a></span>system_vconn_ocp_dis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_vconn_ocp_dis </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable vconn ocp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga128a0e6e3970ac63087ee51a55999429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga128a0e6e3970ac63087ee51a55999429">&#9670;&nbsp;</a></span>app_ovp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_ovp_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>ovp_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and configure the Over-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Expected VBus voltage. </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
    <tr><td class="paramname">ovp_cb</td><td>Callback function to be triggered when there is an OV event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9b919168d11183f7e6d5816b773a327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b919168d11183f7e6d5816b773a327e">&#9670;&nbsp;</a></span>app_ovp_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_ovp_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Over-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1d2dc98c12ea2ccc48072cb1b911a077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2dc98c12ea2ccc48072cb1b911a077">&#9670;&nbsp;</a></span>system_vconn_scp_en()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_vconn_scp_en </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enable vconn scp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cbk</td><td>SCP callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false if parameters are invalid. </dd></dl>

</div>
</div>
<a id="ga6a402bfbaeee99955bb644bb5ee19838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a402bfbaeee99955bb644bb5ee19838">&#9670;&nbsp;</a></span>system_vconn_scp_dis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_vconn_scp_dis </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disable vconn scp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3c78977d8cc1e0753a16ea9bd1269b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c78977d8cc1e0753a16ea9bd1269b41">&#9670;&nbsp;</a></span>app_uvp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_uvp_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_cb_vbus_fault_t&#160;</td>
          <td class="paramname"><em>uvp_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable and configure the Under-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Expected VBus voltage. </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
    <tr><td class="paramname">uvp_cb</td><td>Callback function to be triggered when there is an UV event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga8a8979eabd2d152c80b65239cf08c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8979eabd2d152c80b65239cf08c601">&#9670;&nbsp;</a></span>app_uvp_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_uvp_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pfet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Under-Voltage protection circuitry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pfet</td><td>Whether PFET is used for the power supply control. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae2a1416d128b2d3ddb2444c4ea645750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a1416d128b2d3ddb2444c4ea645750">&#9670;&nbsp;</a></span>app_update_bc_src_snk_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_bc_src_snk_support </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the BC 1.2 source support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">enable</td><td>Whether BC 1.2 source support should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa2efd4f1d1b83a9cdda00443a3fd6209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2efd4f1d1b83a9cdda00443a3fd6209">&#9670;&nbsp;</a></span>app_update_bc_src_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_bc_src_support </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the BC 1.2 source support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">enable</td><td>Whether BC 1.2 support should be enabled or disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga039b5432fa3f08d7671a83b853e634fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga039b5432fa3f08d7671a83b853e634fe">&#9670;&nbsp;</a></span>app_update_sys_pwr_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_sys_pwr_state </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update the system power state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Current system power state: 0=S0, Non-zero=other states. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14afafc3b67eb20f3ed48beb857fbbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14afafc3b67eb20f3ed48beb857fbbb3">&#9670;&nbsp;</a></span>app_disable_pd_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t app_disable_pd_port </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_dpm_typec_cmd_cbk_t&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for PD port disable. </p>
<p>This function is used to ensure that any application level state associated with a faulty connection are cleared when the user wants to disable a PD port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">cbk</td><td>Callback to be called after operation is complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS on success, appropriate error code otherwise. </dd></dl>

</div>
</div>
<a id="gad09a34f2ede57568665767f0abe152dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad09a34f2ede57568665767f0abe152dd">&#9670;&nbsp;</a></span>app_validate_configtable_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_validate_configtable_offsets </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the configuration table specified. </p>
<p>Each copy of CCGx firmware on the device flash contains an embedded configuration table that defines the runtime behaviour of the CCGx device. This function checks whether the configuration table located at the specified location is valid (has valid offsets). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD Stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the table is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="ga1b1f896ef1a80a0a4e4ce42ccb80f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1f896ef1a80a0a4e4ce42ccb80f76a">&#9670;&nbsp;</a></span>ccg_app_task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_app_task_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize CCGx periodic application level tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9f2f76f0c59231e3c1d65082b42c48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f2f76f0c59231e3c1d65082b42c48dc">&#9670;&nbsp;</a></span>app_bc_12_sm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_bc_12_sm_start </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the simplified BC 1.2 (DCP/CDP) state machine for CCG5 device on detection of a Type-C sink connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga72e89461be3b772f36c3e68e0aca3615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e89461be3b772f36c3e68e0aca3615">&#9670;&nbsp;</a></span>sln_pd_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sln_pd_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solution handler for PD events reported from the stack. </p>
<p>The function provides all PD events to the solution. For a solution supporting HPI, the solution function should re-direct the calls to hpi_pd_event_handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">evt</td><td>Event that is being notified. </td></tr>
    <tr><td class="paramname">data</td><td>Data associated with the event. This is an opaque pointer that needs to be de-referenced based on event type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5091a22398d46f8d870ec769bec40853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5091a22398d46f8d870ec769bec40853">&#9670;&nbsp;</a></span>mux_ctrl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mux_ctrl_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Type-C Data Mux for a specific PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the MUX is initialized successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="ga067c4788c2e2c0b38fa1631d05f8adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067c4788c2e2c0b38fa1631d05f8adab">&#9670;&nbsp;</a></span>mux_ctrl_bb_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mux_ctrl_bb_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>polarity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable BB device enumeration on the board. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
    <tr><td class="paramname">polarity</td><td>PD connection (plug) orientation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe5c906c34d42ac62e4aab9b7f19a278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5c906c34d42ac62e4aab9b7f19a278">&#9670;&nbsp;</a></span>fault_handler_init_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fault_handler_init_vars </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize fault-handling related variables from the configuration table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the configuration table is invalid, true otherwise. </dd></dl>

</div>
</div>
<a id="ga6df995227d611d600d71fc616589e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6df995227d611d600d71fc616589e086">&#9670;&nbsp;</a></span>fault_handler_register_cbks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_register_cbks </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register solution space function handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gab57725e00da96b711d9567afd66a2f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57725e00da96b711d9567afd66a2f93">&#9670;&nbsp;</a></span>fault_handler_clear_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_clear_counts </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the fault occurrence counts after a Type-C detach is detected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae13092468da8be42cf1497719f2392d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13092468da8be42cf1497719f2392d3">&#9670;&nbsp;</a></span>fault_handler_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fault_handler_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform any fault handler related tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad49cfd10d337a7d188bf27f25193a35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49cfd10d337a7d188bf27f25193a35b">&#9670;&nbsp;</a></span>fault_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fault_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle any application events associated with fault handling logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">evt</td><td>Event code. </td></tr>
    <tr><td class="paramname">dat</td><td>Data associated with the event code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event does not need to be passed up to the solution layer. </dd></dl>

</div>
</div>
<a id="ga1cf3cc2e31b87f603f5da78321083a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf3cc2e31b87f603f5da78321083a02">&#9670;&nbsp;</a></span>app_otp_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_otp_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Over-Temperature Protection logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gaf1e6cabefd046b9b84a228775afddd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e6cabefd046b9b84a228775afddd54">&#9670;&nbsp;</a></span>app_otp_check_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_otp_check_temp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform OTP check. </p>
<p>This function is called from app task </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae5a0e8856cdbd01ca2f848245c6b8a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a0e8856cdbd01ca2f848245c6b8a60">&#9670;&nbsp;</a></span>app_otp_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_otp_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of Over-Temperature Protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns True if Over-Temperature condition is active, otherwise false. </dd></dl>

</div>
</div>
<a id="gaf604c26013002a29a736c0b618c405cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf604c26013002a29a736c0b618c405cf">&#9670;&nbsp;</a></span>vconn_change_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vconn_change_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>vconn_on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to handle VConn supply state change due to OCP condition or V5V supply change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">vconn_on</td><td>Whether VConn has just turned ON or OFF. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2e060850f2d33f08d9ae4654ee7629f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e060850f2d33f08d9ae4654ee7629f3">&#9670;&nbsp;</a></span>app_is_host_hpd_virtual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_host_hpd_virtual </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the solution is configured to support virtual HPD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if virtual HPD is enabled. </dd></dl>

</div>
</div>
<a id="ga1cbafde1e08b787d570f69c5e8378b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbafde1e08b787d570f69c5e8378b10">&#9670;&nbsp;</a></span>set_custom_host_cap_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_custom_host_cap_control </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>host_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to update custom host capabilities HPI register with the value provided by EC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port on which the register is being updated. </td></tr>
    <tr><td class="paramname">host_config</td><td>Value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the custom host capabilities is set otherwise false. </dd></dl>

</div>
</div>
<a id="ga4a21460df3b3ee4cc8f22b2b856e668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a21460df3b3ee4cc8f22b2b856e668b">&#9670;&nbsp;</a></span>app_power_share_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_power_share_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the power sharing across ports on a dual-port CCG device. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac68110542f5463158989749753e37632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac68110542f5463158989749753e37632">&#9670;&nbsp;</a></span>app_contract_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_contract_handler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called at the end of a PD contract to check whether any role swaps need to be triggered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="ga619740c578362ebb487c68e54c86c83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga619740c578362ebb487c68e54c86c83e">&#9670;&nbsp;</a></span>pd_get_ptr_cfg_sub_tbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pd_get_ptr_cfg_sub_tbl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to retrieve desired sub-table from the configuration table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>PD port index. </td></tr>
    <tr><td class="paramname">type</td><td>Type of sub-table to be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to config sub table </dd></dl>

</div>
</div>
<a id="gabcee026b0d0cdeec924f9b46abcc479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcee026b0d0cdeec924f9b46abcc479c">&#9670;&nbsp;</a></span>timer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void timer_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize timer callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08054935adf625b7ed2d5e6076f8ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08054935adf625b7ed2d5e6076f8ba52">&#9670;&nbsp;</a></span>app_conf_for_faulty_dev_removal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_conf_for_faulty_dev_removal </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the CCG to wait for physical detach of faulty port partner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa561ba390c4db0bce122405dedffb75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa561ba390c4db0bce122405dedffb75d">&#9670;&nbsp;</a></span>app_port_fault_count_exceeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_port_fault_count_exceeded </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any fault count has exceeded limit for the specified PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if fault count has exceeded limit, false otherwise. </dd></dl>

</div>
</div>
<a id="ga9fbef10605b1f75b463c5bc07f3b04e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbef10605b1f75b463c5bc07f3b04e6">&#9670;&nbsp;</a></span>app_retrieve_fault_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t app_retrieve_fault_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To retrieve the fault sticky status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns sticky fault status. </dd></dl>

</div>
</div>
<a id="ga4ae3f90a4aac402a773faf295e871e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae3f90a4aac402a773faf295e871e29">&#9670;&nbsp;</a></span>register_soln_function_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_soln_function_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapp__sln__handler__t.html">app_sln_handler_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function registers solution level functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
    <tr><td class="paramname">handler</td><td>pointer to solution handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga48b852c3817507e93ac4f0cc8f5f58ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b852c3817507e93ac4f0cc8f5f58ba">&#9670;&nbsp;</a></span>app_vdm_layer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_vdm_layer_reset </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restarts alternate mode layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the alternate mode resetted, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3fe0ced862d3cbf35b36334f47490339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe0ced862d3cbf35b36334f47490339">&#9670;&nbsp;</a></span>app_is_typec_attached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_is_typec_attached </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status of Type-C attach on all Type-C ports. </p>
<dl class="section return"><dt>Returns</dt><dd>True if any port is attached. False if all ports are unattached. </dd></dl>

</div>
</div>
<a id="ga41a79606a8a811589791b10712774b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a79606a8a811589791b10712774b85">&#9670;&nbsp;</a></span>pd_vbat_gnd_scp_cbk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_vbat_gnd_scp_cbk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function from interrupt handler to handle VBAT-GND SCP fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8da3d9d084dd05dbaa510b065198b6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da3d9d084dd05dbaa510b065198b6b8">&#9670;&nbsp;</a></span>pd_bb_ilim_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_bb_ilim_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function from interrupt handler to handle buck-boost inductor current limit fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a90b6242e88c2affb0817cff513751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a90b6242e88c2affb0817cff513751e">&#9670;&nbsp;</a></span>pd_brown_out_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_brown_out_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for VDDD regulator brown out fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab9f3f3e4de83a213874c00f309b1751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9f3f3e4de83a213874c00f309b1751">&#9670;&nbsp;</a></span>pd_vreg_inrush_det_fault_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pd_vreg_inrush_det_fault_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for VDDD regulator inrush current fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>USBPD Context pointer.</td></tr>
    <tr><td class="paramname">state</td><td>Current state of fault. True indicates fault is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7dda31bfc7bf591351222ad2d8eb5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7dda31bfc7bf591351222ad2d8eb5c7">&#9670;&nbsp;</a></span>send_src_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool send_src_info </td>
          <td>(</td>
          <td class="paramtype">struct cy_stc_pdstack_context *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback Function to decide whether to send source info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if source info can be send </dd></dl>

</div>
</div>
<a id="gafdfb8d6bfce9507aea95f3f5451a7789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfb8d6bfce9507aea95f3f5451a7789">&#9670;&nbsp;</a></span>bc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the Battery Charging block. </p>
<p>This should be called one time only at system startup for each port on which the BC state machine needs to run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gafae1304bc5281a4decfa9c205d720a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafae1304bc5281a4decfa9c205d720a47">&#9670;&nbsp;</a></span>bc_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cy_stc_legacy_charging_cfg_t* bc_get_config </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the current Battery Charging configuration. </p>
<p>If the LEGACY_DYN_CFG_ENABLE macro is enabled, then this returns the latest configuration. If not, returns the configuration structure from the configuration table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to current configuration data. This should not be modified by the caller. </dd></dl>

</div>
</div>
<a id="ga83c842c6a36610c26e86156463f956e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83c842c6a36610c26e86156463f956e1">&#9670;&nbsp;</a></span>bc_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_start </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga013e4bb33c056c7899d9ba01f9e8ca5a">bc_port_role_t</a>&#160;</td>
          <td class="paramname"><em>port_role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts the Battery Charging block with desired configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">port_role</td><td>Battery Charging port power role. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="ga08bb91b4849ec00a7feed096d9e31dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bb91b4849ec00a7feed096d9e31dce">&#9670;&nbsp;</a></span>bc_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_stop </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the Battery Charging block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gaa609c3d5f131d1259a9416fd5a7a5979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa609c3d5f131d1259a9416fd5a7a5979">&#9670;&nbsp;</a></span>bc_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether the BC module is active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the BC module is running, false otherwise. </dd></dl>

</div>
</div>
<a id="gab4b0ddf5ed205702d4628341428a3bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b0ddf5ed205702d4628341428a3bf4">&#9670;&nbsp;</a></span>bc_fsm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t bc_fsm </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles the Battery Charging block state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_usbpd_status_t </dd></dl>

</div>
</div>
<a id="gaeddb10ad3d52f33172877e7b46b7611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeddb10ad3d52f33172877e7b46b7611a">&#9670;&nbsp;</a></span>bc_port_is_cdp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_port_is_cdp </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the port is currently functioning as a CDP (Charging Downstream Port). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if port is CDP, false otherwise. </dd></dl>

</div>
</div>
<a id="gae90d6d317d6183bc5e277a66a3e9de18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae90d6d317d6183bc5e277a66a3e9de18">&#9670;&nbsp;</a></span>bc_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_sleep </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function puts the Battery Charging block to sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the sleep is successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ga3638da0a0c79743d5db6127741635079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3638da0a0c79743d5db6127741635079">&#9670;&nbsp;</a></span>bc_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function wakes up the Battery Charging block. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if wakeup successful, false otherwise </dd></dl>

</div>
</div>
<a id="ga1be37ea9b028a57c60684196e3fcf905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be37ea9b028a57c60684196e3fcf905">&#9670;&nbsp;</a></span>bc_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__group__ccgxAppCommon__data__structures.html#structbc__status__t">bc_status_t</a>* bc_get_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the current status of the BC state machine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to BC status. The structure must not be modified by caller. </dd></dl>

</div>
</div>
<a id="gaa8eb59136a5bc414a24d202a88ab500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8eb59136a5bc414a24d202a88ab500b">&#9670;&nbsp;</a></span>bc_pd_event_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_pd_event_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_app_evt_t&#160;</td>
          <td class="paramname"><em>evt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function handles events from USB-PD Device Policy Manager. </p>
<p>This event handler is used call the bc_start and bc_stop functions to enable/disable the BC state machine at appropriate times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt</td><td>PD event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad52979fd63b3499dfd069ba41d2bf28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52979fd63b3499dfd069ba41d2bf28a">&#9670;&nbsp;</a></span>bc_set_bc_evt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_set_bc_evt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evt_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets an event status for the BC state machine to process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt_mask</td><td>Event Mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga736c168139e927c108d7ef55e90fc7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736c168139e927c108d7ef55e90fc7a9">&#9670;&nbsp;</a></span>bc_clear_bc_evt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_clear_bc_evt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evt_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears one or more BC events after the state machine has dealt with them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">evt_mask</td><td>Event Mask to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3a9699353dc54d34ea5dce1c71b0466c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9699353dc54d34ea5dce1c71b0466c">&#9670;&nbsp;</a></span>ccg_get_system_max_pdp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_system_max_pdp </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the port PDP value. </p>
<p>If PD3.0 is supported, then the value returned will the PDP value from the extended source cap If PD3.0 is not supported, then the preconfigured PDP value will be returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>System PDP </dd></dl>

</div>
</div>
<a id="gab5d2d443f2be2f1b549e8835870ddf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d2d443f2be2f1b549e8835870ddf95">&#9670;&nbsp;</a></span>qc_set_cf_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qc_set_cf_limit </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables Current Foldback on the port when in QC mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga9aa42ffefc5ac3d753b11847cb398fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aa42ffefc5ac3d753b11847cb398fab">&#9670;&nbsp;</a></span>bc_afc_form_vi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bc_afc_form_vi </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function forms the new AFC source capabilities based on the power passed. </p>
<p>The number of source caps for AFC will be same as that configured in the table. This function does not modify the voltage value of the source cap in the config table. The current will be updated based on the power value and the AFC voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gabcee615842c5c62ebf8d36e83a919afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcee615842c5c62ebf8d36e83a919afe">&#9670;&nbsp;</a></span>bc_12_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bc_12_get_status </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current BC 1.2 status for a PD port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BC 1.2 status. </dd></dl>

</div>
</div>
<a id="ga0755713453a2b8aed13e4e11ae94354c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0755713453a2b8aed13e4e11ae94354c">&#9670;&nbsp;</a></span>bc_is_qc_afc_charging_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_qc_afc_charging_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether the QC or AFC charging modes are active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if QC or AFC charging modes are active, false otherwise. </dd></dl>

</div>
</div>
<a id="gaf9f0a988f1e8c31a092c4f2c45256ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9f0a988f1e8c31a092c4f2c45256ad7">&#9670;&nbsp;</a></span>bc_is_bc_charging_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_bc_charging_active </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether legacy charging modes are active or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if legacy charging modes are active, false otherwise. </dd></dl>

</div>
</div>
<a id="ga92ebf8bad9d327493c62bdf056fd2585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ebf8bad9d327493c62bdf056fd2585">&#9670;&nbsp;</a></span>bc_is_bc_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bc_is_bc_connected </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether legacy charging connect negotiated or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if legacy charging connect is negotiated, false otherwise. </dd></dl>

</div>
</div>
<a id="gae2b8bb762de654cf691bfa2d4910b373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2b8bb762de654cf691bfa2d4910b373">&#9670;&nbsp;</a></span>gpio_set_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the GPIO to the required state. </p>
<p>This function updates the output state of a GPIO pin. The API does not do any error check and will just update the output state. It is the caller's responsibility to ensure that the HSIOM and drive mode settings for the pin have been selected as required.</p>
<p>Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be updated. </td></tr>
    <tr><td class="paramname">value</td><td>Value to drive on the pin: 0=LOW, 1=HIGH.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon__functions.html#ga05d2ba473562725e5d2f2216f63dc504" title="Select the IO mode for a CCG device IO. ">hsiom_set_config</a> </dd>
<dd>
<a class="el" href="group__group__ccgxAppCommon__functions.html#gac81d9271ce686992981a09ab31509c0f" title="Configure the GPIO with the desired drive mode. ">gpio_set_drv_mode</a> </dd></dl>

</div>
</div>
<a id="gab4a340d82409454a45acd6068e69419b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4a340d82409454a45acd6068e69419b">&#9670;&nbsp;</a></span>gpio_read_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpio_read_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GPIO current state. </p>
<p>This API retrieves the current state of a pin, assuming it has been configured as a GPIO. It is the caller's responsibility to ensure that the HSIOM and drive mode settings for the pin have been set correctly.</p>
<p>The API does not do any error check and will just read the GPIO state register. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current state of the pin.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon__functions.html#ga05d2ba473562725e5d2f2216f63dc504" title="Select the IO mode for a CCG device IO. ">hsiom_set_config</a> </dd>
<dd>
<a class="el" href="group__group__ccgxAppCommon__functions.html#gac81d9271ce686992981a09ab31509c0f" title="Configure the GPIO with the desired drive mode. ">gpio_set_drv_mode</a> </dd></dl>

</div>
</div>
<a id="gac81d9271ce686992981a09ab31509c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81d9271ce686992981a09ab31509c0f">&#9670;&nbsp;</a></span>gpio_set_drv_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_drv_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a>&#160;</td>
          <td class="paramname"><em>drv_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the GPIO with the desired drive mode. </p>
<p>This API updates the drive mode for the selected CCG device IO. The API does not do any error check and will just set the drive mode of GPIO. The caller should ensure that the HSIOM setting for the pin has been selected correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">drv_mode</td><td>Desired drive mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga061aa6d28ccf3abfd22e9add75199b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061aa6d28ccf3abfd22e9add75199b9c">&#9670;&nbsp;</a></span>gpio_int_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_int_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>int_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the GPIO with the desired interrupt setting. </p>
<p>This API configures the interrupt mode for the specified GPIO. It does not do any error check and will just configure the GPIO interrupt setting. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">int_mode</td><td>Desired interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6213d69fa12f6d561f97cb17358d9b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6213d69fa12f6d561f97cb17358d9b40">&#9670;&nbsp;</a></span>gpio_register_intr_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t gpio_register_intr_cb </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga05e5e6e022e2fb8b6a30b303f9a0d2fe">gpio_intr_cb_t</a>&#160;</td>
          <td class="paramname"><em>intr_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback to be called when a GPIO interrupt associated with a specific port is triggered. </p>
<p>The gpio_int_set_config should be used to configure the desired interrupts for each of the relevant pins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>GPIO port on which interrupts are to be updated. </td></tr>
    <tr><td class="paramname">intr_cb</td><td>Pointer to callback function to be called on interrupt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS on success, appropriate error code otherwise. </dd></dl>

</div>
</div>
<a id="ga05d2ba473562725e5d2f2216f63dc504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d2ba473562725e5d2f2216f63dc504">&#9670;&nbsp;</a></span>hsiom_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hsiom_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a>&#160;</td>
          <td class="paramname"><em>hsiom_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the IO mode for a CCG device IO. </p>
<p>This API configures the IO mode for a CCG device IO. It does not do any error check and will just set the HSIOM configuration for the GPIO. Care should be taken to make sure that wrong indexing is not done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">hsiom_mode</td><td>Desired IO mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon__enums.html#ga21929450529e4881bbfac8628bd82577" title="Various IO matrix configuration modes. ">hsiom_mode_t</a> </dd></dl>

</div>
</div>
<a id="gae5a37e81fc0c0bf20c918954056bfa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a37e81fc0c0bf20c918954056bfa83">&#9670;&nbsp;</a></span>gpio_hsiom_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_hsiom_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga21929450529e4881bbfac8628bd82577">hsiom_mode_t</a>&#160;</td>
          <td class="paramname"><em>hsiom_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga91de19d5edf75a3e58f9d2c9371c30f5">gpio_dm_t</a>&#160;</td>
          <td class="paramname"><em>drv_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single function for complete configuration of a CCG IO. </p>
<p>This is a single API which can be used to configure the IO mode, the drive mode and the current value of a CCG device IO. No error checks are performed, and the caller should ensure that the settings provided are valid for the selected IO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be configured. </td></tr>
    <tr><td class="paramname">hsiom_mode</td><td>Desired IO mode. </td></tr>
    <tr><td class="paramname">drv_mode</td><td>Desired drive mode. </td></tr>
    <tr><td class="paramname">value</td><td>Desired output state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gac5e3a8c83eb6bae572d7e18cea59edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e3a8c83eb6bae572d7e18cea59edd3">&#9670;&nbsp;</a></span>gpio_set_lvttl_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_lvttl_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the input buffer voltage for a port to LVTTL. </p>
<p>This API sets the input buffer voltage for a complete CCG device port to LVTTL levels. This is required to be set for ports that include the IOs used for the I2C based HPI interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>IO port to be configured for LVTTL levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga7ea5408d9cf9f6cdeac7eaddaedf39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea5408d9cf9f6cdeac7eaddaedf39f8">&#9670;&nbsp;</a></span>gpio_get_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpio_get_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the interrupt status on a specific GPIO. </p>
<p>This function checks whether there are any active interrupts on the specified GPIO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interrupt is active, false otherwise. </dd></dl>

</div>
</div>
<a id="ga68bf50943ae651b4a773d6ada7d8da48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68bf50943ae651b4a773d6ada7d8da48">&#9670;&nbsp;</a></span>gpio_clear_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_clear_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear interrupt status on the specified GPIO. </p>
<p>This function clears any active interrupts on the specified GPIO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Pin to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga65daf9463b0aa6902604e565da854174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65daf9463b0aa6902604e565da854174">&#9670;&nbsp;</a></span>lpm_gpio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#gadbd5dcca7a3c67f0e2c2f6a7e538ef7f">gpio_port_pin_t</a>&#160;</td>
          <td class="paramname"><em>port_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the LPM Functionality over GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_pin</td><td>Chip Enable Pin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gab35b615f84e123c6f244a3f00f83bfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35b615f84e123c6f244a3f00f83bfe9">&#9670;&nbsp;</a></span>lpm_gpio_get_lpm_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lpm_gpio_get_lpm_stat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To get the LPM Status. </p>
<dl class="section return"><dt>Returns</dt><dd>Status of LPM. </dd></dl>

</div>
</div>
<a id="ga74ed132647d48c038a2b8f5fb663c97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ed132647d48c038a2b8f5fb663c97d">&#9670;&nbsp;</a></span>lpm_gpio_clr_lpm_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_clr_lpm_stat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To clear the LPM Status. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga6caaa2a2399383668c403e694d6d5758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6caaa2a2399383668c403e694d6d5758">&#9670;&nbsp;</a></span>lpm_gpio_set_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_set_intr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga534bf6468ef6937caf6db065d83845ca">gpio_intr_t</a>&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Set the Interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>interrupt type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga19fbabfd67fd86ce7060a960b5c43d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19fbabfd67fd86ce7060a960b5c43d80">&#9670;&nbsp;</a></span>lpm_gpio_clr_intr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lpm_gpio_clr_intr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Clear the Interrupt. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga464ab91815a8c55916d179cb924d6103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464ab91815a8c55916d179cb924d6103">&#9670;&nbsp;</a></span>lpm_gpio_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lpm_gpio_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To Read the LPM_GPIO. </p>
<dl class="section return"><dt>Returns</dt><dd>gpio status </dd></dl>

</div>
</div>
<a id="ga0c9ba09522c7b06b4f4b78965af64cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c9ba09522c7b06b4f4b78965af64cfc">&#9670;&nbsp;</a></span>eval_src_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_src_cap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>srcCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the PD stack to allow the application logic to evaluate the Source Capabilities received from the port partner and generate the desired request. </p>
<p>The request object is expected to be passed back to the stack through the app_resp_handler() callback.</p>
<p>The default implementation of this function matches each of the received source PDOs against the active sink capabilities; and then selects the source PDO that can deliver the maximum power to the system as a sink.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the CCG6 device, the eval_src_cap function is executed from ROM and hence changes in this function will not affect the policy engine behavior. The <a class="el" href="group__group__ccgxAppCommon__functions.html#ga92f950d9ddc50d8a7d3f69a23de108f1" title="This function is only applicable in the case of the CCG6 device, and can be used by the application l...">app_update_rdo()</a> function should be used to update the request object in this case.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">srcCap</td><td>Pointer to PD packet which contains source capabilities. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1aa9ecc53e672ff08c97ea9beb3905ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa9ecc53e672ff08c97ea9beb3905ed">&#9670;&nbsp;</a></span>eval_rdo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_rdo </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t&#160;</td>
          <td class="paramname"><em>rdo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the PD stack to allow the application to evaluate a power request data object received from the port partner and decide whether it should be satisfied. </p>
<p>The response to the request should be passed back to the stack through the app_resp_handler() callback.</p>
<dl class="section warning"><dt>Warning</dt><dd>On the CCG6 device, the eval_rdo function is executed from ROM and hence changes in this function will not affect the policy engine behavior. The application is expected to update the source capabilities registered with the PD stack based on the current system status.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">rdo</td><td>The request data object received. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga92f950d9ddc50d8a7d3f69a23de108f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f950d9ddc50d8a7d3f69a23de108f1">&#9670;&nbsp;</a></span>app_update_rdo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_update_rdo </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>srcCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t *&#160;</td>
          <td class="paramname"><em>appResp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only applicable in the case of the CCG6 device, and can be used by the application logic to modify the RDO generated by the ROM-ed version of the eval_src_cap function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">srcCap</td><td>Pointer to PD packet which contains source capabilities. </td></tr>
    <tr><td class="paramname">appResp</td><td>Response containing the updated RDO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab3817297cc85653d6201cd1e48159ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3817297cc85653d6201cd1e48159ada">&#9670;&nbsp;</a></span>psrc_set_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_set_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the VBus source voltage to the desired value. </p>
<p>It also updates the voltage thresholds associated with protection schemes such as OVP and UVP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>Voltage in mV units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1881bbbc0107059d70bc39920a6738f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1881bbbc0107059d70bc39920a6738f2">&#9670;&nbsp;</a></span>psrc_get_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t psrc_get_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the VBus source voltage that is currently configured. </p>
<p>This is different from the <a class="el" href="group__group__ccgxAppCommon__functions.html#ga0c527850e02f68c9c1072b58921fe533" title="This function return current VBUS voltage in mV. ">vbus_get_value()</a> function which measures the actual VBus voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Voltage in mV units. </dd></dl>

</div>
</div>
<a id="gad93e96d009a6e6717ffef86a79f7d223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93e96d009a6e6717ffef86a79f7d223">&#9670;&nbsp;</a></span>psrc_set_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_set_current </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cur_10mA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the VBus source current limit. </p>
<p>The current limits are used to configure the current sensing circuits to trigger fault indication in case of overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">cur_10mA</td><td>Current in 10mA units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae078c31aa1f7fce6bba129df400dc862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae078c31aa1f7fce6bba129df400dc862">&#9670;&nbsp;</a></span>psrc_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_pwr_ready_cbk_t&#160;</td>
          <td class="paramname"><em>pwr_ready_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the VBus power supply. </p>
<p>The voltage and current to be supplied would have been specified through the <a class="el" href="group__group__ccgxAppCommon__functions.html#gab3817297cc85653d6201cd1e48159ada" title="This function sets the VBus source voltage to the desired value. ">psrc_set_voltage()</a> and <a class="el" href="group__group__ccgxAppCommon__functions.html#gad93e96d009a6e6717ffef86a79f7d223" title="This function sets the VBus source current limit. ">psrc_set_current()</a> calls before the supply is enabled. The function returns as soon as the supply enable operation has been started. The pwr_ready_handler is expected to be called once VBus voltage has stabilized at the desired level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pwr_ready_handler</td><td>Application handler callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae522dada2eb76d90d46a6f428a31eff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae522dada2eb76d90d46a6f428a31eff1">&#9670;&nbsp;</a></span>psrc_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psrc_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_pwr_ready_cbk_t&#160;</td>
          <td class="paramname"><em>pwr_ready_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the VBus power supply. </p>
<p>If a non-NULL pwr_ready_handler callback is specified, the function can return after starting the VBus disable operation. The callback will be called once the VBus voltage has been safely brought to vSafe0V. If the callback is NULL, the function is expected to return after shutting down the supply without initiating any VBus discharge sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context </td></tr>
    <tr><td class="paramname">pwr_ready_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad019aef09ac99508d3cca4d2315b7df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad019aef09ac99508d3cca4d2315b7df7">&#9670;&nbsp;</a></span>ccg_sensor_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the sensor check block. </p>
<p>This should be called one time only at system startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae913d9eb9a79f913e28c8d34de043686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae913d9eb9a79f913e28c8d34de043686">&#9670;&nbsp;</a></span>ccg_sensor_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ccg_sensor_is_idle </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Facilitates to know if sensor check module is idle. </p>
<p>System sleep is allowed in idle state only. In idle state, ccg_ls_task() can run in lower frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if sensor check module is idle. True otherwise. </dd></dl>

</div>
</div>
<a id="gaea471cf36a082dfaecfa15dc4b1028c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea471cf36a082dfaecfa15dc4b1028c3">&#9670;&nbsp;</a></span>ccg_sensor_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_check </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Facilitates caller to update system operating condition to the operating condition indicated by VIN and temperature of the sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga6b142ab3e283161f9e168c898afce86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b142ab3e283161f9e168c898afce86a">&#9670;&nbsp;</a></span>ccg_sensor_debounce_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_sensor_debounce_task </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs the debounce related checks. </p>
<p>This will be called continuously, but will be executed only if the flag is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga546096050c83925d0c4099621f3486c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546096050c83925d0c4099621f3486c0">&#9670;&nbsp;</a></span>ccg_sensor_temp_ec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t ccg_sensor_temp_ec </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current sensor temperature. </p>
<p>This will be called by the EC to know the temperature of the sensors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">buffer</td><td>to which the information will be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success or Failure depending on whether temperature based throttling is enabled in the firmware </dd></dl>

</div>
</div>
<a id="ga2cfae9d8db4a74aed03c538607b6b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfae9d8db4a74aed03c538607b6b1a9">&#9670;&nbsp;</a></span>ccg_get_battery_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ccg_get_battery_voltage </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts VIN(Battery) voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Voltage in millivolts. </dd></dl>

</div>
</div>
<a id="gad1372cb404e2fdc0104e55166417b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1372cb404e2fdc0104e55166417b5f9">&#9670;&nbsp;</a></span>ccg_get_sys_oc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_sys_oc </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__macros.html#gad456bb3be6173dae2997daf53c4aabc8">CCG_OC_BUFFER_DATE_TYPE</a> *&#160;</td>
          <td class="paramname"><em>oc_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts undebounced OC specific information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">oc_buffer</td><td>Placeholder for undebounced OC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Undebounced system OC at this point of time. </dd></dl>

</div>
</div>
<a id="ga61443c0e3f64be9b85774528c6776eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61443c0e3f64be9b85774528c6776eee">&#9670;&nbsp;</a></span>ccg_set_sensor_sleep_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccg_set_sensor_sleep_mode </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the VIN OV/UV comparators for sleep mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga3e5f3c378ced3b9a9b88a864380db5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e5f3c378ced3b9a9b88a864380db5a6">&#9670;&nbsp;</a></span>eval_dr_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_dr_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates Data role swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga28f7b458a4b35ab3a85dfec4aa969001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f7b458a4b35ab3a85dfec4aa969001">&#9670;&nbsp;</a></span>eval_pr_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_pr_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates Power role swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga35bebef1cf20542c23c68e15ab2394fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35bebef1cf20542c23c68e15ab2394fe">&#9670;&nbsp;</a></span>eval_vconn_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_vconn_swap </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function evaluates VConn swap request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Application handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga606d6f10e4bf215d5ecbae3ac5422220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606d6f10e4bf215d5ecbae3ac5422220">&#9670;&nbsp;</a></span>ccg_volt_temp_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_volt_temp_map </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>therm_volt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the thermal voltage read from thermistor to temperature value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">therm_volt</td><td>The thermal voltage that must be mapped to temperature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The temperature value corresponding to the thermal voltage read </dd></dl>

</div>
</div>
<a id="gab10bbe4117fc4502f3ffe303a46a1819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10bbe4117fc4502f3ffe303a46a1819">&#9670;&nbsp;</a></span>ccg_get_sensor_temperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ccg_get_sensor_temperature </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sensor_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the temperature of the specified sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">sensor_id</td><td>The index of the sensor to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The temperature value corresponding to the thermal voltage read </dd></dl>

</div>
</div>
<a id="ga81e2b20a4fb4669bdb692d782124c94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e2b20a4fb4669bdb692d782124c94e">&#9670;&nbsp;</a></span>register_thermistor_mapping_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_thermistor_mapping_table </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>volt_temp_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function maps the thermal voltage read from thermistor to temperature value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackcontext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">volt_temp_table</td><td>Pointer to the table to be used for thermal voltage to temperature mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2b5edab6846405e6f18f4d584bf20d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5edab6846405e6f18f4d584bf20d42">&#9670;&nbsp;</a></span>uvdm_get_cur_nb_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga690ec97bf194692eae90b1276e129295">uvdm_cmd_opcode_t</a> uvdm_get_cur_nb_cmd </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current non blocking command opcode. </p>
<p>This function returns the opcode of current Non Blocking UVDM Command which can be used to form the response VDM.</p>
<dl class="section return"><dt>Returns</dt><dd>uvdm_cmd_opcode_t UVDM Command Opcode </dd></dl>

</div>
</div>
<a id="ga88917f34345b4c2ffbd7f05e004cbbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88917f34345b4c2ffbd7f05e004cbbcb">&#9670;&nbsp;</a></span>uvdm_reset_nb_cmd_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_reset_nb_cmd_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets internal state and trackers related to Non Blocking flash write operation at the end of write operation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaa6f4e6875801da6056c0c87f2785cae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6f4e6875801da6056c0c87f2785cae8">&#9670;&nbsp;</a></span>uvdm_enter_cy_alt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_enter_cy_alt_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Mode Entry Handler This function is called when CCG enters CY Flashing Alternate mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaee0e712a6dac921e9a12c1519f162132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0e712a6dac921e9a12c1519f162132">&#9670;&nbsp;</a></span>uvdm_exit_cy_alt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvdm_exit_cy_alt_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Mode Exit Handler This function is called when CCG exits CY Flashing Alternate mode. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga48049492908c61b5a2bcb7869611cf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48049492908c61b5a2bcb7869611cf89">&#9670;&nbsp;</a></span>uvdm_get_flashing_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvdm_get_flashing_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return CY Flashing Mode Status This function returns the current state of CY Flashing Alternate Mode. </p>
<dl class="section return"><dt>Returns</dt><dd>true if CY Flashing Mode active, false otherwise. </dd></dl>

</div>
</div>
<a id="gae932229b8c737c4f5f9605d19c64c439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae932229b8c737c4f5f9605d19c64c439">&#9670;&nbsp;</a></span>uvdm_handle_device_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t uvdm_handle_device_reset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reset_sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle Device Reset Command This function handles device Reset command. </p>
<p>Device Reset handling is application specific and hence this routine shall be implemented at Solution level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reset_sig</td><td>Type of Reset: Device Reset, Jump to bootloader or Jump to Alt image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_pdstack_status_t </dd></dl>

</div>
</div>
<a id="ga45a21400ab342fd3552ed6791a834f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45a21400ab342fd3552ed6791a834f88">&#9670;&nbsp;</a></span>uvdm_handle_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> uvdm_handle_cmd </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t **&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga3dd798364911c9f1c1e8c93db6976f8e">flash_cbk_t</a>&#160;</td>
          <td class="paramname"><em>flash_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CY Flashing Alternate Mode UVDM Command Handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to pdstack </td></tr>
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response </td></tr>
    <tr><td class="paramname">flash_cb</td><td>Callback function for Non Blocking Flash Write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="gace292f2968c8a0fbe52bd5fb817219d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace292f2968c8a0fbe52bd5fb817219d9">&#9670;&nbsp;</a></span>uvdm_qc_pps_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> uvdm_qc_pps_handler </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t **&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles all QC 5.0/4.0 Protocol UVDM commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>PD stack context </td></tr>
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="ga9937839e0df56ab2ae92677a3c4fc89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9937839e0df56ab2ae92677a3c4fc89c">&#9670;&nbsp;</a></span>sln_flashing_uvdm_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga5e70c33f2bd3c8f24494776269a35ad7">uvdm_response_state_t</a> sln_flashing_uvdm_handler </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pd_pd_do_t *&#160;</td>
          <td class="paramname"><em>vdm_rspn_pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>vdo_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_pdstack_status_t *&#160;</td>
          <td class="paramname"><em>response_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flashing Alternate Mode UVDM Command solution space extension handler. </p>
<p>This function is invoked by the flashing UVDM handler if the SLN_FLASHING_UVDM_HANDLER_ENABLE is enabled and the standard handler is not able to resolve.</p>
<p>NOTE: Since the function is for extending avaiable solution in the standard handler, the data structures are re-used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx_pkt</td><td>Pointer to VDM Command </td></tr>
    <tr><td class="paramname">vdm_rspn_pkt</td><td>Pointer to the VDM response packet (allocation done in uvdm.c) </td></tr>
    <tr><td class="paramname">vdo_count</td><td>Number of VDOs in VDM response, 0 if no VDM Response </td></tr>
    <tr><td class="paramname">response_code</td><td>Response status code to be returned in the UVDM response</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uvdm_response_state_t </dd></dl>

</div>
</div>
<a id="gaba9d243d72311578fc26927b0d8b3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba9d243d72311578fc26927b0d8b3d18">&#9670;&nbsp;</a></span>pwm_get_duty_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pwm_get_duty_cycle </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vbus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_volt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pwm_period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function computes PWM duty cycle needed to generate requested VBUS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbus</td><td>The voltage to set to in mV units </td></tr>
    <tr><td class="paramname">min_volt</td><td>Minimum VBUS as per design in mv </td></tr>
    <tr><td class="paramname">max_volt</td><td>Maximum VBUS as per design in mv </td></tr>
    <tr><td class="paramname">pwm_period</td><td>Period of the PWM signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM duty cycle in terms of PWM on time. </dd></dl>

</div>
</div>
<a id="ga0176c9ee7a447e6d05e118ec148581c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0176c9ee7a447e6d05e118ec148581c3">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_turn_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_turn_on </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the PWM signal that turns VBus ON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1dbe2b31bf4f30e721228591b8420357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dbe2b31bf4f30e721228591b8420357">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_turn_off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_turn_off </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function disables the PWM signal thus turning VBus OFF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2bd5743b05e845340eea6f5c7054c0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd5743b05e845340eea6f5c7054c0e0">&#9670;&nbsp;</a></span>vbus_ctrl_pwm_set_volt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_pwm_set_volt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the Type-C VBUS voltage to requested level using PWM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>The voltage to set to in mV units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gabcd12abd4dc2a695f0aca4fcc9e9b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd12abd4dc2a695f0aca4fcc9e9b9be">&#9670;&nbsp;</a></span>vbus_ctrl_fb_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_enable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function enables the Type-C VBUS voltage feedback logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaf7e37244c8eb9e2b5a85195fb5aa04c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e37244c8eb9e2b5a85195fb5aa04c1">&#9670;&nbsp;</a></span>vbus_ctrl_fb_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_disable </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function disables the Type-C VBUS voltage feedback logic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5534b8c6f4249d42f6719791ed55ff38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5534b8c6f4249d42f6719791ed55ff38">&#9670;&nbsp;</a></span>vbus_ctrl_fb_set_volt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vbus_ctrl_fb_set_volt </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function sets the Type-C VBUS voltage to requested level using FB (feedback). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mV</td><td>The voltage to set to in mV units. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga7c5f522c241cad2d51bac5a524312fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5f522c241cad2d51bac5a524312fe7">&#9670;&nbsp;</a></span>vbus_ctrl_set_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vbus_ctrl_set_is_idle </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns whether the vbus voltage transition is over or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vbus transition is over, otherwise False. </dd></dl>

</div>
</div>
<a id="ga7d395b4a3c133de574b7362d20540c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d395b4a3c133de574b7362d20540c8b">&#9670;&nbsp;</a></span>vbus_ctrl_get_trim_idac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t vbus_ctrl_get_trim_idac </td>
          <td>(</td>
          <td class="paramtype">cy_stc_usbpd_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>volt_mv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns trimmed IDAC value for the required voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack Context </td></tr>
    <tr><td class="paramname">volt_mv</td><td>Required source voltage in mV </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idac Signed IDAC value for the requested voltage</dd></dl>
<p><b>Applicable devices:</b> CCG3PA, CCG3PA2, PAG1S, CCG7D, CCG7S. </p>

</div>
</div>
<a id="ga3d7b269e24c8f4fec661273d02586fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d7b269e24c8f4fec661273d02586fa3">&#9670;&nbsp;</a></span>vdm_data_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_data_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store the VDM data from the configuration table. </p>
<p>This function retrieves the VDM data (for CCG as UFP) that is stored in the configuration table and stores it in the run-time data structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="gae954f67f0c7fc0fa4d0b77e86d39efa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae954f67f0c7fc0fa4d0b77e86d39efa9">&#9670;&nbsp;</a></span>vdm_update_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_update_data </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id_vdo_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>id_vdo_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>svid_vdo_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>svid_vdo_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mode_resp_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mode_resp_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows the VDM data for CCG to be changed. </p>
<p>This function allows the user to change the VDM responses that CCG sends for D_ID, D_SVID and D_MODE requests. The default responses are taken from the configuration table. This function allows the user to change the response data. The caller is responsible to ensure that the responses are not changed while CCG is already in contract as a UFP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">id_vdo_cnt</td><td>Number of VDOs in the D_ID response. </td></tr>
    <tr><td class="paramname">id_vdo_p</td><td>Pointer to the actual D_ID response in memory. </td></tr>
    <tr><td class="paramname">svid_vdo_cnt</td><td>Number of VDOs in the D_SVID response. Should be less than 8. </td></tr>
    <tr><td class="paramname">svid_vdo_p</td><td>Pointer to the actual D_SVID response in memory. </td></tr>
    <tr><td class="paramname">mode_resp_len</td><td>Total length of mode response. This includes the D_MODE responses for each supported SVID, along with the corresponding header fields. </td></tr>
    <tr><td class="paramname">mode_resp_p</td><td>Pointer to all of the mode responses in memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4b760125b3e49c10b90e064750acb68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b760125b3e49c10b90e064750acb68e">&#9670;&nbsp;</a></span>eval_vdm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_vdm </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>vdm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_vdm_resp_cbk_t&#160;</td>
          <td class="paramname"><em>vdm_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is responsible for analyzing and processing received VDM. </p>
<p>This function also makes a decision about necessity of response to the received VDM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">vdm</td><td>Pointer to pd packet which contains received VDM. </td></tr>
    <tr><td class="paramname">vdm_resp_handler</td><td>VDM handler callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga4d682bedad7997cf296ac7b472ccb4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d682bedad7997cf296ac7b472ccb4e5">&#9670;&nbsp;</a></span>eval_enter_usb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eval_enter_usb </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cy_stc_pdstack_pd_packet_t *&#160;</td>
          <td class="paramname"><em>eudo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_pdstack_app_resp_cbk_t&#160;</td>
          <td class="paramname"><em>app_resp_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to evaluate an Enter_USB request and report whether it should be accepted or rejected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD Stack context. </td></tr>
    <tr><td class="paramname">eudo</td><td>Pointer to the Enter_USB packet. </td></tr>
    <tr><td class="paramname">app_resp_handler</td><td>Response callback through which the response is passed to the PD stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga07f91bf53ad0b7c9ce8bc3727ef8512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07f91bf53ad0b7c9ce8bc3727ef8512d">&#9670;&nbsp;</a></span>vdm_assign_port_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vdm_assign_port_num </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign unique port number in a CCG3PA multiport system. </p>
<p>This port number overrides the port number configured in configuration table. DFP VDO in discover identity response shall respond with this port number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>PD stack context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga5a7f98716771b456abbe7bd132d8255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7f98716771b456abbe7bd132d8255f">&#9670;&nbsp;</a></span>boot_validate_configtable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_validate_configtable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>table_p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the configuration table specified. </p>
<p>Each copy of CCGx firmware on the device flash contains an embedded configuration table that defines the runtime behaviour of the CCGx device. This function checks whether the configuration table located at the specified location is valid (has valid signature and checksum).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_p</td><td>Pointer to the configuration table to be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS if the table is valid, CCG_STAT_FAILURE otherwise. </dd></dl>

</div>
</div>
<a id="ga1edb32e1e45d388147185b053875f8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1edb32e1e45d388147185b053875f8fe">&#9670;&nbsp;</a></span>boot_validate_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_validate_fw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#structsys__fw__metadata__t">sys_fw_metadata_t</a> *&#160;</td>
          <td class="paramname"><em>fw_metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the firmware image associated with the given metadata. </p>
<p>This function validates the firmware binary associated with the metadata specified in the fw_metadata parameter. The validity check includes checks for signature, location, size and checksum. This function internally performs validation of the embedded configuration table using the boot_validate_configtable function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw_metadata</td><td>Pointer to metadata table of the FW which has to be validated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CCG_STAT_SUCCESS if the firmware is valid, CCG_STAT_FAILURE otherwise. </dd></dl>

</div>
</div>
<a id="ga861588454fc735f940e5cdaaaa65cce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861588454fc735f940e5cdaaaa65cce9">&#9670;&nbsp;</a></span>boot_handle_validate_fw_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t boot_handle_validate_fw_cmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gaf9e3ae39360ed4676f284cfcbd27f090">sys_fw_mode_t</a>&#160;</td>
          <td class="paramname"><em>fw_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles the VALIDATE_FW command from HPI or UVDM. </p>
<p>This API handles the VALIDATE_FW command received through the HPI or UVDM interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fw_mode</td><td>Firmware binary id: 1 for FW1 and 2 for FW2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating the validity of the firmware. </dd></dl>

</div>
</div>
<a id="ga86165e9d25f534b61706bce73087523a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86165e9d25f534b61706bce73087523a">&#9670;&nbsp;</a></span>boot_get_wait_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t boot_get_wait_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the boot-wait delay configured for the application. </p>
<p>This function identifies the boot-wait delay required by checking the firmware metadata.</p>
<dl class="section return"><dt>Returns</dt><dd>Boot-wait delay in milliseconds. </dd></dl>

</div>
</div>
<a id="gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f73e8f2ef043dc5f9e7fdbd9a2d5f9">&#9670;&nbsp;</a></span>boot_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool boot_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the firmware binary to be loaded. </p>
<p>This function is only used in the CCGx boot-loader, and implements the main start-up logic of the boot-loader. The function validates the two firmware binaries in device flash, and identifies the binary to be loaded. If neither binary is valid, the function returns false notifying the caller to continue in boot-loader mode.</p>
<dl class="section return"><dt>Returns</dt><dd>true if firmware load is allowed, false otherwise. </dd></dl>

</div>
</div>
<a id="ga12781921cca4e29d0c7516cc7431da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12781921cca4e29d0c7516cc7431da31">&#9670;&nbsp;</a></span>boot_check_for_valid_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_check_for_valid_fw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the presence of alternate firmware waiting to be validated. </p>
<p>This function checks whether the CCGx device flash contains an alternate firmware binary which is waiting to be validated. This can happen if a firmware update happened during the last power up of the device, and the binary is yet to be validated and made active. The active firmware will make use of the pseudo metadata in flash to identify the alternate firmware, validate it and activate it by updating the actual firmware metadata.</p>
<p>Please refer to the CCGx boot sequence description in the firmware guide for a more detailed description of the boot procedure.</p>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga8c99ecc08d4d9906ab7cea73c403241d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c99ecc08d4d9906ab7cea73c403241d">&#9670;&nbsp;</a></span>iecs_check_for_valid_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iecs_check_for_valid_fw </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>first_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a alternate firmware according to IECS SFWv command. </p>
<p>This function validate alternate firmware binary. EC update flash rows step by step without the first row and after that send SFWv command to validate FW signature. if a firmware signature is correct function writes a first row of a image to flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_row</td><td>Poineter to the first row of FW image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="ga734e1c7b35b3b51709c1997cf4b27adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga734e1c7b35b3b51709c1997cf4b27adc">&#9670;&nbsp;</a></span>get_boot_mode_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#unionfw__img__status__t">fw_img_status_t</a> get_boot_mode_reason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a bitmap containing the reason for boot mode. </p>
<p>This function returns the bitmap value that is to be stored in the BOOT_MODE_REASON HPI register, which identifies the validity of the two firmware binaries. The validation of the firmware is expected to have been completed earlier through the boot_start function. This function only retrieves the status stored during the validation procedure.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__ccgxAppCommon__data__structures.html#unionfw__img__status__t" title="Boot mode reason structure. ">fw_img_status_t</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Boot mode reason bitmap. </dd></dl>

</div>
</div>
<a id="ga06f1bc2f59ba8e0476dd349d1d2970eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f1bc2f59ba8e0476dd349d1d2970eb">&#9670;&nbsp;</a></span>boot_jump_to_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_jump_to_fw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer control to the firmware binary identified by boot_start. </p>
<p>This function is only used by the CCGx boot-loader. This transfers control to the firmware binary selected as the boot target by the boot_start function. This is expected to be called after the boot-wait window has elapsed.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae7d02f78bb5df076263df291bb175ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d02f78bb5df076263df291bb175ea0">&#9670;&nbsp;</a></span>boot_get_boot_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t boot_get_boot_seq </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>fwid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the boot sequence number value for the specified firmware image. </p>
<p>A boot sequence number field stored in the firmware metadata is used by the CCGx boot-loader to identify the firmware binary to be loaded. This function retrieves the sequence number associated with the specified firmware binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fwid</td><td>Firmware id whose sequence number is to be retrieved. 1 for FW1 and 2 for FW2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boot sequence number value if the firmware is valid, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga9ea7548753e977c3e1509c663150b39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea7548753e977c3e1509c663150b39c">&#9670;&nbsp;</a></span>boot_update_fw_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_update_fw_status </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to validate firmware images and update image status. </p>
<p>This function is used to validate the firmware images in the CCG device flash and update their status in the image status / boot-mode reason field.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga92a19c1628a70d606e705085976c8c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a19c1628a70d606e705085976c8c3a">&#9670;&nbsp;</a></span>boot_jump_to_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void boot_jump_to_app </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>appId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to jump from bootloader to application. </p>
<p>This function is used to validate the firmware images in the CCG device flash and update their status in the image status / boot-mode reason field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">appId</td><td>application Id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga37dda9a1fc8dfcbf1fc1df46a26e21b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37dda9a1fc8dfcbf1fc1df46a26e21b1">&#9670;&nbsp;</a></span>flash_enter_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_enter_mode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga30137929a443c18c3d02c0a5158fc77e">flash_interface_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>data_in_place</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle ENTER_FLASHING_MODE Command. </p>
<p>This function notifies the CCG stack that flash read/write is being enabled by the application. By default, CCG firmware disallows all flash read/write operations. Flash access is only allowed after flashing mode has been explicitly enabled through user command.</p>
<p>Note: FW update interface is allowed to Enable Flashing mode only once in one session. This is to ensure that multiple flashing interfaces are not active simultaneously. Each FW update interface is expected to take care of this. Once Flash access is complete, this API should be used to exit FW Update interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_enable</td><td>Enable/Disable Flashing Mode </td></tr>
    <tr><td class="paramname">mode</td><td>Flash update interface to be used. </td></tr>
    <tr><td class="paramname">data_in_place</td><td>Specifies whether the flash write data buffer can be used in place as SROM API parameter buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga1e00a477f64eff99c2c57b743a4beed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e00a477f64eff99c2c57b743a4beed3">&#9670;&nbsp;</a></span>flash_access_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool flash_access_get_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>modes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether flashing mode has been entered. </p>
<p>This function checks whether flashing mode has currently been entered by a different interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>Bitmap containing flashing interfaces to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if flashing mode has been entered using any of the interfaces listed in modes, false otherwise. </dd></dl>

</div>
</div>
<a id="ga0e0981b2faa41026199bd7202ac4fce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e0981b2faa41026199bd7202ac4fce4">&#9670;&nbsp;</a></span>flash_set_access_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_set_access_limits </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>last_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>md_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bl_last_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set limits to the flash rows that can be accessed. </p>
<p>The CCG stack has been designed to support fail-safe firmware upgrades using a pair of firmware binaries that can mutually update each other. This scheme can only be robust if the currently active firmware binary can effectively protect itself by not allowing access to any of its own flash rows.</p>
<p>This function is used to specify the list of flash rows that can safely be accessed by the currently active firmware binary. This function should only be used with parameters derived based on the binary locations identified from firmware metadata. Incorrect usage of this API can cause the device to stop responding during a flash update operation.</p>
<p>This API must be invoked as part of intialization before the <a class="el" href="group__group__ccgxAppCommon__functions.html#gab33465f26b6373367558a6828d3c062a" title="Write the given data to the specified flash row. ">flash_row_write()</a> and <a class="el" href="group__group__ccgxAppCommon__functions.html#gab1397878176494d34c481aa5799ae6df" title="Read the contents of the specified flash row. ">flash_row_read()</a> functions can be called. By default, no flash row can be read or written to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_row</td><td>The lowest row number that can be written. </td></tr>
    <tr><td class="paramname">last_row</td><td>The highest row number that can be written. </td></tr>
    <tr><td class="paramname">md_row</td><td>Row containing metadata for the alternate firmware. </td></tr>
    <tr><td class="paramname">bl_last_row</td><td>Last bootloader row. Rows above this can be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae8aa6a0c5dbdb43aabbba13b5f996eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8aa6a0c5dbdb43aabbba13b5f996eb4">&#9670;&nbsp;</a></span>flash_get_access_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_get_access_limits </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>access_limit_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>access_limit_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>access_limit_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>access_limit_3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract current flash access limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">access_limit_0</td><td>Start row num for flash write access </td></tr>
    <tr><td class="paramname">access_limit_1</td><td>Last row num for flash write access </td></tr>
    <tr><td class="paramname">access_limit_2</td><td>Metadata row num </td></tr>
    <tr><td class="paramname">access_limit_3</td><td>Start row num for read access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gaf2d6633acf126e6734b1121a88243f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d6633acf126e6734b1121a88243f5c">&#9670;&nbsp;</a></span>flash_row_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t flash_row_clear </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the contents of the specified flash row. </p>
<p>This API erases the contents of the specified flash row by filling it with zeroes. Please note that this API will only work if flashing mode is enabled and the selected row is within the range of write enabled rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_num</td><td>Row number to be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of row erase operation. </dd></dl>

</div>
</div>
<a id="gab33465f26b6373367558a6828d3c062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab33465f26b6373367558a6828d3c062a">&#9670;&nbsp;</a></span>flash_row_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t flash_row_write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#ga3dd798364911c9f1c1e8c93db6976f8e">flash_cbk_t</a>&#160;</td>
          <td class="paramname"><em>cbk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the given data to the specified flash row. </p>
<p>This API handles the flash write row operation. The contents from the data buffer is written to the row_num flash row. The access rules for the flash row as the same as for the flash_row_clear API.</p>
<p>For non-blocking write row operation, the API returns as soon as the row update is started. The stack takes care of executing all of the steps across multiple resume interrupts; and the callback is called at the end of the process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_num</td><td>Flash row to be updated. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer containing data to be written to the flash row. </td></tr>
    <tr><td class="paramname">cbk</td><td>Callback function to be called at the end of non-blocking flash write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the flash write. CCG_STAT_SUCCESS or appropriate error code. </dd></dl>

</div>
</div>
<a id="ga4bc72fbbb74b965c13ade195271c5e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc72fbbb74b965c13ade195271c5e08">&#9670;&nbsp;</a></span>sflash_row_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t sflash_row_write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the given data to the specified User SFLASH row. </p>
<p>This API handles writes to the user region in SFLASH of the CCG device. The function ensures that SFLASH rows containing Cypress proprietary configuration and test data is not cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_num</td><td>Flash row to be updated. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer containing data to be written to the SFLASH row.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the flash write. CCG_STAT_SUCCESS or appropriate error code. </dd></dl>

</div>
</div>
<a id="gaf3a462aee5dc2858a9594632fafaaf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a462aee5dc2858a9594632fafaaf3f">&#9670;&nbsp;</a></span>sflash_row_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t sflash_row_read </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of the specified User SFLASH row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_num</td><td>Flash row to be read. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer to read the SFLASH row content into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the flash read. CCG_STAT_SUCCESS or appropriate error code. </dd></dl>

</div>
</div>
<a id="gab1397878176494d34c481aa5799ae6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1397878176494d34c481aa5799ae6df">&#9670;&nbsp;</a></span>flash_row_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t flash_row_read </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of the specified flash row. </p>
<p>This API handles the flash read row operation. The contents of the flash row are copied into the specified data buffer, if flashing mode has been entered and the row_num is part of the readable range of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_num</td><td>Flash row to be read. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer to read the flash row content into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the flash read. CCG_STAT_SUCCESS or appropriate error code. </dd></dl>

</div>
</div>
<a id="ga8ec52899db03a736518d26b78058a64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec52899db03a736518d26b78058a64f">&#9670;&nbsp;</a></span>flash_set_app_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_pdstack_status_t flash_set_app_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga6633ac9f2f92f32e11085c5aca014b46">flash_app_priority_t</a>&#160;</td>
          <td class="paramname"><em>app_priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the app boot priority flag. </p>
<p>This function is used to set the app priority field to override the default FW selection algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app_priority</td><td>Desired boot priority setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code of the priority update. </dd></dl>

</div>
</div>
<a id="ga333040c32b526560e0189685c2477943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga333040c32b526560e0189685c2477943">&#9670;&nbsp;</a></span>instrumentation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize data structures associated with application instrumentation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad367c15b42304176602a24ab5cc659a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad367c15b42304176602a24ab5cc659a8">&#9670;&nbsp;</a></span>instrumentation_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start any timers or tasks associated with application instrumentation. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gafe5f4d31cceda3638f9d2c3831c34cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5f4d31cceda3638f9d2c3831c34cdc">&#9670;&nbsp;</a></span>instrumentation_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_task </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform tasks associated with application instrumentation. </p>
<p>The specific functionality implemented is user defined and can vary. </p><dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gab8347fe4114de4120402ee8a63fce69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8347fe4114de4120402ee8a63fce69b">&#9670;&nbsp;</a></span>instrumentation_register_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrumentation_register_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon.html#gaa07a7ee21510d24dac6326ec163d8e3c">instrumentation_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register solution level callback function to be executed when instrumentation fault occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gad8e95b70077dc7b63704262bff2cbf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e95b70077dc7b63704262bff2cbf0d">&#9670;&nbsp;</a></span>watchdog_timer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watchdog_timer_cb </td>
          <td>(</td>
          <td class="paramtype">cy_timer_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer callback to reset device if main loop has not been run as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer Id </td></tr>
    <tr><td class="paramname">callbackContext</td><td>Callback pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0744c70187ce4c00822179005c6c0b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0744c70187ce4c00822179005c6c0b2b">&#9670;&nbsp;</a></span>i2c_scb_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_init </td>
          <td>(</td>
          <td class="paramtype">cy_stc_pdstack_context_t *&#160;</td>
          <td class="paramname"><em>ptrPdStackContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga929dc6e6ed7bb0e330bcbd1285acc0d1">i2c_scb_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__enums.html#ga39039019bd1c23cdc1d45a1bf0ea8b74">i2c_scb_clock_freq_t</a>&#160;</td>
          <td class="paramname"><em>clock_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__ccgxAppCommon__data__structures.html#gad247990093dcf83bc7a86f1215878b05">i2c_cb_fun_t</a>&#160;</td>
          <td class="paramname"><em>cb_fun_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>scratch_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>scratch_buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure one of the I2C blocks as required. </p>
<p>This API is used to enable and configure one of the I2C blocks for driver operation. Only I2C slave operation is currently supported by the driver as of now.</p>
<p>The I2C driver is agnostic of the actual data transfer protocol. It reads all data written by the master into a receive buffer provided by the protocol layer. A callback function is used to notify the protocol layer when the write is complete. The receive buffer provided should be big enough to hold the maximum amount of data that the master may provide in a write operation. If the write contains more data than the buffer can hold, the I2C driver will NAK the transaction.</p>
<p>Read requests from the I2C master are automatically delayed by clock stretching. A callback function is used to notify the protocol layer that the master is waiting for data. The i2c_scb_write function can be used by the protocol layer to write data into the transmit FIFO in response to the read request.</p>
<p>All I2C driver events are generated from interrupt context, and are expected to be handled with care. The protocol layer should defer any long operations to a non-interrupt context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB index being configured for I2C operation. </td></tr>
    <tr><td class="paramname">mode</td><td>Desired mode of operation. </td></tr>
    <tr><td class="paramname">clock_freq</td><td>Desired I2C clock frequency. </td></tr>
    <tr><td class="paramname">slave_addr</td><td>Device address to be used in case of slave operation. </td></tr>
    <tr><td class="paramname">slave_mask</td><td>Mask to be applied on for slave address matching. </td></tr>
    <tr><td class="paramname">cb_fun_ptr</td><td>Callback function to be called for event notification. </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>Receive buffer used to hold written by master. </td></tr>
    <tr><td class="paramname">scratch_buffer_size</td><td>Size of the receive buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>This API is used to enable and configure one of the I2C blocks for driver operation. Only I2C slave operation is currently supported by the driver as of now.</p>
<p>The I2C driver is agnostic of the actual data transfer protocol. It reads all data written by the master into a receive buffer provided by the protocol layer. A callback function is used to notify the protocol layer when the write is complete. The receive buffer provided should be big enough to hold the maximum amount of data that the master may provide in a write operation. If the write contains more data than the buffer can hold, the I2C driver will NAK the transaction.</p>
<p>Read requests from the I2C master are automatically delayed by clock stretching. A callback function is used to notify the protocol layer that the master is waiting for data. The i2c_scb_write function can be used by the protocol layer to write data into the transmit FIFO in response to the read request.</p>
<p>All I2C driver events are generated from interrupt context, and are expected to be handled with care. The protocol layer should defer any long operations to a non-interrupt context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrPdStackContext</td><td>Pointer to pdstack context. </td></tr>
    <tr><td class="paramname">scb_index</td><td>SCB index being configured for I2C operation. </td></tr>
    <tr><td class="paramname">mode</td><td>Desired mode of operation. </td></tr>
    <tr><td class="paramname">clock_freq</td><td>Desired I2C clock frequency. </td></tr>
    <tr><td class="paramname">slave_addr</td><td>Device address to be used in case of slave operation. </td></tr>
    <tr><td class="paramname">slave_mask</td><td>Mask to be applied on for slave address matching. </td></tr>
    <tr><td class="paramname">cb_fun_ptr</td><td>Callback function to be called for event notification. </td></tr>
    <tr><td class="paramname">scratch_buffer</td><td>Receive buffer used to hold written by master. </td></tr>
    <tr><td class="paramname">scratch_buffer_size</td><td>Size of the receive buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga64f4c815aac116cc730b5166787962a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f4c815aac116cc730b5166787962a1">&#9670;&nbsp;</a></span>i2c_scb_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_deinit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize a previously initialized SCB block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB index to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga378575c70ffa0b89f129860177848143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga378575c70ffa0b89f129860177848143">&#9670;&nbsp;</a></span>i2c_scb_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>source_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into the transmit FIFO associated with the I2C block. </p>
<p>This function is used by the protocol layer to write data into the I2C transmit FIFO in response to a master read operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to do the I2C transfer through. </td></tr>
    <tr><td class="paramname">source_ptr</td><td>Pointer to buffer containing the data to be written. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data buffer. Maximum amount of data that may be written. </td></tr>
    <tr><td class="paramname">count</td><td>Return parameter through which the actual write size is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="gae2cbeecd552d2640e432e2c57111f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cbeecd552d2640e432e2c57111f35c">&#9670;&nbsp;</a></span>i2c_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the I2C block specified. </p>
<p>This function resets the I2C block in response to an error or explicit request from protocol layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Reset the I2C block specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>Index of the I2C block to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga472c6396fd36ea9ddda27cc6ef9e6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga472c6396fd36ea9ddda27cc6ef9e6986">&#9670;&nbsp;</a></span>i2c_slave_ack_ctrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_slave_ack_ctrl </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable the I2C slave acknowledgement. </p>
<p>This function enables/disables the slave address ACK from the I2C block. The protocol layer can disable the address ACK to hold off data transfers when it is not ready to respond to the master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to configure. </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable or disable the auto slave address acknowledgement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga2c52132c4b3089409dac99443ed4a231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c52132c4b3089409dac99443ed4a231">&#9670;&nbsp;</a></span>i2c_scb_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_scb_is_idle </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the I2C block is idle. </p>
<p>This function checks whether the specified I2C block is idle. This check should be performed before the device enters deep sleep. Deep sleep entry should be avoided if this function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C block is idle, false otherwise. </dd></dl>

</div>
</div>
<a id="ga706524d3e4a8d5a195d7cb940e9149e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga706524d3e4a8d5a195d7cb940e9149e4">&#9670;&nbsp;</a></span>i2c_scb_enable_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_scb_enable_wakeup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>scb_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable deep-sleep wakeup due to address match on the specified SCB block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb_index</td><td>SCB ID to be configured as deep-sleep wakeup trigger.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga0d55f6c9d1f49de78bd51450f176d24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d55f6c9d1f49de78bd51450f176d24d">&#9670;&nbsp;</a></span>i2c_timer_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_timer_cb </td>
          <td>(</td>
          <td class="paramtype">cy_timer_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer callback that indicates I2C transaction that has timed out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackContext</td><td>Callback pointer. </td></tr>
    <tr><td class="paramname">id</td><td>The timer id used to time I2C transactions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<p>Timer callback that indicates I2C transaction that has timed out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Timer ID that is used to specify the SCB block. </td></tr>
    <tr><td class="paramname">callbackContext</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CCGx App Common</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
